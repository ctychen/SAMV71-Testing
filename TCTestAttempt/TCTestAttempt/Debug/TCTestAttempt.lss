
TCTestAttempt.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000015a8  00400000  00400000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000000  20400000  20400000  000115a8  2**0
                  CONTENTS
  2 .bss          00000110  20400000  20400000  00020000  2**2
                  ALLOC
  3 .heap         00000200  20400110  20400110  00020000  2**0
                  ALLOC
  4 .stack        00000400  20400310  20400310  00020000  2**0
                  ALLOC
  5 .ARM.attributes 0000002e  00000000  00000000  000115a8  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  000115d6  2**0
                  CONTENTS, READONLY
  7 .debug_info   0000d7ba  00000000  00000000  0001162f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00002050  00000000  00000000  0001ede9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00005e88  00000000  00000000  00020e39  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000500  00000000  00000000  00026cc1  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000004f0  00000000  00000000  000271c1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  0003c54e  00000000  00000000  000276b1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000cf9c  00000000  00000000  00063bff  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00148505  00000000  00000000  00070b9b  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00000c1c  00000000  00000000  001b90a0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <exception_table>:
  400000:	10 07 40 20 e5 01 40 00 e1 01 40 00 e1 01 40 00     ..@ ..@...@...@.
  400010:	e1 01 40 00 e1 01 40 00 e1 01 40 00 00 00 00 00     ..@...@...@.....
	...
  40002c:	e1 01 40 00 e1 01 40 00 00 00 00 00 e1 01 40 00     ..@...@.......@.
  40003c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40004c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40005c:	e1 01 40 00 e1 01 40 00 00 00 00 00 19 09 40 00     ..@...@.......@.
  40006c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40007c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40008c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40009c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  4000ac:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  4000bc:	e1 01 40 00 e1 01 40 00 e1 01 40 00 c9 0e 40 00     ..@...@...@...@.
  4000cc:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  4000dc:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  4000ec:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  4000fc:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40010c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 00 00 00 00     ..@...@...@.....
  40011c:	00 00 00 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ......@...@...@.
  40012c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40013c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40014c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40015c:	e1 01 40 00 e1 01 40 00 e1 01 40 00                 ..@...@...@.

00400168 <__do_global_dtors_aux>:
  400168:	b510      	push	{r4, lr}
  40016a:	4c05      	ldr	r4, [pc, #20]	; (400180 <__do_global_dtors_aux+0x18>)
  40016c:	7823      	ldrb	r3, [r4, #0]
  40016e:	b933      	cbnz	r3, 40017e <__do_global_dtors_aux+0x16>
  400170:	4b04      	ldr	r3, [pc, #16]	; (400184 <__do_global_dtors_aux+0x1c>)
  400172:	b113      	cbz	r3, 40017a <__do_global_dtors_aux+0x12>
  400174:	4804      	ldr	r0, [pc, #16]	; (400188 <__do_global_dtors_aux+0x20>)
  400176:	f3af 8000 	nop.w
  40017a:	2301      	movs	r3, #1
  40017c:	7023      	strb	r3, [r4, #0]
  40017e:	bd10      	pop	{r4, pc}
  400180:	20400000 	.word	0x20400000
  400184:	00000000 	.word	0x00000000
  400188:	004015a8 	.word	0x004015a8

0040018c <frame_dummy>:
  40018c:	4b0c      	ldr	r3, [pc, #48]	; (4001c0 <frame_dummy+0x34>)
  40018e:	b143      	cbz	r3, 4001a2 <frame_dummy+0x16>
  400190:	480c      	ldr	r0, [pc, #48]	; (4001c4 <frame_dummy+0x38>)
  400192:	490d      	ldr	r1, [pc, #52]	; (4001c8 <frame_dummy+0x3c>)
  400194:	b510      	push	{r4, lr}
  400196:	f3af 8000 	nop.w
  40019a:	480c      	ldr	r0, [pc, #48]	; (4001cc <frame_dummy+0x40>)
  40019c:	6803      	ldr	r3, [r0, #0]
  40019e:	b923      	cbnz	r3, 4001aa <frame_dummy+0x1e>
  4001a0:	bd10      	pop	{r4, pc}
  4001a2:	480a      	ldr	r0, [pc, #40]	; (4001cc <frame_dummy+0x40>)
  4001a4:	6803      	ldr	r3, [r0, #0]
  4001a6:	b933      	cbnz	r3, 4001b6 <frame_dummy+0x2a>
  4001a8:	4770      	bx	lr
  4001aa:	4b09      	ldr	r3, [pc, #36]	; (4001d0 <frame_dummy+0x44>)
  4001ac:	2b00      	cmp	r3, #0
  4001ae:	d0f7      	beq.n	4001a0 <frame_dummy+0x14>
  4001b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  4001b4:	4718      	bx	r3
  4001b6:	4b06      	ldr	r3, [pc, #24]	; (4001d0 <frame_dummy+0x44>)
  4001b8:	2b00      	cmp	r3, #0
  4001ba:	d0f5      	beq.n	4001a8 <frame_dummy+0x1c>
  4001bc:	4718      	bx	r3
  4001be:	bf00      	nop
  4001c0:	00000000 	.word	0x00000000
  4001c4:	004015a8 	.word	0x004015a8
  4001c8:	20400004 	.word	0x20400004
  4001cc:	004015a8 	.word	0x004015a8
  4001d0:	00000000 	.word	0x00000000

004001d4 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
  4001d4:	b508      	push	{r3, lr}
	system_init();
  4001d6:	4b01      	ldr	r3, [pc, #4]	; (4001dc <atmel_start_init+0x8>)
  4001d8:	4798      	blx	r3
  4001da:	bd08      	pop	{r3, pc}
  4001dc:	004002f9 	.word	0x004002f9

004001e0 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  4001e0:	e7fe      	b.n	4001e0 <Dummy_Handler>
	...

004001e4 <Reset_Handler>:
{
  4001e4:	b508      	push	{r3, lr}
        if (pSrc != pDest) {
  4001e6:	4b10      	ldr	r3, [pc, #64]	; (400228 <Reset_Handler+0x44>)
  4001e8:	4a10      	ldr	r2, [pc, #64]	; (40022c <Reset_Handler+0x48>)
  4001ea:	429a      	cmp	r2, r3
  4001ec:	d009      	beq.n	400202 <Reset_Handler+0x1e>
  4001ee:	4b0e      	ldr	r3, [pc, #56]	; (400228 <Reset_Handler+0x44>)
  4001f0:	4a0e      	ldr	r2, [pc, #56]	; (40022c <Reset_Handler+0x48>)
  4001f2:	e003      	b.n	4001fc <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
  4001f4:	6811      	ldr	r1, [r2, #0]
  4001f6:	6019      	str	r1, [r3, #0]
  4001f8:	3304      	adds	r3, #4
  4001fa:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
  4001fc:	490c      	ldr	r1, [pc, #48]	; (400230 <Reset_Handler+0x4c>)
  4001fe:	428b      	cmp	r3, r1
  400200:	d3f8      	bcc.n	4001f4 <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
  400202:	4b0c      	ldr	r3, [pc, #48]	; (400234 <Reset_Handler+0x50>)
  400204:	e002      	b.n	40020c <Reset_Handler+0x28>
                *pDest++ = 0;
  400206:	2200      	movs	r2, #0
  400208:	601a      	str	r2, [r3, #0]
  40020a:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
  40020c:	4a0a      	ldr	r2, [pc, #40]	; (400238 <Reset_Handler+0x54>)
  40020e:	4293      	cmp	r3, r2
  400210:	d3f9      	bcc.n	400206 <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  400212:	4a0a      	ldr	r2, [pc, #40]	; (40023c <Reset_Handler+0x58>)
  400214:	4b0a      	ldr	r3, [pc, #40]	; (400240 <Reset_Handler+0x5c>)
  400216:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  40021a:	6093      	str	r3, [r2, #8]
        __libc_init_array();
  40021c:	4b09      	ldr	r3, [pc, #36]	; (400244 <Reset_Handler+0x60>)
  40021e:	4798      	blx	r3
        main();
  400220:	4b09      	ldr	r3, [pc, #36]	; (400248 <Reset_Handler+0x64>)
  400222:	4798      	blx	r3
  400224:	e7fe      	b.n	400224 <Reset_Handler+0x40>
  400226:	bf00      	nop
  400228:	20400000 	.word	0x20400000
  40022c:	004015a8 	.word	0x004015a8
  400230:	20400000 	.word	0x20400000
  400234:	20400000 	.word	0x20400000
  400238:	20400110 	.word	0x20400110
  40023c:	e000ed00 	.word	0xe000ed00
  400240:	00400000 	.word	0x00400000
  400244:	004014d9 	.word	0x004014d9
  400248:	00401495 	.word	0x00401495

0040024c <TIMER_0_PORT_init>:
}

static inline void hri_pio_set_ABCDSR_reg(const void *const hw, uint8_t index, hri_pio_abcdsr_reg_t mask)
{
	PIO_CRITICAL_SECTION_ENTER();
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  40024c:	4b06      	ldr	r3, [pc, #24]	; (400268 <TIMER_0_PORT_init+0x1c>)
  40024e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400250:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
  400254:	671a      	str	r2, [r3, #112]	; 0x70
}

static inline void hri_pio_clear_ABCDSR_reg(const void *const hw, uint8_t index, hri_pio_abcdsr_reg_t mask)
{
	PIO_CRITICAL_SECTION_ENTER();
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400256:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400258:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
  40025c:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  40025e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  400262:	605a      	str	r2, [r3, #4]
  400264:	4770      	bx	lr
  400266:	bf00      	nop
  400268:	400e1200 	.word	0x400e1200

0040026c <TIMER_0_CLOCK_init>:
}

static inline hri_pmc_pcsr1_reg_t hri_pmc_get_PCSR1_reg(const void *const hw, hri_pmc_pcsr1_reg_t mask)
{
	uint32_t tmp;
	tmp = ((Pmc *)hw)->PMC_PCSR1;
  40026c:	4b10      	ldr	r3, [pc, #64]	; (4002b0 <TIMER_0_CLOCK_init+0x44>)
  40026e:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
		if (!hri_pmc_get_PCSR0_reg(PMC, (1 << periph_id))) {
			hri_pmc_set_PCSR0_reg(PMC, (1 << periph_id));
		}
	} else if (periph_id < 64) {
		periph_id -= 32;
		if (!hri_pmc_get_PCSR1_reg(PMC, (1 << periph_id))) {
  400272:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  400276:	d104      	bne.n	400282 <TIMER_0_CLOCK_init+0x16>
	((Pmc *)hw)->PMC_PCER1 = mask;
  400278:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  40027c:	4b0c      	ldr	r3, [pc, #48]	; (4002b0 <TIMER_0_CLOCK_init+0x44>)
  40027e:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	tmp = ((Pmc *)hw)->PMC_PCSR1;
  400282:	4b0b      	ldr	r3, [pc, #44]	; (4002b0 <TIMER_0_CLOCK_init+0x44>)
  400284:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
  400288:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  40028c:	d104      	bne.n	400298 <TIMER_0_CLOCK_init+0x2c>
	((Pmc *)hw)->PMC_PCER1 = mask;
  40028e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  400292:	4b07      	ldr	r3, [pc, #28]	; (4002b0 <TIMER_0_CLOCK_init+0x44>)
  400294:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	tmp = ((Pmc *)hw)->PMC_PCSR1;
  400298:	4b05      	ldr	r3, [pc, #20]	; (4002b0 <TIMER_0_CLOCK_init+0x44>)
  40029a:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
  40029e:	f413 3f00 	tst.w	r3, #131072	; 0x20000
  4002a2:	d104      	bne.n	4002ae <TIMER_0_CLOCK_init+0x42>
	((Pmc *)hw)->PMC_PCER1 = mask;
  4002a4:	f44f 3200 	mov.w	r2, #131072	; 0x20000
  4002a8:	4b01      	ldr	r3, [pc, #4]	; (4002b0 <TIMER_0_CLOCK_init+0x44>)
  4002aa:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  4002ae:	4770      	bx	lr
  4002b0:	400e0600 	.word	0x400e0600

004002b4 <delay_driver_init>:
	_pmc_enable_periph_clock(ID_TC2_CHANNEL1);
	_pmc_enable_periph_clock(ID_TC2_CHANNEL2);
}

void delay_driver_init(void)
{
  4002b4:	b508      	push	{r3, lr}
	delay_init(SysTick);
  4002b6:	4802      	ldr	r0, [pc, #8]	; (4002c0 <delay_driver_init+0xc>)
  4002b8:	4b02      	ldr	r3, [pc, #8]	; (4002c4 <delay_driver_init+0x10>)
  4002ba:	4798      	blx	r3
  4002bc:	bd08      	pop	{r3, pc}
  4002be:	bf00      	nop
  4002c0:	e000e010 	.word	0xe000e010
  4002c4:	00400369 	.word	0x00400369

004002c8 <USB_0_CLOCK_init>:
	tmp = ((Pmc *)hw)->PMC_PCSR1;
  4002c8:	4b05      	ldr	r3, [pc, #20]	; (4002e0 <USB_0_CLOCK_init+0x18>)
  4002ca:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
  4002ce:	f013 0f04 	tst.w	r3, #4
  4002d2:	d103      	bne.n	4002dc <USB_0_CLOCK_init+0x14>
	((Pmc *)hw)->PMC_PCER1 = mask;
  4002d4:	2204      	movs	r2, #4
  4002d6:	4b02      	ldr	r3, [pc, #8]	; (4002e0 <USB_0_CLOCK_init+0x18>)
  4002d8:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  4002dc:	4770      	bx	lr
  4002de:	bf00      	nop
  4002e0:	400e0600 	.word	0x400e0600

004002e4 <USB_0_init>:
{
	_pmc_enable_periph_clock(ID_USBHS);
}

void USB_0_init(void)
{
  4002e4:	b508      	push	{r3, lr}
	USB_0_CLOCK_init();
  4002e6:	4b02      	ldr	r3, [pc, #8]	; (4002f0 <USB_0_init+0xc>)
  4002e8:	4798      	blx	r3
	usb_d_init();
  4002ea:	4b02      	ldr	r3, [pc, #8]	; (4002f4 <USB_0_init+0x10>)
  4002ec:	4798      	blx	r3
  4002ee:	bd08      	pop	{r3, pc}
  4002f0:	004002c9 	.word	0x004002c9
  4002f4:	00400651 	.word	0x00400651

004002f8 <system_init>:
}

void system_init(void)
{
  4002f8:	b508      	push	{r3, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
  4002fa:	4b0b      	ldr	r3, [pc, #44]	; (400328 <system_init+0x30>)
  4002fc:	4798      	blx	r3
}

static inline void hri_wdt_set_MR_WDDIS_bit(const void *const hw)
{
	WDT_CRITICAL_SECTION_ENTER();
	((Wdt *)hw)->WDT_MR |= WDT_MR_WDDIS;
  4002fe:	4a0b      	ldr	r2, [pc, #44]	; (40032c <system_init+0x34>)
  400300:	6853      	ldr	r3, [r2, #4]
  400302:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  400306:	6053      	str	r3, [r2, #4]
	((Pio *)hw)->PIO_ODR = mask;
  400308:	2208      	movs	r2, #8
  40030a:	4b09      	ldr	r3, [pc, #36]	; (400330 <system_init+0x38>)
  40030c:	615a      	str	r2, [r3, #20]
	// is it right to set direction here vs starting clock specifically? might be problem? 
	gpio_set_pin_direction(PB3_TRIG, GPIO_DIRECTION_IN);
	//gpio_set_pin_direction(PA6_OUT, GPIO_DIRECTION_OUT);
	

	TIMER_0_CLOCK_init();
  40030e:	4b09      	ldr	r3, [pc, #36]	; (400334 <system_init+0x3c>)
  400310:	4798      	blx	r3
	TIMER_0_PORT_init();
  400312:	4b09      	ldr	r3, [pc, #36]	; (400338 <system_init+0x40>)
  400314:	4798      	blx	r3
	TIMER_0_init();
  400316:	4b09      	ldr	r3, [pc, #36]	; (40033c <system_init+0x44>)
  400318:	4798      	blx	r3

	delay_driver_init();
  40031a:	4b09      	ldr	r3, [pc, #36]	; (400340 <system_init+0x48>)
  40031c:	4798      	blx	r3

	USB_0_init();
  40031e:	4b09      	ldr	r3, [pc, #36]	; (400344 <system_init+0x4c>)
  400320:	4798      	blx	r3

	ext_irq_init();
  400322:	4b09      	ldr	r3, [pc, #36]	; (400348 <system_init+0x50>)
  400324:	4798      	blx	r3
  400326:	bd08      	pop	{r3, pc}
  400328:	004006c5 	.word	0x004006c5
  40032c:	400e1850 	.word	0x400e1850
  400330:	400e1000 	.word	0x400e1000
  400334:	0040026d 	.word	0x0040026d
  400338:	0040024d 	.word	0x0040024d
  40033c:	00400a15 	.word	0x00400a15
  400340:	004002b5 	.word	0x004002b5
  400344:	004002e5 	.word	0x004002e5
  400348:	004003c1 	.word	0x004003c1

0040034c <atomic_enter_critical>:
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
  40034c:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
  400350:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  400352:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
  400354:	f3bf 8f5f 	dmb	sy
  400358:	4770      	bx	lr

0040035a <atomic_leave_critical>:
  40035a:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
  40035e:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
  400360:	f383 8810 	msr	PRIMASK, r3
  400364:	4770      	bx	lr
	...

00400368 <delay_init>:

/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
  400368:	b508      	push	{r3, lr}
	_delay_init(hardware = hw);
  40036a:	4b02      	ldr	r3, [pc, #8]	; (400374 <delay_init+0xc>)
  40036c:	6018      	str	r0, [r3, #0]
  40036e:	4b02      	ldr	r3, [pc, #8]	; (400378 <delay_init+0x10>)
  400370:	4798      	blx	r3
  400372:	bd08      	pop	{r3, pc}
  400374:	2040001c 	.word	0x2040001c
  400378:	00400a09 	.word	0x00400a09

0040037c <process_ext_irq>:
 * \brief Interrupt processing routine
 *
 * \param[in] pin The pin which triggered the interrupt
 */
static void process_ext_irq(const uint32_t pin)
{
  40037c:	b538      	push	{r3, r4, r5, lr}
	uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;
  40037e:	2501      	movs	r5, #1
  400380:	2400      	movs	r4, #0

	while (upper >= lower) {
  400382:	e007      	b.n	400394 <process_ext_irq+0x18>
		if (middle >= EXT_IRQ_AMOUNT) {
			return;
		}

		if (ext_irqs[middle].pin == pin) {
			if (ext_irqs[middle].cb) {
  400384:	4a0d      	ldr	r2, [pc, #52]	; (4003bc <process_ext_irq+0x40>)
  400386:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
  40038a:	b1b3      	cbz	r3, 4003ba <process_ext_irq+0x3e>
				ext_irqs[middle].cb();
  40038c:	4798      	blx	r3
  40038e:	bd38      	pop	{r3, r4, r5, pc}
		}

		if (ext_irqs[middle].pin < pin) {
			lower = middle + 1;
		} else {
			upper = middle - 1;
  400390:	3901      	subs	r1, #1
  400392:	b2cd      	uxtb	r5, r1
	while (upper >= lower) {
  400394:	42ac      	cmp	r4, r5
  400396:	d810      	bhi.n	4003ba <process_ext_irq+0x3e>
		middle = (upper + lower) >> 1;
  400398:	192b      	adds	r3, r5, r4
  40039a:	105b      	asrs	r3, r3, #1
		if (middle >= EXT_IRQ_AMOUNT) {
  40039c:	f013 01ff 	ands.w	r1, r3, #255	; 0xff
  4003a0:	d10b      	bne.n	4003ba <process_ext_irq+0x3e>
  4003a2:	b2db      	uxtb	r3, r3
		if (ext_irqs[middle].pin == pin) {
  4003a4:	4a05      	ldr	r2, [pc, #20]	; (4003bc <process_ext_irq+0x40>)
  4003a6:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
  4003aa:	6852      	ldr	r2, [r2, #4]
  4003ac:	4282      	cmp	r2, r0
  4003ae:	d0e9      	beq.n	400384 <process_ext_irq+0x8>
		if (ext_irqs[middle].pin < pin) {
  4003b0:	4282      	cmp	r2, r0
  4003b2:	d2ed      	bcs.n	400390 <process_ext_irq+0x14>
			lower = middle + 1;
  4003b4:	3101      	adds	r1, #1
  4003b6:	b2cc      	uxtb	r4, r1
  4003b8:	e7ec      	b.n	400394 <process_ext_irq+0x18>
  4003ba:	bd38      	pop	{r3, r4, r5, pc}
  4003bc:	20400020 	.word	0x20400020

004003c0 <ext_irq_init>:
{
  4003c0:	b508      	push	{r3, lr}
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
  4003c2:	2300      	movs	r3, #0
  4003c4:	b11b      	cbz	r3, 4003ce <ext_irq_init+0xe>
	return _ext_irq_init(process_ext_irq);
  4003c6:	4808      	ldr	r0, [pc, #32]	; (4003e8 <ext_irq_init+0x28>)
  4003c8:	4b08      	ldr	r3, [pc, #32]	; (4003ec <ext_irq_init+0x2c>)
  4003ca:	4798      	blx	r3
}
  4003cc:	bd08      	pop	{r3, pc}
		ext_irqs[i].pin = 0xFFFFFFFF;
  4003ce:	4a08      	ldr	r2, [pc, #32]	; (4003f0 <ext_irq_init+0x30>)
  4003d0:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
  4003d4:	f04f 30ff 	mov.w	r0, #4294967295
  4003d8:	6048      	str	r0, [r1, #4]
		ext_irqs[i].cb  = NULL;
  4003da:	2100      	movs	r1, #0
  4003dc:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
  4003e0:	3301      	adds	r3, #1
  4003e2:	b29b      	uxth	r3, r3
  4003e4:	e7ee      	b.n	4003c4 <ext_irq_init+0x4>
  4003e6:	bf00      	nop
  4003e8:	0040037d 	.word	0x0040037d
  4003ec:	00400925 	.word	0x00400925
  4003f0:	20400020 	.word	0x20400020

004003f4 <_usb_d_find_ep>:
 * \retval <0 Not found (endpoint is not initialized).
 */
static int8_t _usb_d_find_ep(const uint8_t ep)
{
	int8_t i;
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
  4003f4:	2300      	movs	r3, #0
  4003f6:	2b03      	cmp	r3, #3
  4003f8:	dc21      	bgt.n	40043e <_usb_d_find_ep+0x4a>
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
  4003fa:	4a13      	ldr	r2, [pc, #76]	; (400448 <_usb_d_find_ep+0x54>)
  4003fc:	eb02 1243 	add.w	r2, r2, r3, lsl #5
  400400:	7851      	ldrb	r1, [r2, #1]
  400402:	4281      	cmp	r1, r0
  400404:	d01d      	beq.n	400442 <_usb_d_find_ep+0x4e>
{
  400406:	b410      	push	{r4}
  400408:	e009      	b.n	40041e <_usb_d_find_ep+0x2a>
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
  40040a:	3301      	adds	r3, #1
  40040c:	b25b      	sxtb	r3, r3
  40040e:	2b03      	cmp	r3, #3
  400410:	dc0f      	bgt.n	400432 <_usb_d_find_ep+0x3e>
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
  400412:	4a0d      	ldr	r2, [pc, #52]	; (400448 <_usb_d_find_ep+0x54>)
  400414:	eb02 1243 	add.w	r2, r2, r3, lsl #5
  400418:	7851      	ldrb	r1, [r2, #1]
  40041a:	4281      	cmp	r1, r0
  40041c:	d00b      	beq.n	400436 <_usb_d_find_ep+0x42>
			return i;
		}
		if (usb_d_inst.ep[i].xfer.hdr.type == USB_EP_XTYPE_CTRL
  40041e:	015a      	lsls	r2, r3, #5
  400420:	4c09      	ldr	r4, [pc, #36]	; (400448 <_usb_d_find_ep+0x54>)
  400422:	5ca2      	ldrb	r2, [r4, r2]
  400424:	2a00      	cmp	r2, #0
  400426:	d1f0      	bne.n	40040a <_usb_d_find_ep+0x16>
		    && (ep & USB_EP_N_MASK) == usb_d_inst.ep[i].xfer.hdr.ep) {
  400428:	f000 020f 	and.w	r2, r0, #15
  40042c:	428a      	cmp	r2, r1
  40042e:	d1ec      	bne.n	40040a <_usb_d_find_ep+0x16>
  400430:	e001      	b.n	400436 <_usb_d_find_ep+0x42>
			return i;
		}
	}
	return -1;
  400432:	f04f 33ff 	mov.w	r3, #4294967295
}
  400436:	4618      	mov	r0, r3
  400438:	f85d 4b04 	ldr.w	r4, [sp], #4
  40043c:	4770      	bx	lr
	return -1;
  40043e:	f04f 33ff 	mov.w	r3, #4294967295
}
  400442:	4618      	mov	r0, r3
  400444:	4770      	bx	lr
  400446:	bf00      	nop
  400448:	20400028 	.word	0x20400028

0040044c <usb_d_dummy_cb_false>:
{
	(void)unused0;
	(void)unused1;
	(void)unused2;
	return false;
}
  40044c:	2000      	movs	r0, #0
  40044e:	4770      	bx	lr

00400450 <usb_d_cb_trans_more>:
 * \brief Callback invoked when request more data
 * \param[in] ep Endpoint number with transfer direction on bit 8.
 * \param[in] transfered Number of bytes transfered.
 */
static bool usb_d_cb_trans_more(const uint8_t ep, const uint32_t transfered)
{
  400450:	b538      	push	{r3, r4, r5, lr}
  400452:	4604      	mov	r4, r0
  400454:	460d      	mov	r5, r1
	int8_t           ep_index = _usb_d_find_ep(ep);
  400456:	4b09      	ldr	r3, [pc, #36]	; (40047c <usb_d_cb_trans_more+0x2c>)
  400458:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ept->xfer.hdr.state == USB_EP_S_X_DATA) {
  40045a:	4b09      	ldr	r3, [pc, #36]	; (400480 <usb_d_cb_trans_more+0x30>)
  40045c:	eb03 1340 	add.w	r3, r3, r0, lsl #5
  400460:	789b      	ldrb	r3, [r3, #2]
  400462:	2b03      	cmp	r3, #3
  400464:	d001      	beq.n	40046a <usb_d_cb_trans_more+0x1a>
		return ept->callbacks.more(ep, transfered);
	}
	return false;
  400466:	2000      	movs	r0, #0
}
  400468:	bd38      	pop	{r3, r4, r5, pc}
		return ept->callbacks.more(ep, transfered);
  40046a:	4b05      	ldr	r3, [pc, #20]	; (400480 <usb_d_cb_trans_more+0x30>)
  40046c:	eb03 1040 	add.w	r0, r3, r0, lsl #5
  400470:	6983      	ldr	r3, [r0, #24]
  400472:	4629      	mov	r1, r5
  400474:	4620      	mov	r0, r4
  400476:	4798      	blx	r3
  400478:	bd38      	pop	{r3, r4, r5, pc}
  40047a:	bf00      	nop
  40047c:	004003f5 	.word	0x004003f5
  400480:	20400028 	.word	0x20400028

00400484 <_usb_d_cb_trans_done>:

/**
 * Callback when USB transactions are finished.
 */
static void _usb_d_cb_trans_done(const uint8_t ep, const int32_t code, const uint32_t transferred)
{
  400484:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  400488:	b084      	sub	sp, #16
  40048a:	4607      	mov	r7, r0
  40048c:	460d      	mov	r5, r1
  40048e:	4690      	mov	r8, r2
	int8_t           ep_index = _usb_d_find_ep(ep);
  400490:	4b48      	ldr	r3, [pc, #288]	; (4005b4 <_usb_d_cb_trans_done+0x130>)
  400492:	4798      	blx	r3
  400494:	4604      	mov	r4, r0
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
  400496:	4e48      	ldr	r6, [pc, #288]	; (4005b8 <_usb_d_cb_trans_done+0x134>)
  400498:	eb06 1640 	add.w	r6, r6, r0, lsl #5

	if (code == USB_TRANS_DONE) {
  40049c:	2d00      	cmp	r5, #0
  40049e:	d14f      	bne.n	400540 <_usb_d_cb_trans_done+0xbc>
		ept->xfer.hdr.status = USB_XFER_DONE;
  4004a0:	4a45      	ldr	r2, [pc, #276]	; (4005b8 <_usb_d_cb_trans_done+0x134>)
  4004a2:	0143      	lsls	r3, r0, #5
  4004a4:	2000      	movs	r0, #0
  4004a6:	70f0      	strb	r0, [r6, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
  4004a8:	5cd3      	ldrb	r3, [r2, r3]
  4004aa:	b17b      	cbz	r3, 4004cc <_usb_d_cb_trans_done+0x48>
			usb_d_ctrl_trans_done(ept);
			return;
		}
		ept->xfer.hdr.state = USB_EP_S_IDLE;
  4004ac:	4b42      	ldr	r3, [pc, #264]	; (4005b8 <_usb_d_cb_trans_done+0x134>)
  4004ae:	eb03 1344 	add.w	r3, r3, r4, lsl #5
  4004b2:	2201      	movs	r2, #1
  4004b4:	709a      	strb	r2, [r3, #2]
	} else {
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
		ept->xfer.hdr.status = USB_XFER_ERROR;
	}

	ept->callbacks.xfer(ep, (enum usb_xfer_code)ept->xfer.hdr.status, (void *)transferred);
  4004b6:	4b40      	ldr	r3, [pc, #256]	; (4005b8 <_usb_d_cb_trans_done+0x134>)
  4004b8:	eb03 1444 	add.w	r4, r3, r4, lsl #5
  4004bc:	69e3      	ldr	r3, [r4, #28]
  4004be:	4642      	mov	r2, r8
  4004c0:	78e1      	ldrb	r1, [r4, #3]
  4004c2:	4638      	mov	r0, r7
  4004c4:	4798      	blx	r3
}
  4004c6:	b004      	add	sp, #16
  4004c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uint8_t state   = ept->xfer.hdr.state;
  4004cc:	78b3      	ldrb	r3, [r6, #2]
  4004ce:	f996 400c 	ldrsb.w	r4, [r6, #12]
	if (state == USB_EP_S_X_DATA) {
  4004d2:	2b03      	cmp	r3, #3
  4004d4:	d008      	beq.n	4004e8 <_usb_d_cb_trans_done+0x64>
		ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DONE, ept->xfer.req);
  4004d6:	69f3      	ldr	r3, [r6, #28]
  4004d8:	f106 020c 	add.w	r2, r6, #12
  4004dc:	2100      	movs	r1, #0
  4004de:	7870      	ldrb	r0, [r6, #1]
  4004e0:	4798      	blx	r3
		ept->xfer.hdr.state = USB_EP_S_X_SETUP;
  4004e2:	2302      	movs	r3, #2
  4004e4:	70b3      	strb	r3, [r6, #2]
  4004e6:	e7ee      	b.n	4004c6 <_usb_d_cb_trans_done+0x42>
		bool err = ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DATA, ept->xfer.req);
  4004e8:	69f3      	ldr	r3, [r6, #28]
  4004ea:	f106 020c 	add.w	r2, r6, #12
  4004ee:	2101      	movs	r1, #1
  4004f0:	7870      	ldrb	r0, [r6, #1]
  4004f2:	4798      	blx	r3
		if (err) {
  4004f4:	b170      	cbz	r0, 400514 <_usb_d_cb_trans_done+0x90>
			ept->xfer.hdr.state  = USB_EP_S_HALTED;
  4004f6:	2305      	movs	r3, #5
  4004f8:	70b3      	strb	r3, [r6, #2]
			ept->xfer.hdr.status = USB_XFER_HALT;
  4004fa:	2302      	movs	r3, #2
  4004fc:	70f3      	strb	r3, [r6, #3]
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
  4004fe:	2c00      	cmp	r4, #0
  400500:	db06      	blt.n	400510 <_usb_d_cb_trans_done+0x8c>
  400502:	7870      	ldrb	r0, [r6, #1]
  400504:	f040 0080 	orr.w	r0, r0, #128	; 0x80
  400508:	2101      	movs	r1, #1
  40050a:	4b2c      	ldr	r3, [pc, #176]	; (4005bc <_usb_d_cb_trans_done+0x138>)
  40050c:	4798      	blx	r3
  40050e:	e7da      	b.n	4004c6 <_usb_d_cb_trans_done+0x42>
  400510:	7870      	ldrb	r0, [r6, #1]
  400512:	e7f9      	b.n	400508 <_usb_d_cb_trans_done+0x84>
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
  400514:	2304      	movs	r3, #4
  400516:	70b3      	strb	r3, [r6, #2]
			_usb_d_trans(ept->xfer.hdr.ep, !req_dir, NULL, 0, 1);
  400518:	7873      	ldrb	r3, [r6, #1]
	struct usb_d_transfer trans
  40051a:	2200      	movs	r2, #0
  40051c:	9201      	str	r2, [sp, #4]
  40051e:	9202      	str	r2, [sp, #8]
  400520:	4294      	cmp	r4, r2
  400522:	db0a      	blt.n	40053a <_usb_d_cb_trans_done+0xb6>
  400524:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  400528:	f88d 300c 	strb.w	r3, [sp, #12]
  40052c:	2301      	movs	r3, #1
  40052e:	f88d 300d 	strb.w	r3, [sp, #13]
	return _usb_d_dev_ep_trans(&trans);
  400532:	a801      	add	r0, sp, #4
  400534:	4b22      	ldr	r3, [pc, #136]	; (4005c0 <_usb_d_cb_trans_done+0x13c>)
  400536:	4798      	blx	r3
  400538:	e7c5      	b.n	4004c6 <_usb_d_cb_trans_done+0x42>
	struct usb_d_transfer trans
  40053a:	f003 030f 	and.w	r3, r3, #15
  40053e:	e7f3      	b.n	400528 <_usb_d_cb_trans_done+0xa4>
	} else if (code == USB_TRANS_STALL) {
  400540:	2d01      	cmp	r5, #1
  400542:	d00a      	beq.n	40055a <_usb_d_cb_trans_done+0xd6>
	} else if (code == USB_TRANS_ABORT) {
  400544:	2d02      	cmp	r5, #2
  400546:	d01c      	beq.n	400582 <_usb_d_cb_trans_done+0xfe>
	} else if (code == USB_TRANS_RESET) {
  400548:	2d03      	cmp	r5, #3
  40054a:	d02a      	beq.n	4005a2 <_usb_d_cb_trans_done+0x11e>
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
  40054c:	4b1a      	ldr	r3, [pc, #104]	; (4005b8 <_usb_d_cb_trans_done+0x134>)
  40054e:	eb03 1340 	add.w	r3, r3, r0, lsl #5
  400552:	2206      	movs	r2, #6
  400554:	709a      	strb	r2, [r3, #2]
		ept->xfer.hdr.status = USB_XFER_ERROR;
  400556:	70da      	strb	r2, [r3, #3]
  400558:	e7ad      	b.n	4004b6 <_usb_d_cb_trans_done+0x32>
		ept->xfer.hdr.status = USB_XFER_HALT;
  40055a:	4a17      	ldr	r2, [pc, #92]	; (4005b8 <_usb_d_cb_trans_done+0x134>)
  40055c:	0143      	lsls	r3, r0, #5
  40055e:	18d1      	adds	r1, r2, r3
  400560:	2002      	movs	r0, #2
  400562:	70c8      	strb	r0, [r1, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
  400564:	5cd3      	ldrb	r3, [r2, r3]
  400566:	b12b      	cbz	r3, 400574 <_usb_d_cb_trans_done+0xf0>
			ept->xfer.hdr.state = USB_EP_S_HALTED;
  400568:	4b13      	ldr	r3, [pc, #76]	; (4005b8 <_usb_d_cb_trans_done+0x134>)
  40056a:	eb03 1344 	add.w	r3, r3, r4, lsl #5
  40056e:	2205      	movs	r2, #5
  400570:	709a      	strb	r2, [r3, #2]
  400572:	e7a0      	b.n	4004b6 <_usb_d_cb_trans_done+0x32>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
  400574:	460b      	mov	r3, r1
  400576:	7098      	strb	r0, [r3, #2]
			_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
  400578:	2100      	movs	r1, #0
  40057a:	4638      	mov	r0, r7
  40057c:	4b0f      	ldr	r3, [pc, #60]	; (4005bc <_usb_d_cb_trans_done+0x138>)
  40057e:	4798      	blx	r3
  400580:	e799      	b.n	4004b6 <_usb_d_cb_trans_done+0x32>
		ept->xfer.hdr.status = USB_XFER_ABORT;
  400582:	4a0d      	ldr	r2, [pc, #52]	; (4005b8 <_usb_d_cb_trans_done+0x134>)
  400584:	0143      	lsls	r3, r0, #5
  400586:	18d1      	adds	r1, r2, r3
  400588:	2004      	movs	r0, #4
  40058a:	70c8      	strb	r0, [r1, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
  40058c:	5cd3      	ldrb	r3, [r2, r3]
  40058e:	b12b      	cbz	r3, 40059c <_usb_d_cb_trans_done+0x118>
		ept->xfer.hdr.state = USB_EP_S_IDLE;
  400590:	4b09      	ldr	r3, [pc, #36]	; (4005b8 <_usb_d_cb_trans_done+0x134>)
  400592:	eb03 1344 	add.w	r3, r3, r4, lsl #5
  400596:	2201      	movs	r2, #1
  400598:	709a      	strb	r2, [r3, #2]
  40059a:	e78c      	b.n	4004b6 <_usb_d_cb_trans_done+0x32>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
  40059c:	2302      	movs	r3, #2
  40059e:	708b      	strb	r3, [r1, #2]
			return;
  4005a0:	e791      	b.n	4004c6 <_usb_d_cb_trans_done+0x42>
		ept->xfer.hdr.state  = USB_EP_S_DISABLED;
  4005a2:	4b05      	ldr	r3, [pc, #20]	; (4005b8 <_usb_d_cb_trans_done+0x134>)
  4005a4:	eb03 1340 	add.w	r3, r3, r0, lsl #5
  4005a8:	2200      	movs	r2, #0
  4005aa:	709a      	strb	r2, [r3, #2]
		ept->xfer.hdr.status = USB_XFER_RESET;
  4005ac:	2205      	movs	r2, #5
  4005ae:	70da      	strb	r2, [r3, #3]
  4005b0:	e781      	b.n	4004b6 <_usb_d_cb_trans_done+0x32>
  4005b2:	bf00      	nop
  4005b4:	004003f5 	.word	0x004003f5
  4005b8:	20400028 	.word	0x20400028
  4005bc:	00401119 	.word	0x00401119
  4005c0:	004012d1 	.word	0x004012d1

004005c4 <usb_d_cb_trans_setup>:
{
  4005c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4005c8:	4605      	mov	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
  4005ca:	4b1d      	ldr	r3, [pc, #116]	; (400640 <usb_d_cb_trans_setup+0x7c>)
  4005cc:	4798      	blx	r3
  4005ce:	4606      	mov	r6, r0
	uint8_t *        req      = ept->xfer.req;
  4005d0:	0144      	lsls	r4, r0, #5
  4005d2:	f104 0308 	add.w	r3, r4, #8
  4005d6:	4c1b      	ldr	r4, [pc, #108]	; (400644 <usb_d_cb_trans_setup+0x80>)
  4005d8:	441c      	add	r4, r3
  4005da:	3404      	adds	r4, #4
	uint8_t n = _usb_d_dev_ep_read_req(ep, req);
  4005dc:	4621      	mov	r1, r4
  4005de:	4628      	mov	r0, r5
  4005e0:	4b19      	ldr	r3, [pc, #100]	; (400648 <usb_d_cb_trans_setup+0x84>)
  4005e2:	4798      	blx	r3
  4005e4:	b2c0      	uxtb	r0, r0
	if (n != 8) {
  4005e6:	2808      	cmp	r0, #8
  4005e8:	d009      	beq.n	4005fe <usb_d_cb_trans_setup+0x3a>
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
  4005ea:	2101      	movs	r1, #1
  4005ec:	4628      	mov	r0, r5
  4005ee:	4c17      	ldr	r4, [pc, #92]	; (40064c <usb_d_cb_trans_setup+0x88>)
  4005f0:	47a0      	blx	r4
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
  4005f2:	2101      	movs	r1, #1
  4005f4:	f045 0080 	orr.w	r0, r5, #128	; 0x80
  4005f8:	47a0      	blx	r4
		return;
  4005fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
  4005fe:	2100      	movs	r1, #0
  400600:	4628      	mov	r0, r5
  400602:	4f12      	ldr	r7, [pc, #72]	; (40064c <usb_d_cb_trans_setup+0x88>)
  400604:	47b8      	blx	r7
	_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_CLR);
  400606:	f045 0880 	orr.w	r8, r5, #128	; 0x80
  40060a:	2100      	movs	r1, #0
  40060c:	4640      	mov	r0, r8
  40060e:	47b8      	blx	r7
	ept->xfer.hdr.state = USB_EP_S_IDLE;
  400610:	4b0c      	ldr	r3, [pc, #48]	; (400644 <usb_d_cb_trans_setup+0x80>)
  400612:	eb03 1346 	add.w	r3, r3, r6, lsl #5
  400616:	2201      	movs	r2, #1
  400618:	709a      	strb	r2, [r3, #2]
	if (!ept->callbacks.req(ep, req)) {
  40061a:	695b      	ldr	r3, [r3, #20]
  40061c:	4621      	mov	r1, r4
  40061e:	4628      	mov	r0, r5
  400620:	4798      	blx	r3
  400622:	b108      	cbz	r0, 400628 <usb_d_cb_trans_setup+0x64>
  400624:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		ept->xfer.hdr.state = USB_EP_S_HALTED;
  400628:	4b06      	ldr	r3, [pc, #24]	; (400644 <usb_d_cb_trans_setup+0x80>)
  40062a:	eb03 1646 	add.w	r6, r3, r6, lsl #5
  40062e:	2305      	movs	r3, #5
  400630:	70b3      	strb	r3, [r6, #2]
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
  400632:	2101      	movs	r1, #1
  400634:	4628      	mov	r0, r5
  400636:	47b8      	blx	r7
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
  400638:	2101      	movs	r1, #1
  40063a:	4640      	mov	r0, r8
  40063c:	47b8      	blx	r7
  40063e:	e7f1      	b.n	400624 <usb_d_cb_trans_setup+0x60>
  400640:	004003f5 	.word	0x004003f5
  400644:	20400028 	.word	0x20400028
  400648:	00401251 	.word	0x00401251
  40064c:	00401119 	.word	0x00401119

00400650 <usb_d_init>:

int32_t usb_d_init(void)
{
  400650:	b510      	push	{r4, lr}
	int32_t rc = _usb_d_dev_init();
  400652:	4b12      	ldr	r3, [pc, #72]	; (40069c <usb_d_init+0x4c>)
  400654:	4798      	blx	r3
	uint8_t i;
	if (rc < 0) {
  400656:	2800      	cmp	r0, #0
  400658:	db1e      	blt.n	400698 <usb_d_init+0x48>
		return rc;
	}
	memset(usb_d_inst.ep, 0x00, sizeof(struct usb_d_ep) * CONF_USB_D_NUM_EP_SP);
  40065a:	2280      	movs	r2, #128	; 0x80
  40065c:	2100      	movs	r1, #0
  40065e:	4810      	ldr	r0, [pc, #64]	; (4006a0 <usb_d_init+0x50>)
  400660:	4b10      	ldr	r3, [pc, #64]	; (4006a4 <usb_d_init+0x54>)
  400662:	4798      	blx	r3
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
  400664:	2200      	movs	r2, #0
  400666:	e00a      	b.n	40067e <usb_d_init+0x2e>
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
  400668:	4b0d      	ldr	r3, [pc, #52]	; (4006a0 <usb_d_init+0x50>)
  40066a:	eb03 1342 	add.w	r3, r3, r2, lsl #5
  40066e:	21ff      	movs	r1, #255	; 0xff
  400670:	7059      	strb	r1, [r3, #1]
		usb_d_inst.ep[i].callbacks.req  = (usb_d_ep_cb_setup_t)usb_d_dummy_cb_false;
  400672:	490d      	ldr	r1, [pc, #52]	; (4006a8 <usb_d_init+0x58>)
  400674:	6159      	str	r1, [r3, #20]
		usb_d_inst.ep[i].callbacks.more = (usb_d_ep_cb_more_t)usb_d_dummy_cb_false;
  400676:	6199      	str	r1, [r3, #24]
		usb_d_inst.ep[i].callbacks.xfer = (usb_d_ep_cb_xfer_t)usb_d_dummy_cb_false;
  400678:	61d9      	str	r1, [r3, #28]
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
  40067a:	3201      	adds	r2, #1
  40067c:	b2d2      	uxtb	r2, r2
  40067e:	2a03      	cmp	r2, #3
  400680:	d9f2      	bls.n	400668 <usb_d_init+0x18>
	}
	/* Handles device driver endpoint callbacks to build transfer. */
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_SETUP, (FUNC_PTR)usb_d_cb_trans_setup);
  400682:	490a      	ldr	r1, [pc, #40]	; (4006ac <usb_d_init+0x5c>)
  400684:	2000      	movs	r0, #0
  400686:	4c0a      	ldr	r4, [pc, #40]	; (4006b0 <usb_d_init+0x60>)
  400688:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_MORE, (FUNC_PTR)usb_d_cb_trans_more);
  40068a:	490a      	ldr	r1, [pc, #40]	; (4006b4 <usb_d_init+0x64>)
  40068c:	2001      	movs	r0, #1
  40068e:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_DONE, (FUNC_PTR)_usb_d_cb_trans_done);
  400690:	4909      	ldr	r1, [pc, #36]	; (4006b8 <usb_d_init+0x68>)
  400692:	2002      	movs	r0, #2
  400694:	47a0      	blx	r4
	return ERR_NONE;
  400696:	2000      	movs	r0, #0
}
  400698:	bd10      	pop	{r4, pc}
  40069a:	bf00      	nop
  40069c:	004010c9 	.word	0x004010c9
  4006a0:	20400028 	.word	0x20400028
  4006a4:	00401537 	.word	0x00401537
  4006a8:	0040044d 	.word	0x0040044d
  4006ac:	004005c5 	.word	0x004005c5
  4006b0:	00401441 	.word	0x00401441
  4006b4:	00400451 	.word	0x00400451
  4006b8:	00400485 	.word	0x00400485

004006bc <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
  4006bc:	b900      	cbnz	r0, 4006c0 <assert+0x4>
		__asm("BKPT #0");
  4006be:	be00      	bkpt	0x0000
  4006c0:	4770      	bx	lr
	...

004006c4 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
  4006c4:	b500      	push	{lr}
  4006c6:	b083      	sub	sp, #12
/**
 * \brief Enable FPU
 */
static inline void _fpu_enable(void)
{
	CRITICAL_SECTION_ENTER()
  4006c8:	a801      	add	r0, sp, #4
  4006ca:	4b0e      	ldr	r3, [pc, #56]	; (400704 <_init_chip+0x40>)
  4006cc:	4798      	blx	r3
	/** Set bits 20-23 to enable CP10 and CP11 coprocessors */
	SCB->CPACR |= (0xFu << 20);
  4006ce:	4a0e      	ldr	r2, [pc, #56]	; (400708 <_init_chip+0x44>)
  4006d0:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
  4006d4:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  4006d8:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
  4006dc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  4006e0:	f3bf 8f6f 	isb	sy
	__DSB();
	__ISB();
	CRITICAL_SECTION_LEAVE()
  4006e4:	a801      	add	r0, sp, #4
  4006e6:	4b09      	ldr	r3, [pc, #36]	; (40070c <_init_chip+0x48>)
  4006e8:	4798      	blx	r3

static inline void hri_efc_write_EEFC_FMR_FWS_bf(const void *const hw, hri_efc_eefc_fmr_reg_t data)
{
	uint32_t tmp;
	EFC_CRITICAL_SECTION_ENTER();
	tmp = ((Efc *)hw)->EEFC_FMR;
  4006ea:	4a09      	ldr	r2, [pc, #36]	; (400710 <_init_chip+0x4c>)
  4006ec:	6813      	ldr	r3, [r2, #0]
	tmp &= ~EEFC_FMR_FWS_Msk;
  4006ee:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
	tmp |= EEFC_FMR_FWS(data);
  4006f2:	f443 63c0 	orr.w	r3, r3, #1536	; 0x600
	((Efc *)hw)->EEFC_FMR = tmp;
  4006f6:	6013      	str	r3, [r2, #0]
#if CONF_DMA_ENABLE
	_pmc_enable_periph_clock(ID_XDMAC);
	_dma_init();

#endif
	_pmc_init();
  4006f8:	4b06      	ldr	r3, [pc, #24]	; (400714 <_init_chip+0x50>)
  4006fa:	4798      	blx	r3
}
  4006fc:	b003      	add	sp, #12
  4006fe:	f85d fb04 	ldr.w	pc, [sp], #4
  400702:	bf00      	nop
  400704:	0040034d 	.word	0x0040034d
  400708:	e000ed00 	.word	0xe000ed00
  40070c:	0040035b 	.word	0x0040035b
  400710:	400e0c00 	.word	0x400e0c00
  400714:	004009e1 	.word	0x004009e1

00400718 <_ffs>:
};
#endif

/* Find the first bit set */
static int _ffs(uint32_t *v, uint8_t len)
{
  400718:	b430      	push	{r4, r5}
	uint32_t i, j, bit;

	for (i = 0; i < len; i++) {
  40071a:	2500      	movs	r5, #0
  40071c:	428d      	cmp	r5, r1
  40071e:	d210      	bcs.n	400742 <_ffs+0x2a>
  400720:	2201      	movs	r2, #1
  400722:	2300      	movs	r3, #0
		bit = 1;
		for (j = 0; j < sizeof(uint32_t) * 8; j++) {
  400724:	2b1f      	cmp	r3, #31
  400726:	d80a      	bhi.n	40073e <_ffs+0x26>
			if (v[i] & bit) {
  400728:	f850 4025 	ldr.w	r4, [r0, r5, lsl #2]
  40072c:	4222      	tst	r2, r4
  40072e:	d102      	bne.n	400736 <_ffs+0x1e>
				return i * 32 + j;
			}
			bit <<= 1;
  400730:	0052      	lsls	r2, r2, #1
		for (j = 0; j < sizeof(uint32_t) * 8; j++) {
  400732:	3301      	adds	r3, #1
  400734:	e7f6      	b.n	400724 <_ffs+0xc>
				return i * 32 + j;
  400736:	eb03 1045 	add.w	r0, r3, r5, lsl #5
		}
	}

	return -1;
}
  40073a:	bc30      	pop	{r4, r5}
  40073c:	4770      	bx	lr
	for (i = 0; i < len; i++) {
  40073e:	3501      	adds	r5, #1
  400740:	e7ec      	b.n	40071c <_ffs+0x4>
	return -1;
  400742:	f04f 30ff 	mov.w	r0, #4294967295
  400746:	e7f8      	b.n	40073a <_ffs+0x22>

00400748 <_ext_irq_handler>:

/**
 * \brief External interrupt handler
 */
static void _ext_irq_handler(void)
{
  400748:	b510      	push	{r4, lr}
  40074a:	b086      	sub	sp, #24
	uint32_t flag_total = 0, flags[5] = {
  40074c:	2300      	movs	r3, #0
  40074e:	9301      	str	r3, [sp, #4]
  400750:	9302      	str	r3, [sp, #8]
  400752:	9303      	str	r3, [sp, #12]
  400754:	9304      	str	r3, [sp, #16]
  400756:	9305      	str	r3, [sp, #20]
	                             0,
	                         };
	int pos;

	ASSERT(callback);
  400758:	4b1b      	ldr	r3, [pc, #108]	; (4007c8 <_ext_irq_handler+0x80>)
  40075a:	6818      	ldr	r0, [r3, #0]
  40075c:	22f8      	movs	r2, #248	; 0xf8
  40075e:	491b      	ldr	r1, [pc, #108]	; (4007cc <_ext_irq_handler+0x84>)
  400760:	3000      	adds	r0, #0
  400762:	bf18      	it	ne
  400764:	2001      	movne	r0, #1
  400766:	4b1a      	ldr	r3, [pc, #104]	; (4007d0 <_ext_irq_handler+0x88>)
  400768:	4798      	blx	r3
	return ((Pio *)hw)->PIO_ISR;
  40076a:	4a1a      	ldr	r2, [pc, #104]	; (4007d4 <_ext_irq_handler+0x8c>)
  40076c:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  40076e:	6c92      	ldr	r2, [r2, #72]	; 0x48

#if CONF_EXTIRQ_0_ENABLE == 1 && defined(PIOA)
	flags[0] = hri_pio_read_ISR_reg(PIOA);
	flags[0] &= hri_pio_read_IMR_reg(PIOA);
  400770:	4013      	ands	r3, r2
  400772:	9301      	str	r3, [sp, #4]
	flags[4] = hri_pio_read_ISR_reg(PIOE);
	flags[4] &= hri_pio_read_IMR_reg(PIOE);
	flag_total |= flags[4];
#endif

	while (flag_total) {
  400774:	e01f      	b.n	4007b6 <_ext_irq_handler+0x6e>
		pos = _ffs(flags, 5);
		while (-1 != pos) {
			callback(pos);
  400776:	4b14      	ldr	r3, [pc, #80]	; (4007c8 <_ext_irq_handler+0x80>)
  400778:	681b      	ldr	r3, [r3, #0]
  40077a:	4620      	mov	r0, r4
  40077c:	4798      	blx	r3

			flags[pos >> 5] &= ~(1 << (pos & 31));
  40077e:	1163      	asrs	r3, r4, #5
  400780:	f004 041f 	and.w	r4, r4, #31
  400784:	2201      	movs	r2, #1
  400786:	fa02 f404 	lsl.w	r4, r2, r4
  40078a:	aa06      	add	r2, sp, #24
  40078c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400790:	f853 2c14 	ldr.w	r2, [r3, #-20]
  400794:	ea22 0204 	bic.w	r2, r2, r4
  400798:	f843 2c14 	str.w	r2, [r3, #-20]
			pos = _ffs(flags, 5);
  40079c:	2105      	movs	r1, #5
  40079e:	a801      	add	r0, sp, #4
  4007a0:	4b0d      	ldr	r3, [pc, #52]	; (4007d8 <_ext_irq_handler+0x90>)
  4007a2:	4798      	blx	r3
  4007a4:	4604      	mov	r4, r0
		while (-1 != pos) {
  4007a6:	f1b4 3fff 	cmp.w	r4, #4294967295
  4007aa:	d1e4      	bne.n	400776 <_ext_irq_handler+0x2e>
	return ((Pio *)hw)->PIO_ISR;
  4007ac:	4a09      	ldr	r2, [pc, #36]	; (4007d4 <_ext_irq_handler+0x8c>)
  4007ae:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  4007b0:	6c93      	ldr	r3, [r2, #72]	; 0x48
		}
		flag_total = 0;

#if CONF_EXTIRQ_0_ENABLE == 1 && defined(PIOA)
		flags[0] = hri_pio_read_ISR_reg(PIOA);
		flags[0] &= hri_pio_read_IMR_reg(PIOA);
  4007b2:	400b      	ands	r3, r1
  4007b4:	9301      	str	r3, [sp, #4]
	while (flag_total) {
  4007b6:	b12b      	cbz	r3, 4007c4 <_ext_irq_handler+0x7c>
		pos = _ffs(flags, 5);
  4007b8:	2105      	movs	r1, #5
  4007ba:	a801      	add	r0, sp, #4
  4007bc:	4b06      	ldr	r3, [pc, #24]	; (4007d8 <_ext_irq_handler+0x90>)
  4007be:	4798      	blx	r3
  4007c0:	4604      	mov	r4, r0
		while (-1 != pos) {
  4007c2:	e7f0      	b.n	4007a6 <_ext_irq_handler+0x5e>
		flags[4] = hri_pio_read_ISR_reg(PIOE);
		flags[4] &= hri_pio_read_IMR_reg(PIOE);
		flag_total |= flags[4];
#endif
	}
}
  4007c4:	b006      	add	sp, #24
  4007c6:	bd10      	pop	{r4, pc}
  4007c8:	204000a8 	.word	0x204000a8
  4007cc:	0040156c 	.word	0x0040156c
  4007d0:	004006bd 	.word	0x004006bd
  4007d4:	400e0e00 	.word	0x400e0e00
  4007d8:	00400719 	.word	0x00400719

004007dc <_pio_get_hardware_index>:
{
  4007dc:	b510      	push	{r4, lr}
	ASSERT(hw);
  4007de:	4604      	mov	r4, r0
  4007e0:	22d2      	movs	r2, #210	; 0xd2
  4007e2:	4905      	ldr	r1, [pc, #20]	; (4007f8 <_pio_get_hardware_index+0x1c>)
  4007e4:	3000      	adds	r0, #0
  4007e6:	bf18      	it	ne
  4007e8:	2001      	movne	r0, #1
  4007ea:	4b04      	ldr	r3, [pc, #16]	; (4007fc <_pio_get_hardware_index+0x20>)
  4007ec:	4798      	blx	r3
	return ((uint32_t)hw - (uint32_t)PIOA) >> 9;
  4007ee:	4804      	ldr	r0, [pc, #16]	; (400800 <_pio_get_hardware_index+0x24>)
  4007f0:	4420      	add	r0, r4
}
  4007f2:	f3c0 2047 	ubfx	r0, r0, #9, #8
  4007f6:	bd10      	pop	{r4, pc}
  4007f8:	0040156c 	.word	0x0040156c
  4007fc:	004006bd 	.word	0x004006bd
  400800:	bff1f200 	.word	0xbff1f200

00400804 <_pio_get_index>:
{
  400804:	b510      	push	{r4, lr}
	ASSERT(hw);
  400806:	4604      	mov	r4, r0
  400808:	22e0      	movs	r2, #224	; 0xe0
  40080a:	490d      	ldr	r1, [pc, #52]	; (400840 <_pio_get_index+0x3c>)
  40080c:	3000      	adds	r0, #0
  40080e:	bf18      	it	ne
  400810:	2001      	movne	r0, #1
  400812:	4b0c      	ldr	r3, [pc, #48]	; (400844 <_pio_get_index+0x40>)
  400814:	4798      	blx	r3
	uint8_t offset = _pio_get_hardware_index(hw);
  400816:	4620      	mov	r0, r4
  400818:	4b0b      	ldr	r3, [pc, #44]	; (400848 <_pio_get_index+0x44>)
  40081a:	4798      	blx	r3
	for (i = 0; i < ARRAY_SIZE(_ext_irq); i++) {
  40081c:	2300      	movs	r3, #0
  40081e:	b113      	cbz	r3, 400826 <_pio_get_index+0x22>
	return ERR_INVALID_DATA;
  400820:	f04f 30ff 	mov.w	r0, #4294967295
}
  400824:	bd10      	pop	{r4, pc}
		if (_ext_irq[i].number == offset) {
  400826:	ebc3 01c3 	rsb	r1, r3, r3, lsl #3
  40082a:	008a      	lsls	r2, r1, #2
  40082c:	4907      	ldr	r1, [pc, #28]	; (40084c <_pio_get_index+0x48>)
  40082e:	5c8a      	ldrb	r2, [r1, r2]
  400830:	4290      	cmp	r0, r2
  400832:	d002      	beq.n	40083a <_pio_get_index+0x36>
	for (i = 0; i < ARRAY_SIZE(_ext_irq); i++) {
  400834:	3301      	adds	r3, #1
  400836:	b2db      	uxtb	r3, r3
  400838:	e7f1      	b.n	40081e <_pio_get_index+0x1a>
			return i;
  40083a:	b258      	sxtb	r0, r3
  40083c:	bd10      	pop	{r4, pc}
  40083e:	bf00      	nop
  400840:	0040156c 	.word	0x0040156c
  400844:	004006bd 	.word	0x004006bd
  400848:	004007dd 	.word	0x004007dd
  40084c:	00401548 	.word	0x00401548

00400850 <_pio_init>:
 * \return The status of instance initial
 * \retval ERR_NONE Initial status OK
 * \retval ERR_DENIED No need to initial
 */
static int32_t _pio_init(void *const hw)
{
  400850:	b538      	push	{r3, r4, r5, lr}
	int8_t i;

	ASSERT(hw);
  400852:	4604      	mov	r4, r0
  400854:	f44f 72aa 	mov.w	r2, #340	; 0x154
  400858:	4929      	ldr	r1, [pc, #164]	; (400900 <_pio_init+0xb0>)
  40085a:	3000      	adds	r0, #0
  40085c:	bf18      	it	ne
  40085e:	2001      	movne	r0, #1
  400860:	4b28      	ldr	r3, [pc, #160]	; (400904 <_pio_init+0xb4>)
  400862:	4798      	blx	r3

	i = _pio_get_index(hw);
  400864:	4620      	mov	r0, r4
  400866:	4b28      	ldr	r3, [pc, #160]	; (400908 <_pio_init+0xb8>)
  400868:	4798      	blx	r3
	if (i < 0) {
  40086a:	2800      	cmp	r0, #0
  40086c:	db43      	blt.n	4008f6 <_pio_init+0xa6>
		return ERR_DENIED;
	}

	hri_pio_set_AIMMR_reg(hw, _ext_irq[i].add_irq_enable);
  40086e:	4d27      	ldr	r5, [pc, #156]	; (40090c <_pio_init+0xbc>)
  400870:	00c2      	lsls	r2, r0, #3
  400872:	1a11      	subs	r1, r2, r0
  400874:	008b      	lsls	r3, r1, #2
  400876:	442b      	add	r3, r5
  400878:	6899      	ldr	r1, [r3, #8]
	((Pio *)hw)->PIO_AIMER = mask;
  40087a:	f8c4 10b0 	str.w	r1, [r4, #176]	; 0xb0
	hri_pio_clear_ELSR_reg(hw, _ext_irq[i].esr);
  40087e:	68d9      	ldr	r1, [r3, #12]
	((Pio *)hw)->PIO_ESR = mask;
  400880:	f8c4 10c0 	str.w	r1, [r4, #192]	; 0xc0
	hri_pio_set_ELSR_reg(hw, _ext_irq[i].lsr);
  400884:	691b      	ldr	r3, [r3, #16]
	((Pio *)hw)->PIO_LSR = mask;
  400886:	f8c4 30c4 	str.w	r3, [r4, #196]	; 0xc4
	((Pio *)hw)->PIO_FELLSR = mask;
  40088a:	2300      	movs	r3, #0
  40088c:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
	hri_pio_clear_FRLHSR_reg(hw, _ext_irq[i].fellsr);
	hri_pio_set_FRLHSR_reg(hw, _ext_irq[i].rehlsr);
  400890:	1a10      	subs	r0, r2, r0
  400892:	0083      	lsls	r3, r0, #2
  400894:	442b      	add	r3, r5
  400896:	695b      	ldr	r3, [r3, #20]
	((Pio *)hw)->PIO_REHLSR = mask;
  400898:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4

	i = _pio_irq_n[_pio_get_hardware_index(hw)];
  40089c:	4620      	mov	r0, r4
  40089e:	4b1c      	ldr	r3, [pc, #112]	; (400910 <_pio_init+0xc0>)
  4008a0:	4798      	blx	r3
  4008a2:	4428      	add	r0, r5
  4008a4:	f990 301c 	ldrsb.w	r3, [r0, #28]
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  4008a8:	2b00      	cmp	r3, #0
  4008aa:	db0c      	blt.n	4008c6 <_pio_init+0x76>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  4008ac:	095a      	lsrs	r2, r3, #5
  4008ae:	f003 001f 	and.w	r0, r3, #31
  4008b2:	2101      	movs	r1, #1
  4008b4:	4081      	lsls	r1, r0
  4008b6:	3220      	adds	r2, #32
  4008b8:	4816      	ldr	r0, [pc, #88]	; (400914 <_pio_init+0xc4>)
  4008ba:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
  4008be:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  4008c2:	f3bf 8f6f 	isb	sy
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  4008c6:	2b00      	cmp	r3, #0
  4008c8:	db08      	blt.n	4008dc <_pio_init+0x8c>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  4008ca:	095a      	lsrs	r2, r3, #5
  4008cc:	f003 001f 	and.w	r0, r3, #31
  4008d0:	2101      	movs	r1, #1
  4008d2:	4081      	lsls	r1, r0
  4008d4:	3260      	adds	r2, #96	; 0x60
  4008d6:	480f      	ldr	r0, [pc, #60]	; (400914 <_pio_init+0xc4>)
  4008d8:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
  if ((int32_t)(IRQn) >= 0)
  4008dc:	2b00      	cmp	r3, #0
  4008de:	db0d      	blt.n	4008fc <_pio_init+0xac>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  4008e0:	0959      	lsrs	r1, r3, #5
  4008e2:	f003 031f 	and.w	r3, r3, #31
  4008e6:	2201      	movs	r2, #1
  4008e8:	fa02 f303 	lsl.w	r3, r2, r3
  4008ec:	4a09      	ldr	r2, [pc, #36]	; (400914 <_pio_init+0xc4>)
  4008ee:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
	NVIC_DisableIRQ((IRQn_Type)i);
	NVIC_ClearPendingIRQ((IRQn_Type)i);
	NVIC_EnableIRQ((IRQn_Type)i);

	return ERR_NONE;
  4008f2:	2000      	movs	r0, #0
  4008f4:	bd38      	pop	{r3, r4, r5, pc}
		return ERR_DENIED;
  4008f6:	f06f 0010 	mvn.w	r0, #16
  4008fa:	bd38      	pop	{r3, r4, r5, pc}
	return ERR_NONE;
  4008fc:	2000      	movs	r0, #0
}
  4008fe:	bd38      	pop	{r3, r4, r5, pc}
  400900:	0040156c 	.word	0x0040156c
  400904:	004006bd 	.word	0x004006bd
  400908:	00400805 	.word	0x00400805
  40090c:	00401548 	.word	0x00401548
  400910:	004007dd 	.word	0x004007dd
  400914:	e000e100 	.word	0xe000e100

00400918 <PIOA_Handler>:
{
  400918:	b508      	push	{r3, lr}
	_ext_irq_handler();
  40091a:	4b01      	ldr	r3, [pc, #4]	; (400920 <PIOA_Handler+0x8>)
  40091c:	4798      	blx	r3
  40091e:	bd08      	pop	{r3, pc}
  400920:	00400749 	.word	0x00400749

00400924 <_ext_irq_init>:

int32_t _ext_irq_init(void (*cb)(const uint32_t pin))
{
  400924:	b510      	push	{r4, lr}
  400926:	4604      	mov	r4, r0

#if CONF_EXTIRQ_0_ENABLE == 1 && defined(PIOA)
	_pio_init(PIOA);
  400928:	4803      	ldr	r0, [pc, #12]	; (400938 <_ext_irq_init+0x14>)
  40092a:	4b04      	ldr	r3, [pc, #16]	; (40093c <_ext_irq_init+0x18>)
  40092c:	4798      	blx	r3

#if CONF_EXTIRQ_4_ENABLE == 1 && defined(PIOE)
	_pio_init(PIOE);
#endif

	callback = cb;
  40092e:	4b04      	ldr	r3, [pc, #16]	; (400940 <_ext_irq_init+0x1c>)
  400930:	601c      	str	r4, [r3, #0]

	return ERR_NONE;
}
  400932:	2000      	movs	r0, #0
  400934:	bd10      	pop	{r4, pc}
  400936:	bf00      	nop
  400938:	400e0e00 	.word	0x400e0e00
  40093c:	00400851 	.word	0x00400851
  400940:	204000a8 	.word	0x204000a8

00400944 <_pmc_init_sources>:
	PMC_CRITICAL_SECTION_LEAVE();
}

static inline hri_pmc_ckgr_mor_reg_t hri_pmc_read_CKGR_MOR_reg(const void *const hw)
{
	return ((Pmc *)hw)->CKGR_MOR;
  400944:	490e      	ldr	r1, [pc, #56]	; (400980 <_pmc_init_sources+0x3c>)
  400946:	6a0a      	ldr	r2, [r1, #32]
	/* Enable Main XTAL oscillator */
	data = hri_pmc_read_CKGR_MOR_reg(PMC) & ~CKGR_MOR_MOSCXTEN;
	data |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY | CKGR_MOR_MOSCSEL;
	hri_pmc_write_CKGR_MOR_reg(PMC, data);
#else
	data = hri_pmc_read_CKGR_MOR_reg(PMC) & ~CKGR_MOR_MOSCXTBY;
  400948:	f022 0202 	bic.w	r2, r2, #2
	data |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCXTST(CONF_XOSC20M_STARTUP_TIME);
  40094c:	4b0d      	ldr	r3, [pc, #52]	; (400984 <_pmc_init_sources+0x40>)
  40094e:	4313      	orrs	r3, r2
	((Pmc *)hw)->CKGR_MOR = data;
  400950:	620b      	str	r3, [r1, #32]
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MOSCXTS) > 0;
  400952:	4b0b      	ldr	r3, [pc, #44]	; (400980 <_pmc_init_sources+0x3c>)
  400954:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	hri_pmc_write_CKGR_MOR_reg(PMC, data);
	while (!hri_pmc_get_SR_MOSCXTS_bit(PMC)) {
  400956:	f013 0f01 	tst.w	r3, #1
  40095a:	d0fa      	beq.n	400952 <_pmc_init_sources+0xe>
	((Pmc *)hw)->CKGR_MOR |= mask;
  40095c:	4b08      	ldr	r3, [pc, #32]	; (400980 <_pmc_init_sources+0x3c>)
  40095e:	6a19      	ldr	r1, [r3, #32]
  400960:	4a09      	ldr	r2, [pc, #36]	; (400988 <_pmc_init_sources+0x44>)
  400962:	430a      	orrs	r2, r1
  400964:	621a      	str	r2, [r3, #32]

static inline void hri_pmc_write_CKGR_PLLAR_MULA_bf(const void *const hw, hri_pmc_ckgr_pllar_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->CKGR_PLLAR;
  400966:	6a99      	ldr	r1, [r3, #40]	; 0x28
	tmp &= ~CKGR_PLLAR_MULA_Msk;
  400968:	4a08      	ldr	r2, [pc, #32]	; (40098c <_pmc_init_sources+0x48>)
  40096a:	400a      	ands	r2, r1
	tmp |= CKGR_PLLAR_MULA(data);
	((Pmc *)hw)->CKGR_PLLAR = tmp;
  40096c:	629a      	str	r2, [r3, #40]	; 0x28
}

static inline void hri_pmc_write_CKGR_PLLAR_reg(const void *const hw, hri_pmc_ckgr_pllar_reg_t data)
{
	PMC_CRITICAL_SECTION_ENTER();
	((Pmc *)hw)->CKGR_PLLAR = data;
  40096e:	4a08      	ldr	r2, [pc, #32]	; (400990 <_pmc_init_sources+0x4c>)
  400970:	629a      	str	r2, [r3, #40]	; 0x28
	return (((Pmc *)hw)->PMC_SR & PMC_SR_LOCKA) > 0;
  400972:	4b03      	ldr	r3, [pc, #12]	; (400980 <_pmc_init_sources+0x3c>)
  400974:	6e9b      	ldr	r3, [r3, #104]	; 0x68
#if (CONF_PLLACK_ENABLE == 1)
	data = CKGR_PLLAR_MULA(CONF_PLLACK_MUL - 1) | CKGR_PLLAR_DIVA(CONF_PLLACK_DIV) | CKGR_PLLAR_PLLACOUNT(PLL_COUNT);
	/* Stop PLL first */
	hri_pmc_write_CKGR_PLLAR_MULA_bf(PMC, 0);
	hri_pmc_write_CKGR_PLLAR_reg(PMC, (CKGR_PLLAR_ONE | data));
	while (!hri_pmc_get_SR_LOCKA_bit(PMC)) {
  400976:	f013 0f02 	tst.w	r3, #2
  40097a:	d0fa      	beq.n	400972 <_pmc_init_sources+0x2e>
#if (CONF_CLK_CFDEN_ENABLE == 1)
	/* Enable main clock failure detection */
	hri_pmc_set_CKGR_MOR_CFDEN_bit(PMC);
#endif
#endif
}
  40097c:	4770      	bx	lr
  40097e:	bf00      	nop
  400980:	400e0600 	.word	0x400e0600
  400984:	00373e01 	.word	0x00373e01
  400988:	01370000 	.word	0x01370000
  40098c:	f800ffff 	.word	0xf800ffff
  400990:	20183f01 	.word	0x20183f01

00400994 <_pmc_init_master_clock>:

static inline void hri_pmc_write_MCKR_PRES_bf(const void *const hw, hri_pmc_mckr_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->PMC_MCKR;
  400994:	4a11      	ldr	r2, [pc, #68]	; (4009dc <_pmc_init_master_clock+0x48>)
  400996:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_PRES_Msk;
  400998:	f023 0370 	bic.w	r3, r3, #112	; 0x70
	tmp |= PMC_MCKR_PRES(data);
	((Pmc *)hw)->PMC_MCKR = tmp;
  40099c:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  40099e:	4b0f      	ldr	r3, [pc, #60]	; (4009dc <_pmc_init_master_clock+0x48>)
  4009a0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
		/* Wait until master clock is ready */
	}
#elif ((CONF_CLK_GEN_MCKR_SRC == CLK_SRC_OPTION_PLLACK) || (CONF_CLK_GEN_MCKR_SRC == CLK_SRC_OPTION_UPLLCKDIV))
	hri_pmc_write_MCKR_PRES_bf(PMC, CONF_MCKR_PRESC);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  4009a2:	f013 0f08 	tst.w	r3, #8
  4009a6:	d0fa      	beq.n	40099e <_pmc_init_master_clock+0xa>

static inline void hri_pmc_write_MCKR_MDIV_bf(const void *const hw, hri_pmc_mckr_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->PMC_MCKR;
  4009a8:	4a0c      	ldr	r2, [pc, #48]	; (4009dc <_pmc_init_master_clock+0x48>)
  4009aa:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_MDIV_Msk;
  4009ac:	f423 7340 	bic.w	r3, r3, #768	; 0x300
	tmp |= PMC_MCKR_MDIV(data);
  4009b0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	((Pmc *)hw)->PMC_MCKR = tmp;
  4009b4:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  4009b6:	4b09      	ldr	r3, [pc, #36]	; (4009dc <_pmc_init_master_clock+0x48>)
  4009b8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
		/* Wait until master clock is ready */
	}
	hri_pmc_write_MCKR_MDIV_bf(PMC, CONF_MCK_DIV);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  4009ba:	f013 0f08 	tst.w	r3, #8
  4009be:	d0fa      	beq.n	4009b6 <_pmc_init_master_clock+0x22>
	tmp = ((Pmc *)hw)->PMC_MCKR;
  4009c0:	4a06      	ldr	r2, [pc, #24]	; (4009dc <_pmc_init_master_clock+0x48>)
  4009c2:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_CSS_Msk;
  4009c4:	f023 0303 	bic.w	r3, r3, #3
	tmp |= PMC_MCKR_CSS(data);
  4009c8:	f043 0302 	orr.w	r3, r3, #2
	((Pmc *)hw)->PMC_MCKR = tmp;
  4009cc:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  4009ce:	4b03      	ldr	r3, [pc, #12]	; (4009dc <_pmc_init_master_clock+0x48>)
  4009d0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
		/* Wait until master clock is ready */
	}
	hri_pmc_write_MCKR_CSS_bf(PMC, CONF_CLK_GEN_MCKR_SRC);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  4009d2:	f013 0f08 	tst.w	r3, #8
  4009d6:	d0fa      	beq.n	4009ce <_pmc_init_master_clock+0x3a>
		/* Wait until master clock is ready */
	}
#endif
#endif
}
  4009d8:	4770      	bx	lr
  4009da:	bf00      	nop
  4009dc:	400e0600 	.word	0x400e0600

004009e0 <_pmc_init>:
/**
 * \brief Initializes cortex M7 core clock
 *
 */
void _pmc_init(void)
{
  4009e0:	b508      	push	{r3, lr}
	_pmc_init_sources();
  4009e2:	4b02      	ldr	r3, [pc, #8]	; (4009ec <_pmc_init+0xc>)
  4009e4:	4798      	blx	r3
	_pmc_init_master_clock();
  4009e6:	4b02      	ldr	r3, [pc, #8]	; (4009f0 <_pmc_init+0x10>)
  4009e8:	4798      	blx	r3
  4009ea:	bd08      	pop	{r3, pc}
  4009ec:	00400945 	.word	0x00400945
  4009f0:	00400995 	.word	0x00400995

004009f4 <_system_time_init>:
 * \brief Initialize system time module
 */
void _system_time_init(void *const hw)
{
	(void)hw;
	SysTick->LOAD = (0xFFFFFF << SysTick_LOAD_RELOAD_Pos);
  4009f4:	4b03      	ldr	r3, [pc, #12]	; (400a04 <_system_time_init+0x10>)
  4009f6:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
  4009fa:	605a      	str	r2, [r3, #4]
	SysTick->CTRL = (1 << SysTick_CTRL_ENABLE_Pos) | (CONF_SYSTICK_TICKINT << SysTick_CTRL_TICKINT_Pos)
  4009fc:	2205      	movs	r2, #5
  4009fe:	601a      	str	r2, [r3, #0]
  400a00:	4770      	bx	lr
  400a02:	bf00      	nop
  400a04:	e000e010 	.word	0xe000e010

00400a08 <_delay_init>:
}
/**
 * \brief Initialize delay functionality
 */
void _delay_init(void *const hw)
{
  400a08:	b508      	push	{r3, lr}
	_system_time_init(hw);
  400a0a:	4b01      	ldr	r3, [pc, #4]	; (400a10 <_delay_init+0x8>)
  400a0c:	4798      	blx	r3
  400a0e:	bd08      	pop	{r3, pc}
  400a10:	004009f5 	.word	0x004009f5

00400a14 <TIMER_0_init>:
}

static inline void hri_tc_write_BCR_reg(const void *const hw, hri_tc_bcr_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->TC_BCR = data;
  400a14:	4b06      	ldr	r3, [pc, #24]	; (400a30 <TIMER_0_init+0x1c>)
  400a16:	2201      	movs	r2, #1
  400a18:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
	((Tc *)hw)->TcChannel[submodule_index].TC_CMR = data;
  400a1c:	f44f 4216 	mov.w	r2, #38400	; 0x9600
  400a20:	605a      	str	r2, [r3, #4]
  400a22:	4a04      	ldr	r2, [pc, #16]	; (400a34 <TIMER_0_init+0x20>)
  400a24:	645a      	str	r2, [r3, #68]	; 0x44
  400a26:	4a04      	ldr	r2, [pc, #16]	; (400a38 <TIMER_0_init+0x24>)
  400a28:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	                     TC_CHANNEL_2,
	                     6 << TC_CMR_TCCLKS_Pos | 2 << TC_CMR_WAVEFORM_WAVSEL_Pos | 1 << TC_CMR_WAVE_Pos
	                         | 3 << TC_CMR_WAVEFORM_BCPC_Pos);

	return 0;
}
  400a2c:	2000      	movs	r0, #0
  400a2e:	4770      	bx	lr
  400a30:	40014000 	.word	0x40014000
  400a34:	000c8403 	.word	0x000c8403
  400a38:	0c00c006 	.word	0x0c00c006

00400a3c <start_timer>:

void start_timer(const void *hw, uint8_t channel)
{
	if (channel < TC_CHANNEL_COUNT) {
  400a3c:	2902      	cmp	r1, #2
  400a3e:	d802      	bhi.n	400a46 <start_timer+0xa>
	((Tc *)hw)->TcChannel[submodule_index].TC_CCR = data;
  400a40:	0189      	lsls	r1, r1, #6
  400a42:	2305      	movs	r3, #5
  400a44:	5043      	str	r3, [r0, r1]
  400a46:	4770      	bx	lr

00400a48 <stop_timer>:
	}
}

void stop_timer(const void *hw, uint8_t channel)
{
	if (channel < TC_CHANNEL_COUNT) {
  400a48:	2902      	cmp	r1, #2
  400a4a:	d802      	bhi.n	400a52 <stop_timer+0xa>
  400a4c:	0189      	lsls	r1, r1, #6
  400a4e:	2302      	movs	r3, #2
  400a50:	5043      	str	r3, [r0, r1]
  400a52:	4770      	bx	lr

00400a54 <_dummy_func_no_return>:

/**
 * \brief Dummy callback function
 */
static void _dummy_func_no_return(uint32_t unused0, uint32_t unused1)
{
  400a54:	4770      	bx	lr

00400a56 <_dummy_func_return_false>:
static bool _dummy_func_return_false(uint32_t unused0, uint32_t unused1)
{
	(void)unused0;
	(void)unused1;
	return false;
}
  400a56:	2000      	movs	r0, #0
  400a58:	4770      	bx	lr
	...

00400a5c <_usb_d_dev_handle_setup>:
 * \brief Handles setup received interrupt
 * \param[in] ept Pointer to endpoint information.
 */
static void _usb_d_dev_handle_setup(struct _usb_d_dev_ep *ept)
{
	uint8_t epn     = USB_EP_GET_N(ept->ep);
  400a5c:	7c83      	ldrb	r3, [r0, #18]
  400a5e:	f003 030f 	and.w	r3, r3, #15
	bool    is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
  400a62:	7cc2      	ldrb	r2, [r0, #19]
  400a64:	f002 0107 	and.w	r1, r2, #7

	if (!is_ctrl) {
  400a68:	2901      	cmp	r1, #1
  400a6a:	d009      	beq.n	400a80 <_usb_d_dev_handle_setup+0x24>
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = mask;
}

static inline void hri_usbhs_write_DEVEPTICR_reg(const void *const hw, uint8_t index, hri_usbhs_deveptisr_reg_t data)
{
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  400a6c:	4a17      	ldr	r2, [pc, #92]	; (400acc <_usb_d_dev_handle_setup+0x70>)
  400a6e:	f103 0058 	add.w	r0, r3, #88	; 0x58
  400a72:	2104      	movs	r1, #4
  400a74:	f842 1020 	str.w	r1, [r2, r0, lsl #2]
}

static inline void hri_usbhs_write_DEVEPTIDR_reg(const void *const hw, uint8_t index, hri_usbhs_deveptidr_reg_t data)
{
	USBHS_CRITICAL_SECTION_ENTER();
	((Usbhs *)hw)->USBHS_DEVEPTIDR[index] = data;
  400a78:	3388      	adds	r3, #136	; 0x88
  400a7a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
  400a7e:	4770      	bx	lr
{
  400a80:	b510      	push	{r4, lr}

	/* Control transfer:
	 * SETUP transaction will terminate IN/OUT transaction,
	 * and start new transaction with received SETUP packet.
	 */
	if (_usb_d_dev_ep_is_busy(ept)) {
  400a82:	f012 0f40 	tst.w	r2, #64	; 0x40
  400a86:	d00e      	beq.n	400aa6 <_usb_d_dev_handle_setup+0x4a>
		ept->flags.bits.is_busy = 0;
  400a88:	7cc2      	ldrb	r2, [r0, #19]
  400a8a:	f36f 1286 	bfc	r2, #6, #1
  400a8e:	74c2      	strb	r2, [r0, #19]
	((Usbhs *)hw)->USBHS_DEVEPTIFR[index] = data;
  400a90:	490e      	ldr	r1, [pc, #56]	; (400acc <_usb_d_dev_handle_setup+0x70>)
  400a92:	f103 0264 	add.w	r2, r3, #100	; 0x64
  400a96:	2401      	movs	r4, #1
  400a98:	f841 4022 	str.w	r4, [r1, r2, lsl #2]
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  400a9c:	f103 0258 	add.w	r2, r3, #88	; 0x58
  400aa0:	2402      	movs	r4, #2
  400aa2:	f841 4022 	str.w	r4, [r1, r2, lsl #2]
		/* Stop transfer on either direction. */
		_usbd_ep_set_in_rdy(epn, false);
		_usbd_ep_set_out_rdy(epn, false);
	}

	ept->flags.bits.is_stalled = 0;
  400aa6:	7cc2      	ldrb	r2, [r0, #19]
  400aa8:	f36f 02c3 	bfc	r2, #3, #1
  400aac:	74c2      	strb	r2, [r0, #19]
  400aae:	4a07      	ldr	r2, [pc, #28]	; (400acc <_usb_d_dev_handle_setup+0x70>)
  400ab0:	f103 0458 	add.w	r4, r3, #88	; 0x58
  400ab4:	2118      	movs	r1, #24
  400ab6:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
	((Usbhs *)hw)->USBHS_DEVEPTIDR[index] = data;
  400aba:	3388      	adds	r3, #136	; 0x88
  400abc:	f842 1023 	str.w	r1, [r2, r3, lsl #2]

	/* Clear status and notify SETUP */
	_usbd_ep_int_ack(epn, USBHS_DEVEPTISR_NAKINI | USBHS_DEVEPTISR_NAKOUTI);
	_usbd_ep_int_dis(epn, USBHS_DEVEPTIMR_NAKINE | USBHS_DEVEPTIMR_NAKOUTE);
	/* Invoke callback. */
	dev_inst.ep_callbacks.setup(ept->ep);
  400ac0:	4b03      	ldr	r3, [pc, #12]	; (400ad0 <_usb_d_dev_handle_setup+0x74>)
  400ac2:	689b      	ldr	r3, [r3, #8]
  400ac4:	7c80      	ldrb	r0, [r0, #18]
  400ac6:	4798      	blx	r3
  400ac8:	bd10      	pop	{r4, pc}
  400aca:	bf00      	nop
  400acc:	40038000 	.word	0x40038000
  400ad0:	204000ac 	.word	0x204000ac

00400ad4 <_usb_d_dev_trans_done>:
 *  \brief Finish the transaction and invoke callback
 * \param[in, out] ept Pointer to endpoint information.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_done(struct _usb_d_dev_ep *ept, const int32_t code)
{
  400ad4:	b538      	push	{r3, r4, r5, lr}
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
  400ad6:	7c84      	ldrb	r4, [r0, #18]
  400ad8:	2cff      	cmp	r4, #255	; 0xff
  400ada:	d003      	beq.n	400ae4 <_usb_d_dev_trans_done+0x10>
  400adc:	7cc3      	ldrb	r3, [r0, #19]
  400ade:	f013 0f40 	tst.w	r3, #64	; 0x40
  400ae2:	d100      	bne.n	400ae6 <_usb_d_dev_trans_done+0x12>
  400ae4:	bd38      	pop	{r3, r4, r5, pc}
		return;
	}

	ept->flags.bits.is_busy = 0;
  400ae6:	7cc2      	ldrb	r2, [r0, #19]
  400ae8:	f36f 1286 	bfc	r2, #6, #1
  400aec:	74c2      	strb	r2, [r0, #19]
	dev_inst.ep_callbacks.done(ept->ep, code, ept->trans_count);
  400aee:	4a03      	ldr	r2, [pc, #12]	; (400afc <_usb_d_dev_trans_done+0x28>)
  400af0:	6915      	ldr	r5, [r2, #16]
  400af2:	6882      	ldr	r2, [r0, #8]
  400af4:	4620      	mov	r0, r4
  400af6:	47a8      	blx	r5
  400af8:	e7f4      	b.n	400ae4 <_usb_d_dev_trans_done+0x10>
  400afa:	bf00      	nop
  400afc:	204000ac 	.word	0x204000ac

00400b00 <_usb_d_dev_reset_epts>:
{
  400b00:	b570      	push	{r4, r5, r6, lr}
	((Usbhs *)hw)->USBHS_DEVCTRL &= ~USBHS_DEVCTRL_ADDEN;
  400b02:	4b15      	ldr	r3, [pc, #84]	; (400b58 <_usb_d_dev_reset_epts+0x58>)
  400b04:	681a      	ldr	r2, [r3, #0]
  400b06:	f022 0280 	bic.w	r2, r2, #128	; 0x80
  400b0a:	601a      	str	r2, [r3, #0]
	tmp = ((Usbhs *)hw)->USBHS_DEVCTRL;
  400b0c:	681a      	ldr	r2, [r3, #0]
	tmp &= ~USBHS_DEVCTRL_UADD_Msk;
  400b0e:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
	((Usbhs *)hw)->USBHS_DEVCTRL = tmp;
  400b12:	601a      	str	r2, [r3, #0]
	((Usbhs *)hw)->USBHS_DEVCTRL |= USBHS_DEVCTRL_ADDEN;
  400b14:	681a      	ldr	r2, [r3, #0]
  400b16:	f042 0280 	orr.w	r2, r2, #128	; 0x80
  400b1a:	601a      	str	r2, [r3, #0]
	for (i = 0; i < USB_D_N_EP; i++) {
  400b1c:	2400      	movs	r4, #0
  400b1e:	e017      	b.n	400b50 <_usb_d_dev_reset_epts+0x50>
		_usb_d_dev_trans_done(&dev_inst.ep[i], USB_TRANS_RESET);
  400b20:	4e0e      	ldr	r6, [pc, #56]	; (400b5c <_usb_d_dev_reset_epts+0x5c>)
  400b22:	00a5      	lsls	r5, r4, #2
  400b24:	192b      	adds	r3, r5, r4
  400b26:	0098      	lsls	r0, r3, #2
  400b28:	3010      	adds	r0, #16
  400b2a:	4430      	add	r0, r6
  400b2c:	2103      	movs	r1, #3
  400b2e:	3004      	adds	r0, #4
  400b30:	4b0b      	ldr	r3, [pc, #44]	; (400b60 <_usb_d_dev_reset_epts+0x60>)
  400b32:	4798      	blx	r3
		dev_inst.ep[i].ep       = 0xFF;
  400b34:	192a      	adds	r2, r5, r4
  400b36:	0093      	lsls	r3, r2, #2
  400b38:	4433      	add	r3, r6
  400b3a:	22ff      	movs	r2, #255	; 0xff
  400b3c:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
		dev_inst.ep[i].flags.u8 = 0;
  400b40:	4425      	add	r5, r4
  400b42:	00ab      	lsls	r3, r5, #2
  400b44:	441e      	add	r6, r3
  400b46:	2300      	movs	r3, #0
  400b48:	f886 3027 	strb.w	r3, [r6, #39]	; 0x27
	for (i = 0; i < USB_D_N_EP; i++) {
  400b4c:	3401      	adds	r4, #1
  400b4e:	b2e4      	uxtb	r4, r4
  400b50:	2c03      	cmp	r4, #3
  400b52:	d9e5      	bls.n	400b20 <_usb_d_dev_reset_epts+0x20>
}
  400b54:	bd70      	pop	{r4, r5, r6, pc}
  400b56:	bf00      	nop
  400b58:	40038000 	.word	0x40038000
  400b5c:	204000ac 	.word	0x204000ac
  400b60:	00400ad5 	.word	0x00400ad5

00400b64 <_usb_d_dev_handle_stall>:
{
  400b64:	b508      	push	{r3, lr}
	uint8_t epn = USB_EP_GET_N(ept->ep);
  400b66:	7c83      	ldrb	r3, [r0, #18]
  400b68:	f003 030f 	and.w	r3, r3, #15
	((Usbhs *)hw)->USBHS_DEVEPTIDR[index] = data;
  400b6c:	3388      	adds	r3, #136	; 0x88
  400b6e:	2140      	movs	r1, #64	; 0x40
  400b70:	4a03      	ldr	r2, [pc, #12]	; (400b80 <_usb_d_dev_handle_stall+0x1c>)
  400b72:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	_usb_d_dev_trans_done(ept, USB_TRANS_STALL);
  400b76:	2101      	movs	r1, #1
  400b78:	4b02      	ldr	r3, [pc, #8]	; (400b84 <_usb_d_dev_handle_stall+0x20>)
  400b7a:	4798      	blx	r3
  400b7c:	bd08      	pop	{r3, pc}
  400b7e:	bf00      	nop
  400b80:	40038000 	.word	0x40038000
  400b84:	00400ad5 	.word	0x00400ad5

00400b88 <_usb_d_dev_dma_next>:
{
  400b88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t  epn = USB_EP_GET_N(ept->ep);
  400b8a:	7c83      	ldrb	r3, [r0, #18]
	if (!ept->flags.bits.is_busy) {
  400b8c:	7cc2      	ldrb	r2, [r0, #19]
  400b8e:	f012 0f40 	tst.w	r2, #64	; 0x40
  400b92:	d031      	beq.n	400bf8 <_usb_d_dev_dma_next+0x70>
  400b94:	f003 030f 	and.w	r3, r3, #15
	if (ept->trans_count != ept->trans_size) {
  400b98:	6887      	ldr	r7, [r0, #8]
  400b9a:	6845      	ldr	r5, [r0, #4]
  400b9c:	42af      	cmp	r7, r5
  400b9e:	d023      	beq.n	400be8 <_usb_d_dev_dma_next+0x60>
		trans_next = ept->trans_size - ept->trans_count;
  400ba0:	1bed      	subs	r5, r5, r7
		if (trans_next > USB_D_DEV_TRANS_MAX) {
  400ba2:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
  400ba6:	d828      	bhi.n	400bfa <_usb_d_dev_dma_next+0x72>
			dma_ctrl = USBHS_DEVDMACONTROL_BUFF_LENGTH(trans_next);
  400ba8:	0429      	lsls	r1, r5, #16
		if ((ept->flags.bits.dir) && (!ept->flags.bits.need_zlp)) {
  400baa:	f002 0690 	and.w	r6, r2, #144	; 0x90
  400bae:	2e80      	cmp	r6, #128	; 0x80
  400bb0:	d027      	beq.n	400c02 <_usb_d_dev_dma_next+0x7a>
			if ((ept->flags.bits.eptype != USB_D_EPTYPE_ISOCH) || (trans_next <= ept->size)) {
  400bb2:	f002 0207 	and.w	r2, r2, #7
  400bb6:	2a02      	cmp	r2, #2
  400bb8:	d026      	beq.n	400c08 <_usb_d_dev_dma_next+0x80>
				dma_ctrl |= USBHS_DEVDMACONTROL_END_TR_IT | USBHS_DEVDMACONTROL_END_TR_EN;
  400bba:	f041 0114 	orr.w	r1, r1, #20
		hri_usbhs_write_DEVDMAADDRESS_reg(hw, (epn - 1), (uint32_t)&ept->trans_buf[ept->trans_count]);
  400bbe:	1e5a      	subs	r2, r3, #1
  400bc0:	b2d2      	uxtb	r2, r2
  400bc2:	6806      	ldr	r6, [r0, #0]
  400bc4:	4437      	add	r7, r6

static inline void hri_usbhs_write_DEVDMAADDRESS_reg(const void *const hw, uint8_t submodule_index,
                                                     hri_usbhs_devdmaaddress_reg_t data)
{
	USBHS_CRITICAL_SECTION_ENTER();
	((Usbhs *)hw)->UsbhsDevdma[submodule_index].USBHS_DEVDMAADDRESS = data;
  400bc6:	4c28      	ldr	r4, [pc, #160]	; (400c68 <_usb_d_dev_dma_next+0xe0>)
  400bc8:	f102 0631 	add.w	r6, r2, #49	; 0x31
  400bcc:	eb04 1606 	add.w	r6, r4, r6, lsl #4
  400bd0:	6077      	str	r7, [r6, #4]
		dma_ctrl |= USBHS_DEVDMACONTROL_END_BUFFIT | USBHS_DEVDMACONTROL_CHANN_ENB;
  400bd2:	f041 0121 	orr.w	r1, r1, #33	; 0x21
	USBHS_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_usbhs_get_DEVDMASTATUS_END_TR_ST_bit(const void *const hw, uint8_t submodule_index)
{
	return (((Usbhs *)hw)->UsbhsDevdma[submodule_index].USBHS_DEVDMASTATUS & USBHS_DEVDMASTATUS_END_TR_ST)
  400bd6:	eb04 1402 	add.w	r4, r4, r2, lsl #4
  400bda:	f8d4 431c 	ldr.w	r4, [r4, #796]	; 0x31c
		if (!hri_usbhs_get_DEVDMASTATUS_END_TR_ST_bit(hw, (epn - 1))) {
  400bde:	f014 0f10 	tst.w	r4, #16
  400be2:	d015      	beq.n	400c10 <_usb_d_dev_dma_next+0x88>
		ept->trans_size = ept->trans_count;
  400be4:	6882      	ldr	r2, [r0, #8]
  400be6:	6042      	str	r2, [r0, #4]
	if ((ept->flags.bits.dir) && (ept->flags.bits.need_zlp)) {
  400be8:	7cc2      	ldrb	r2, [r0, #19]
  400bea:	f002 0290 	and.w	r2, r2, #144	; 0x90
  400bee:	2a90      	cmp	r2, #144	; 0x90
  400bf0:	d01d      	beq.n	400c2e <_usb_d_dev_dma_next+0xa6>
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
  400bf2:	2100      	movs	r1, #0
  400bf4:	4b1d      	ldr	r3, [pc, #116]	; (400c6c <_usb_d_dev_dma_next+0xe4>)
  400bf6:	4798      	blx	r3
  400bf8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			dma_ctrl = USBHS_DEVDMACONTROL_BUFF_LENGTH(0);
  400bfa:	2100      	movs	r1, #0
			trans_next = USB_D_DEV_TRANS_MAX;
  400bfc:	f44f 3580 	mov.w	r5, #65536	; 0x10000
  400c00:	e7d3      	b.n	400baa <_usb_d_dev_dma_next+0x22>
			dma_ctrl |= USBHS_DEVDMACONTROL_END_B_EN;
  400c02:	f041 0108 	orr.w	r1, r1, #8
  400c06:	e7da      	b.n	400bbe <_usb_d_dev_dma_next+0x36>
			if ((ept->flags.bits.eptype != USB_D_EPTYPE_ISOCH) || (trans_next <= ept->size)) {
  400c08:	8a02      	ldrh	r2, [r0, #16]
  400c0a:	4295      	cmp	r5, r2
  400c0c:	d8d7      	bhi.n	400bbe <_usb_d_dev_dma_next+0x36>
  400c0e:	e7d4      	b.n	400bba <_usb_d_dev_dma_next+0x32>
	((Usbhs *)hw)->UsbhsDevdma[submodule_index].USBHS_DEVDMACONTROL = data;
  400c10:	4c15      	ldr	r4, [pc, #84]	; (400c68 <_usb_d_dev_dma_next+0xe0>)
  400c12:	eb04 1202 	add.w	r2, r4, r2, lsl #4
  400c16:	f8c2 1318 	str.w	r1, [r2, #792]	; 0x318
			ept->trans_count += trans_next;
  400c1a:	6882      	ldr	r2, [r0, #8]
  400c1c:	442a      	add	r2, r5
  400c1e:	6082      	str	r2, [r0, #8]
			ept->trans_load = trans_next;
  400c20:	60c5      	str	r5, [r0, #12]
			hri_usbhs_set_DEVIMR_reg(hw, (USBHS_DEVIMR_DMA_1 << (epn - 1)));
  400c22:	1e5a      	subs	r2, r3, #1
  400c24:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
  400c28:	4093      	lsls	r3, r2
	((Usbhs *)hw)->USBHS_DEVIER = mask;
  400c2a:	61a3      	str	r3, [r4, #24]
  400c2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  400c2e:	490e      	ldr	r1, [pc, #56]	; (400c68 <_usb_d_dev_dma_next+0xe0>)
  400c30:	f103 0258 	add.w	r2, r3, #88	; 0x58
  400c34:	2001      	movs	r0, #1
  400c36:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
	return (((Usbhs *)hw)->USBHS_DEVEPTISR[index] & USBHS_DEVEPTISR_RWALL) >> USBHS_DEVEPTISR_RWALL_Pos;
  400c3a:	f103 024c 	add.w	r2, r3, #76	; 0x4c
  400c3e:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
		if (hri_usbhs_get_DEVEPTISR_RWALL_bit(hw, epn)) {
  400c42:	f412 3f80 	tst.w	r2, #65536	; 0x10000
  400c46:	d003      	beq.n	400c50 <_usb_d_dev_dma_next+0xc8>
	((Usbhs *)hw)->USBHS_DEVEPTIFR[index] = data;
  400c48:	f103 0264 	add.w	r2, r3, #100	; 0x64
  400c4c:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
	((Usbhs *)hw)->USBHS_DEVEPTIER[index] = data;
  400c50:	4905      	ldr	r1, [pc, #20]	; (400c68 <_usb_d_dev_dma_next+0xe0>)
  400c52:	f103 027c 	add.w	r2, r3, #124	; 0x7c
  400c56:	2001      	movs	r0, #1
  400c58:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
		hri_usbhs_set_DEVIMR_reg(hw, (USBHS_DEVIER_PEP_0 << epn));
  400c5c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  400c60:	fa02 f303 	lsl.w	r3, r2, r3
	((Usbhs *)hw)->USBHS_DEVIER = mask;
  400c64:	618b      	str	r3, [r1, #24]
  400c66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  400c68:	40038000 	.word	0x40038000
  400c6c:	00400ad5 	.word	0x00400ad5

00400c70 <_usb_d_dev_trans_stop>:
 * \param[in] dir Endpoint direction.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_stop(struct _usb_d_dev_ep *ept, bool dir, const int32_t code)
{
	uint8_t epn = USB_EP_GET_N(ept->ep);
  400c70:	7c83      	ldrb	r3, [r0, #18]

	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
  400c72:	2bff      	cmp	r3, #255	; 0xff
  400c74:	d016      	beq.n	400ca4 <_usb_d_dev_trans_stop+0x34>
{
  400c76:	b510      	push	{r4, lr}
  400c78:	f003 040f 	and.w	r4, r3, #15
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
  400c7c:	7cc3      	ldrb	r3, [r0, #19]
  400c7e:	f013 0f40 	tst.w	r3, #64	; 0x40
  400c82:	d008      	beq.n	400c96 <_usb_d_dev_trans_stop+0x26>
		return;
	}

	/* Stop transfer */
	if (dir) {
  400c84:	b141      	cbz	r1, 400c98 <_usb_d_dev_trans_stop+0x28>
	((Usbhs *)hw)->USBHS_DEVEPTIFR[index] = data;
  400c86:	3464      	adds	r4, #100	; 0x64
  400c88:	2101      	movs	r1, #1
  400c8a:	4b07      	ldr	r3, [pc, #28]	; (400ca8 <_usb_d_dev_trans_stop+0x38>)
  400c8c:	f843 1024 	str.w	r1, [r3, r4, lsl #2]
  400c90:	4611      	mov	r1, r2
	} else {
		/* NAK OUT */
		_usbd_ep_set_out_rdy(epn, false);
	}

	_usb_d_dev_trans_done(ept, code);
  400c92:	4b06      	ldr	r3, [pc, #24]	; (400cac <_usb_d_dev_trans_stop+0x3c>)
  400c94:	4798      	blx	r3
  400c96:	bd10      	pop	{r4, pc}
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  400c98:	3458      	adds	r4, #88	; 0x58
  400c9a:	2102      	movs	r1, #2
  400c9c:	4b02      	ldr	r3, [pc, #8]	; (400ca8 <_usb_d_dev_trans_stop+0x38>)
  400c9e:	f843 1024 	str.w	r1, [r3, r4, lsl #2]
  400ca2:	e7f5      	b.n	400c90 <_usb_d_dev_trans_stop+0x20>
  400ca4:	4770      	bx	lr
  400ca6:	bf00      	nop
  400ca8:	40038000 	.word	0x40038000
  400cac:	00400ad5 	.word	0x00400ad5

00400cb0 <_usb_d_dev_handle_overflow>:
{
  400cb0:	b510      	push	{r4, lr}
	uint8_t epn = USB_EP_GET_N(ept->ep);
  400cb2:	7c83      	ldrb	r3, [r0, #18]
  400cb4:	f003 030f 	and.w	r3, r3, #15
  400cb8:	3358      	adds	r3, #88	; 0x58
  400cba:	2420      	movs	r4, #32
  400cbc:	4904      	ldr	r1, [pc, #16]	; (400cd0 <_usb_d_dev_handle_overflow+0x20>)
  400cbe:	f841 4023 	str.w	r4, [r1, r3, lsl #2]
	_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_ERROR);
  400cc2:	7cc1      	ldrb	r1, [r0, #19]
  400cc4:	2204      	movs	r2, #4
  400cc6:	09c9      	lsrs	r1, r1, #7
  400cc8:	4b02      	ldr	r3, [pc, #8]	; (400cd4 <_usb_d_dev_handle_overflow+0x24>)
  400cca:	4798      	blx	r3
  400ccc:	bd10      	pop	{r4, pc}
  400cce:	bf00      	nop
  400cd0:	40038000 	.word	0x40038000
  400cd4:	00400c71 	.word	0x00400c71

00400cd8 <_usb_d_dev_in_next>:
{
  400cd8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  400cda:	4604      	mov	r4, r0
	uint8_t  epn      = USB_EP_GET_N(ept->ep);
  400cdc:	7c85      	ldrb	r5, [r0, #18]
  400cde:	f005 050f 	and.w	r5, r5, #15
	uint8_t *ptr_dest = (uint8_t *)&_usbd_ep_get_fifo_access(epn, 8);
  400ce2:	483d      	ldr	r0, [pc, #244]	; (400dd8 <_usb_d_dev_in_next+0x100>)
  400ce4:	eb00 30c5 	add.w	r0, r0, r5, lsl #15
	uint16_t trans_count = ept->trans_load;
  400ce8:	68e2      	ldr	r2, [r4, #12]
	uint16_t last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
  400cea:	8a26      	ldrh	r6, [r4, #16]
  400cec:	f240 33ff 	movw	r3, #1023	; 0x3ff
  400cf0:	429e      	cmp	r6, r3
  400cf2:	d02a      	beq.n	400d4a <_usb_d_dev_in_next+0x72>
  400cf4:	1e73      	subs	r3, r6, #1
  400cf6:	b21b      	sxth	r3, r3
  400cf8:	4013      	ands	r3, r2
  400cfa:	b29a      	uxth	r2, r3
	bool     is_ctrl  = _usb_d_dev_ep_is_ctrl(ept);
  400cfc:	f894 e013 	ldrb.w	lr, [r4, #19]
  400d00:	f00e 0707 	and.w	r7, lr, #7
	if (ept->trans_count >= ept->trans_size) {
  400d04:	68a1      	ldr	r1, [r4, #8]
  400d06:	6863      	ldr	r3, [r4, #4]
  400d08:	4299      	cmp	r1, r3
  400d0a:	d345      	bcc.n	400d98 <_usb_d_dev_in_next+0xc0>
		if (ept->flags.bits.need_zlp) {
  400d0c:	f01e 0f10 	tst.w	lr, #16
  400d10:	d01d      	beq.n	400d4e <_usb_d_dev_in_next+0x76>
			ept->trans_load          = 0;
  400d12:	2200      	movs	r2, #0
  400d14:	60e2      	str	r2, [r4, #12]
			ept->flags.bits.need_zlp = 0;
  400d16:	7ce3      	ldrb	r3, [r4, #19]
  400d18:	f362 1304 	bfi	r3, r2, #4, #1
  400d1c:	74e3      	strb	r3, [r4, #19]
  400d1e:	4a2f      	ldr	r2, [pc, #188]	; (400ddc <_usb_d_dev_in_next+0x104>)
  400d20:	f105 0358 	add.w	r3, r5, #88	; 0x58
  400d24:	2101      	movs	r1, #1
  400d26:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
  400d2a:	2108      	movs	r1, #8
  400d2c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	((Usbhs *)hw)->USBHS_DEVEPTIER[index] = data;
  400d30:	f105 037c 	add.w	r3, r5, #124	; 0x7c
  400d34:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
			if (!is_ctrl) {
  400d38:	2f01      	cmp	r7, #1
  400d3a:	d04b      	beq.n	400dd4 <_usb_d_dev_in_next+0xfc>
	((Usbhs *)hw)->USBHS_DEVEPTIDR[index] = data;
  400d3c:	3588      	adds	r5, #136	; 0x88
  400d3e:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  400d42:	4b26      	ldr	r3, [pc, #152]	; (400ddc <_usb_d_dev_in_next+0x104>)
  400d44:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
  400d48:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uint16_t last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
  400d4a:	b233      	sxth	r3, r6
  400d4c:	e7d4      	b.n	400cf8 <_usb_d_dev_in_next+0x20>
  400d4e:	f105 0388 	add.w	r3, r5, #136	; 0x88
  400d52:	2001      	movs	r0, #1
  400d54:	4921      	ldr	r1, [pc, #132]	; (400ddc <_usb_d_dev_in_next+0x104>)
  400d56:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
		if (!is_ctrl) {
  400d5a:	4287      	cmp	r7, r0
  400d5c:	d004      	beq.n	400d68 <_usb_d_dev_in_next+0x90>
			hri_usbhs_clear_DEVIMR_reg(hw, (USBHS_DEVIER_PEP_0 << epn));
  400d5e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  400d62:	fa03 f505 	lsl.w	r5, r3, r5
	((Usbhs *)hw)->USBHS_DEVIDR = mask;
  400d66:	614d      	str	r5, [r1, #20]
		ept->trans_size = ept->trans_count;
  400d68:	68a1      	ldr	r1, [r4, #8]
  400d6a:	6061      	str	r1, [r4, #4]
		if (last_pkt == ept->size) {
  400d6c:	8a23      	ldrh	r3, [r4, #16]
  400d6e:	429a      	cmp	r2, r3
  400d70:	d004      	beq.n	400d7c <_usb_d_dev_in_next+0xa4>
		_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
  400d72:	2100      	movs	r1, #0
  400d74:	4620      	mov	r0, r4
  400d76:	4b1a      	ldr	r3, [pc, #104]	; (400de0 <_usb_d_dev_in_next+0x108>)
  400d78:	4798      	blx	r3
		return;
  400d7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			ept->flags.bits.is_busy = 0;
  400d7c:	7ce3      	ldrb	r3, [r4, #19]
  400d7e:	f36f 1386 	bfc	r3, #6, #1
  400d82:	74e3      	strb	r3, [r4, #19]
			if (dev_inst.ep_callbacks.more(ept->ep, ept->trans_count)) {
  400d84:	4b17      	ldr	r3, [pc, #92]	; (400de4 <_usb_d_dev_in_next+0x10c>)
  400d86:	68db      	ldr	r3, [r3, #12]
  400d88:	7ca0      	ldrb	r0, [r4, #18]
  400d8a:	4798      	blx	r3
  400d8c:	bb10      	cbnz	r0, 400dd4 <_usb_d_dev_in_next+0xfc>
			ept->flags.bits.is_busy = 1;
  400d8e:	7ce3      	ldrb	r3, [r4, #19]
  400d90:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  400d94:	74e3      	strb	r3, [r4, #19]
  400d96:	e7ec      	b.n	400d72 <_usb_d_dev_in_next+0x9a>
		trans_next = ept->trans_size - ept->trans_count;
  400d98:	b29b      	uxth	r3, r3
  400d9a:	b28a      	uxth	r2, r1
  400d9c:	1a9b      	subs	r3, r3, r2
  400d9e:	b29b      	uxth	r3, r3
		if (trans_next > ept->size) {
  400da0:	429e      	cmp	r6, r3
  400da2:	d300      	bcc.n	400da6 <_usb_d_dev_in_next+0xce>
		trans_next = ept->trans_size - ept->trans_count;
  400da4:	461e      	mov	r6, r3
		ptr_src = &ept->trans_buf[ept->trans_count];
  400da6:	6823      	ldr	r3, [r4, #0]
		memcpy(ptr_dest, ptr_src, trans_next);
  400da8:	4632      	mov	r2, r6
  400daa:	4419      	add	r1, r3
  400dac:	4b0e      	ldr	r3, [pc, #56]	; (400de8 <_usb_d_dev_in_next+0x110>)
  400dae:	4798      	blx	r3
		ept->trans_load = trans_next;
  400db0:	60e6      	str	r6, [r4, #12]
		ept->trans_count += trans_next;
  400db2:	68a3      	ldr	r3, [r4, #8]
  400db4:	441e      	add	r6, r3
  400db6:	60a6      	str	r6, [r4, #8]
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  400db8:	f105 0358 	add.w	r3, r5, #88	; 0x58
  400dbc:	2101      	movs	r1, #1
  400dbe:	4a07      	ldr	r2, [pc, #28]	; (400ddc <_usb_d_dev_in_next+0x104>)
  400dc0:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		if (!is_ctrl) {
  400dc4:	428f      	cmp	r7, r1
  400dc6:	d005      	beq.n	400dd4 <_usb_d_dev_in_next+0xfc>
	((Usbhs *)hw)->USBHS_DEVEPTIDR[index] = data;
  400dc8:	3588      	adds	r5, #136	; 0x88
  400dca:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  400dce:	4b03      	ldr	r3, [pc, #12]	; (400ddc <_usb_d_dev_in_next+0x104>)
  400dd0:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
  400dd4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  400dd6:	bf00      	nop
  400dd8:	a0100000 	.word	0xa0100000
  400ddc:	40038000 	.word	0x40038000
  400de0:	00400ad5 	.word	0x00400ad5
  400de4:	204000ac 	.word	0x204000ac
  400de8:	00401521 	.word	0x00401521

00400dec <_usb_d_dev_out_next>:
{
  400dec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  400df0:	4604      	mov	r4, r0
	uint8_t  epn         = USB_EP_GET_N(ept->ep);
  400df2:	7c86      	ldrb	r6, [r0, #18]
  400df4:	f006 060f 	and.w	r6, r6, #15
	tmp = ((Usbhs *)hw)->USBHS_DEVEPTISR[index];
  400df8:	4a2f      	ldr	r2, [pc, #188]	; (400eb8 <_usb_d_dev_out_next+0xcc>)
  400dfa:	f106 034c 	add.w	r3, r6, #76	; 0x4c
  400dfe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	return (hri_usbhs_get_DEVEPTISR_reg(USBHS, epn, USBHS_DEVEPTISR_BYCT_Msk) >> USBHS_DEVEPTISR_BYCT_Pos);
  400e02:	f3c3 530a 	ubfx	r3, r3, #20, #11
	uint16_t last_remain = ept->trans_size - ept->trans_count;
  400e06:	8885      	ldrh	r5, [r0, #4]
  400e08:	8901      	ldrh	r1, [r0, #8]
  400e0a:	1a6d      	subs	r5, r5, r1
	uint8_t *ptr         = (uint8_t *)&_usbd_ep_get_fifo_access(epn, 8);
  400e0c:	492b      	ldr	r1, [pc, #172]	; (400ebc <_usb_d_dev_out_next+0xd0>)
  400e0e:	eb01 31c6 	add.w	r1, r1, r6, lsl #15
	bool     is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
  400e12:	7cc7      	ldrb	r7, [r0, #19]
  400e14:	f007 0707 	and.w	r7, r7, #7
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  400e18:	f106 0058 	add.w	r0, r6, #88	; 0x58
  400e1c:	f04f 0e02 	mov.w	lr, #2
  400e20:	f842 e020 	str.w	lr, [r2, r0, lsl #2]
	if (last_trans > 0) {
  400e24:	2b00      	cmp	r3, #0
  400e26:	d03a      	beq.n	400e9e <_usb_d_dev_out_next+0xb2>
  400e28:	b2ad      	uxth	r5, r5
		if (last_trans > last_remain) {
  400e2a:	429d      	cmp	r5, r3
  400e2c:	d334      	bcc.n	400e98 <_usb_d_dev_out_next+0xac>
	uint16_t last_trans  = _usbd_ep_get_trans_count(epn);
  400e2e:	461d      	mov	r5, r3
	bool     is_full = false, is_short = false;
  400e30:	f04f 0800 	mov.w	r8, #0
		memcpy(&ept->trans_buf[ept->trans_count], ptr, last_trans);
  400e34:	6820      	ldr	r0, [r4, #0]
  400e36:	68a3      	ldr	r3, [r4, #8]
  400e38:	462a      	mov	r2, r5
  400e3a:	4418      	add	r0, r3
  400e3c:	4b20      	ldr	r3, [pc, #128]	; (400ec0 <_usb_d_dev_out_next+0xd4>)
  400e3e:	4798      	blx	r3
		ept->trans_count += last_trans;
  400e40:	68a3      	ldr	r3, [r4, #8]
  400e42:	442b      	add	r3, r5
  400e44:	60a3      	str	r3, [r4, #8]
		ept->trans_load = last_trans;
  400e46:	60e5      	str	r5, [r4, #12]
	((Usbhs *)hw)->USBHS_DEVEPTIDR[index] = data;
  400e48:	f106 0388 	add.w	r3, r6, #136	; 0x88
  400e4c:	f44f 4180 	mov.w	r1, #16384	; 0x4000
  400e50:	4a19      	ldr	r2, [pc, #100]	; (400eb8 <_usb_d_dev_out_next+0xcc>)
  400e52:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
  400e56:	462b      	mov	r3, r5
	if (last_trans < ept->size) {
  400e58:	8a22      	ldrh	r2, [r4, #16]
  400e5a:	4293      	cmp	r3, r2
  400e5c:	d222      	bcs.n	400ea4 <_usb_d_dev_out_next+0xb8>
		ept->flags.bits.need_zlp = 0;
  400e5e:	7ce3      	ldrb	r3, [r4, #19]
  400e60:	f36f 1304 	bfc	r3, #4, #1
  400e64:	74e3      	strb	r3, [r4, #19]
		is_short                 = true;
  400e66:	2301      	movs	r3, #1
	if (is_full || is_short) {
  400e68:	ea58 0303 	orrs.w	r3, r8, r3
  400e6c:	d012      	beq.n	400e94 <_usb_d_dev_out_next+0xa8>
  400e6e:	f106 0388 	add.w	r3, r6, #136	; 0x88
  400e72:	2102      	movs	r1, #2
  400e74:	4a10      	ldr	r2, [pc, #64]	; (400eb8 <_usb_d_dev_out_next+0xcc>)
  400e76:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		if (!is_ctrl) {
  400e7a:	2f01      	cmp	r7, #1
  400e7c:	d004      	beq.n	400e88 <_usb_d_dev_out_next+0x9c>
			hri_usbhs_clear_DEVIMR_reg(hw, (USBHS_DEVIER_PEP_0 << epn));
  400e7e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  400e82:	fa03 f606 	lsl.w	r6, r3, r6
	((Usbhs *)hw)->USBHS_DEVIDR = mask;
  400e86:	6156      	str	r6, [r2, #20]
		ept->trans_size = ept->trans_count;
  400e88:	68a3      	ldr	r3, [r4, #8]
  400e8a:	6063      	str	r3, [r4, #4]
		_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
  400e8c:	2100      	movs	r1, #0
  400e8e:	4620      	mov	r0, r4
  400e90:	4b0c      	ldr	r3, [pc, #48]	; (400ec4 <_usb_d_dev_out_next+0xd8>)
  400e92:	4798      	blx	r3
  400e94:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			is_full    = true;
  400e98:	f04f 0801 	mov.w	r8, #1
  400e9c:	e7ca      	b.n	400e34 <_usb_d_dev_out_next+0x48>
	bool     is_full = false, is_short = false;
  400e9e:	f04f 0800 	mov.w	r8, #0
  400ea2:	e7d9      	b.n	400e58 <_usb_d_dev_out_next+0x6c>
	} else if (ept->trans_count >= ept->trans_size) {
  400ea4:	68a2      	ldr	r2, [r4, #8]
  400ea6:	6863      	ldr	r3, [r4, #4]
  400ea8:	429a      	cmp	r2, r3
  400eaa:	d201      	bcs.n	400eb0 <_usb_d_dev_out_next+0xc4>
	bool     is_full = false, is_short = false;
  400eac:	2300      	movs	r3, #0
  400eae:	e7db      	b.n	400e68 <_usb_d_dev_out_next+0x7c>
  400eb0:	2300      	movs	r3, #0
		is_full = true;
  400eb2:	f04f 0801 	mov.w	r8, #1
  400eb6:	e7d7      	b.n	400e68 <_usb_d_dev_out_next+0x7c>
  400eb8:	40038000 	.word	0x40038000
  400ebc:	a0100000 	.word	0xa0100000
  400ec0:	00401521 	.word	0x00401521
  400ec4:	00400ad5 	.word	0x00400ad5

00400ec8 <USBHS_Handler>:
{
  400ec8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return ((Usbhs *)hw)->USBHS_DEVISR;
  400eca:	4b75      	ldr	r3, [pc, #468]	; (4010a0 <USBHS_Handler+0x1d8>)
  400ecc:	685a      	ldr	r2, [r3, #4]
	return ((Usbhs *)hw)->USBHS_DEVIMR;
  400ece:	691d      	ldr	r5, [r3, #16]
	flags = hri_usbhs_read_DEVISR_reg(hw) & hri_usbhs_read_DEVIMR_reg(hw);
  400ed0:	4015      	ands	r5, r2
	ep_int = (flags & USBHS_DEVISR_PEP__Msk) >> USBHS_DEVISR_PEP__Pos;
  400ed2:	f3c5 3609 	ubfx	r6, r5, #12, #10
	if ((ep_int == 0) && (dma_int == 0)) {
  400ed6:	0e6d      	lsrs	r5, r5, #25
  400ed8:	bf0c      	ite	eq
  400eda:	2401      	moveq	r4, #1
  400edc:	2400      	movne	r4, #0
  400ede:	2e00      	cmp	r6, #0
  400ee0:	bf14      	ite	ne
  400ee2:	2400      	movne	r4, #0
  400ee4:	f004 0401 	andeq.w	r4, r4, #1
  400ee8:	b90c      	cbnz	r4, 400eee <USBHS_Handler+0x26>
		rc = false;
  400eea:	2400      	movs	r4, #0
  400eec:	e07d      	b.n	400fea <USBHS_Handler+0x122>
	return ((Usbhs *)hw)->USBHS_DEVISR;
  400eee:	461a      	mov	r2, r3
  400ef0:	685b      	ldr	r3, [r3, #4]
	uint16_t flags = hri_usbhs_read_DEVISR_reg(USBHS);
  400ef2:	b29b      	uxth	r3, r3
	return ((Usbhs *)hw)->USBHS_DEVIMR;
  400ef4:	6912      	ldr	r2, [r2, #16]
	flags &= hri_usbhs_read_DEVIMR_reg(USBHS);
  400ef6:	4013      	ands	r3, r2
	if (flags & USBHS_DEVISR_SOF) {
  400ef8:	f013 0f04 	tst.w	r3, #4
  400efc:	d10f      	bne.n	400f1e <USBHS_Handler+0x56>
	} else if (flags & USBHS_DEVISR_MSOF) {
  400efe:	f013 0f02 	tst.w	r3, #2
  400f02:	d113      	bne.n	400f2c <USBHS_Handler+0x64>
	if (flags & USB_D_WAKEUP_INT_FLAGS) {
  400f04:	f013 0f70 	tst.w	r3, #112	; 0x70
  400f08:	d117      	bne.n	400f3a <USBHS_Handler+0x72>
	} else if (flags & USBHS_DEVISR_EORST) {
  400f0a:	f013 0f08 	tst.w	r3, #8
  400f0e:	d120      	bne.n	400f52 <USBHS_Handler+0x8a>
	} else if (flags & USBHS_DEVISR_SUSP) {
  400f10:	f013 0f01 	tst.w	r3, #1
  400f14:	d12c      	bne.n	400f70 <USBHS_Handler+0xa8>
		rc = false;
  400f16:	2400      	movs	r4, #0
		if (_usb_d_dev_handle_nep()) {
  400f18:	2c00      	cmp	r4, #0
  400f1a:	d0e6      	beq.n	400eea <USBHS_Handler+0x22>
  400f1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	((Usbhs *)hw)->USBHS_DEVICR = data;
  400f1e:	2204      	movs	r2, #4
  400f20:	4b5f      	ldr	r3, [pc, #380]	; (4010a0 <USBHS_Handler+0x1d8>)
  400f22:	609a      	str	r2, [r3, #8]
	dev_inst.callbacks.sof();
  400f24:	4b5f      	ldr	r3, [pc, #380]	; (4010a4 <USBHS_Handler+0x1dc>)
  400f26:	681b      	ldr	r3, [r3, #0]
  400f28:	4798      	blx	r3
  400f2a:	e7f5      	b.n	400f18 <USBHS_Handler+0x50>
  400f2c:	2202      	movs	r2, #2
  400f2e:	4b5c      	ldr	r3, [pc, #368]	; (4010a0 <USBHS_Handler+0x1d8>)
  400f30:	609a      	str	r2, [r3, #8]
	dev_inst.callbacks.sof();
  400f32:	4b5c      	ldr	r3, [pc, #368]	; (4010a4 <USBHS_Handler+0x1dc>)
  400f34:	681b      	ldr	r3, [r3, #0]
  400f36:	4798      	blx	r3
  400f38:	e7ee      	b.n	400f18 <USBHS_Handler+0x50>
  400f3a:	4b59      	ldr	r3, [pc, #356]	; (4010a0 <USBHS_Handler+0x1d8>)
  400f3c:	2270      	movs	r2, #112	; 0x70
  400f3e:	609a      	str	r2, [r3, #8]
	((Usbhs *)hw)->USBHS_DEVIDR = mask;
  400f40:	615a      	str	r2, [r3, #20]
	((Usbhs *)hw)->USBHS_DEVIER = USBHS_DEVIMR_SUSPE;
  400f42:	2201      	movs	r2, #1
  400f44:	619a      	str	r2, [r3, #24]
	dev_inst.callbacks.event(USB_EV_WAKEUP, 0);
  400f46:	4b57      	ldr	r3, [pc, #348]	; (4010a4 <USBHS_Handler+0x1dc>)
  400f48:	685b      	ldr	r3, [r3, #4]
  400f4a:	2100      	movs	r1, #0
  400f4c:	2002      	movs	r0, #2
  400f4e:	4798      	blx	r3
  400f50:	e7e2      	b.n	400f18 <USBHS_Handler+0x50>
	((Usbhs *)hw)->USBHS_DEVICR = data;
  400f52:	4b53      	ldr	r3, [pc, #332]	; (4010a0 <USBHS_Handler+0x1d8>)
  400f54:	2208      	movs	r2, #8
  400f56:	609a      	str	r2, [r3, #8]
	((Usbhs *)hw)->USBHS_DEVIDR = mask;
  400f58:	2270      	movs	r2, #112	; 0x70
  400f5a:	615a      	str	r2, [r3, #20]
	((Usbhs *)hw)->USBHS_DEVIER = mask;
  400f5c:	2701      	movs	r7, #1
  400f5e:	619f      	str	r7, [r3, #24]
	_usb_d_dev_reset_epts();
  400f60:	4b51      	ldr	r3, [pc, #324]	; (4010a8 <USBHS_Handler+0x1e0>)
  400f62:	4798      	blx	r3
	dev_inst.callbacks.event(USB_EV_RESET, 0);
  400f64:	4b4f      	ldr	r3, [pc, #316]	; (4010a4 <USBHS_Handler+0x1dc>)
  400f66:	685b      	ldr	r3, [r3, #4]
  400f68:	2100      	movs	r1, #0
  400f6a:	4638      	mov	r0, r7
  400f6c:	4798      	blx	r3
  400f6e:	e7d3      	b.n	400f18 <USBHS_Handler+0x50>
	((Usbhs *)hw)->USBHS_DEVICR = data;
  400f70:	4b4b      	ldr	r3, [pc, #300]	; (4010a0 <USBHS_Handler+0x1d8>)
  400f72:	2201      	movs	r2, #1
  400f74:	609a      	str	r2, [r3, #8]
	((Usbhs *)hw)->USBHS_DEVIDR = mask;
  400f76:	615a      	str	r2, [r3, #20]
	((Usbhs *)hw)->USBHS_DEVIER = mask;
  400f78:	2270      	movs	r2, #112	; 0x70
  400f7a:	619a      	str	r2, [r3, #24]
	dev_inst.callbacks.event(USB_EV_SUSPEND, 0);
  400f7c:	4b49      	ldr	r3, [pc, #292]	; (4010a4 <USBHS_Handler+0x1dc>)
  400f7e:	685b      	ldr	r3, [r3, #4]
  400f80:	2100      	movs	r1, #0
  400f82:	2004      	movs	r0, #4
  400f84:	4798      	blx	r3
  400f86:	e7c7      	b.n	400f18 <USBHS_Handler+0x50>
	uint8_t epn = USB_EP_GET_N(ept->ep);
  400f88:	7c83      	ldrb	r3, [r0, #18]
  400f8a:	f003 030f 	and.w	r3, r3, #15
	if (!(epint & (1u << epn))) {
  400f8e:	2201      	movs	r2, #1
  400f90:	409a      	lsls	r2, r3
  400f92:	4216      	tst	r6, r2
  400f94:	d027      	beq.n	400fe6 <USBHS_Handler+0x11e>
	return ((Usbhs *)hw)->USBHS_DEVEPTISR[index];
  400f96:	4942      	ldr	r1, [pc, #264]	; (4010a0 <USBHS_Handler+0x1d8>)
  400f98:	f103 024c 	add.w	r2, r3, #76	; 0x4c
  400f9c:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
	return ((Usbhs *)hw)->USBHS_DEVEPTIMR[index];
  400fa0:	3370      	adds	r3, #112	; 0x70
  400fa2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
	mask  = hri_usbhs_read_DEVEPTIMR_reg(hw, epn);
  400fa6:	b2db      	uxtb	r3, r3
	if (flags) {
  400fa8:	401a      	ands	r2, r3
  400faa:	d01c      	beq.n	400fe6 <USBHS_Handler+0x11e>
		if (flags & USBHS_DEVEPTISR_STALLEDI) {
  400fac:	f012 0f40 	tst.w	r2, #64	; 0x40
  400fb0:	d117      	bne.n	400fe2 <USBHS_Handler+0x11a>
		} else if (!_usb_d_dev_ep_is_busy(ept)) {
  400fb2:	7cc3      	ldrb	r3, [r0, #19]
  400fb4:	f013 0f40 	tst.w	r3, #64	; 0x40
  400fb8:	d04f      	beq.n	40105a <USBHS_Handler+0x192>
		} else if (_usb_d_dev_ep_is_in(ept)) {
  400fba:	f013 0f80 	tst.w	r3, #128	; 0x80
  400fbe:	d158      	bne.n	401072 <USBHS_Handler+0x1aa>
	if (flags & USBHS_DEVEPTISR_OVERFI) {
  400fc0:	f012 0f20 	tst.w	r2, #32
  400fc4:	d166      	bne.n	401094 <USBHS_Handler+0x1cc>
	} else if (flags & USBHS_DEVEPTISR_RXOUTI) {
  400fc6:	f012 0f02 	tst.w	r2, #2
  400fca:	d166      	bne.n	40109a <USBHS_Handler+0x1d2>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
  400fcc:	7cc3      	ldrb	r3, [r0, #19]
  400fce:	f003 0307 	and.w	r3, r3, #7
  400fd2:	2b01      	cmp	r3, #1
  400fd4:	d107      	bne.n	400fe6 <USBHS_Handler+0x11e>
		if (flags & USBHS_DEVEPTISR_RXSTPI) {
  400fd6:	f012 0f04 	tst.w	r2, #4
  400fda:	d004      	beq.n	400fe6 <USBHS_Handler+0x11e>
			_usb_d_dev_handle_setup(ept);
  400fdc:	4b33      	ldr	r3, [pc, #204]	; (4010ac <USBHS_Handler+0x1e4>)
  400fde:	4798      	blx	r3
  400fe0:	e001      	b.n	400fe6 <USBHS_Handler+0x11e>
			_usb_d_dev_handle_stall(ept);
  400fe2:	4b33      	ldr	r3, [pc, #204]	; (4010b0 <USBHS_Handler+0x1e8>)
  400fe4:	4798      	blx	r3
	for (i = 0; i < USB_D_N_EP; i++) {
  400fe6:	3401      	adds	r4, #1
  400fe8:	b2e4      	uxtb	r4, r4
  400fea:	2c03      	cmp	r4, #3
  400fec:	d896      	bhi.n	400f1c <USBHS_Handler+0x54>
		struct _usb_d_dev_ep *ept = &dev_inst.ep[i];
  400fee:	4a2d      	ldr	r2, [pc, #180]	; (4010a4 <USBHS_Handler+0x1dc>)
  400ff0:	00a3      	lsls	r3, r4, #2
  400ff2:	1919      	adds	r1, r3, r4
  400ff4:	0088      	lsls	r0, r1, #2
  400ff6:	4601      	mov	r1, r0
  400ff8:	3010      	adds	r0, #16
  400ffa:	4410      	add	r0, r2
  400ffc:	3004      	adds	r0, #4
		if (ept->ep == 0xFF) {
  400ffe:	440a      	add	r2, r1
  401000:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
  401004:	2bff      	cmp	r3, #255	; 0xff
  401006:	d0ee      	beq.n	400fe6 <USBHS_Handler+0x11e>
		if (ep_int) {
  401008:	2e00      	cmp	r6, #0
  40100a:	d1bd      	bne.n	400f88 <USBHS_Handler+0xc0>
		else if ((dma_int) && (_usb_d_dev_ep_is_dma(i))) {
  40100c:	2d00      	cmp	r5, #0
  40100e:	d0ea      	beq.n	400fe6 <USBHS_Handler+0x11e>
  401010:	1e63      	subs	r3, r4, #1
  401012:	b2db      	uxtb	r3, r3
  401014:	2b05      	cmp	r3, #5
  401016:	d8e6      	bhi.n	400fe6 <USBHS_Handler+0x11e>
	uint8_t  epn = USB_EP_GET_N(ept->ep);
  401018:	7c83      	ldrb	r3, [r0, #18]
  40101a:	f003 030f 	and.w	r3, r3, #15
	if (!(epint & (1u << (epn - 1)))) {
  40101e:	1e5f      	subs	r7, r3, #1
  401020:	2201      	movs	r2, #1
  401022:	40ba      	lsls	r2, r7
  401024:	4215      	tst	r5, r2
  401026:	d0de      	beq.n	400fe6 <USBHS_Handler+0x11e>
	if (hri_usbhs_get_DEVDMASTATUS_CHANN_ENB_bit(hw, (epn - 1))) {
  401028:	b2fb      	uxtb	r3, r7
	return (((Usbhs *)hw)->UsbhsDevdma[submodule_index].USBHS_DEVDMASTATUS & USBHS_DEVDMASTATUS_CHANN_ENB)
  40102a:	0119      	lsls	r1, r3, #4
  40102c:	4a21      	ldr	r2, [pc, #132]	; (4010b4 <USBHS_Handler+0x1ec>)
  40102e:	5852      	ldr	r2, [r2, r1]
  401030:	f012 0f01 	tst.w	r2, #1
  401034:	d1d7      	bne.n	400fe6 <USBHS_Handler+0x11e>
	hri_usbhs_clear_DEVIMR_reg(hw, (USBHS_DEVIMR_DMA_1 << (epn - 1)));
  401036:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
  40103a:	40b9      	lsls	r1, r7
	((Usbhs *)hw)->USBHS_DEVIDR = mask;
  40103c:	4a18      	ldr	r2, [pc, #96]	; (4010a0 <USBHS_Handler+0x1d8>)
  40103e:	6151      	str	r1, [r2, #20]
}

static inline hri_usbhs_devdmastatus_reg_t hri_usbhs_read_DEVDMASTATUS_BUFF_COUNT_bf(const void *const hw,
                                                                                     uint8_t           submodule_index)
{
	return (((Usbhs *)hw)->UsbhsDevdma[submodule_index].USBHS_DEVDMASTATUS & USBHS_DEVDMASTATUS_BUFF_COUNT_Msk)
  401040:	eb02 1303 	add.w	r3, r2, r3, lsl #4
  401044:	f8d3 231c 	ldr.w	r2, [r3, #796]	; 0x31c
	if (trans_next) {
  401048:	0c12      	lsrs	r2, r2, #16
  40104a:	d003      	beq.n	401054 <USBHS_Handler+0x18c>
		ept->trans_count -= trans_next;
  40104c:	6883      	ldr	r3, [r0, #8]
  40104e:	1a9b      	subs	r3, r3, r2
  401050:	6083      	str	r3, [r0, #8]
		ept->trans_size = ept->trans_count;
  401052:	6043      	str	r3, [r0, #4]
	_usb_d_dev_dma_next(ept);
  401054:	4b18      	ldr	r3, [pc, #96]	; (4010b8 <USBHS_Handler+0x1f0>)
  401056:	4798      	blx	r3
  401058:	e7c5      	b.n	400fe6 <USBHS_Handler+0x11e>
	if (flags & USBHS_DEVEPTISR_RXSTPI) {
  40105a:	f012 0f04 	tst.w	r2, #4
  40105e:	d105      	bne.n	40106c <USBHS_Handler+0x1a4>
	} else if (flags & USBHS_DEVEPTISR_STALLEDI) {
  401060:	f012 0f40 	tst.w	r2, #64	; 0x40
  401064:	d0bf      	beq.n	400fe6 <USBHS_Handler+0x11e>
		_usb_d_dev_handle_stall(ept);
  401066:	4b12      	ldr	r3, [pc, #72]	; (4010b0 <USBHS_Handler+0x1e8>)
  401068:	4798      	blx	r3
  40106a:	e7bc      	b.n	400fe6 <USBHS_Handler+0x11e>
		_usb_d_dev_handle_setup(ept);
  40106c:	4b0f      	ldr	r3, [pc, #60]	; (4010ac <USBHS_Handler+0x1e4>)
  40106e:	4798      	blx	r3
  401070:	e7b9      	b.n	400fe6 <USBHS_Handler+0x11e>
	if (flags & USBHS_DEVEPTISR_TXINI) {
  401072:	f012 0f01 	tst.w	r2, #1
  401076:	d10a      	bne.n	40108e <USBHS_Handler+0x1c6>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
  401078:	7cc3      	ldrb	r3, [r0, #19]
  40107a:	f003 0307 	and.w	r3, r3, #7
  40107e:	2b01      	cmp	r3, #1
  401080:	d1b1      	bne.n	400fe6 <USBHS_Handler+0x11e>
		if (flags & USBHS_DEVEPTISR_RXSTPI) {
  401082:	f012 0f04 	tst.w	r2, #4
  401086:	d0ae      	beq.n	400fe6 <USBHS_Handler+0x11e>
			_usb_d_dev_handle_setup(ept);
  401088:	4b08      	ldr	r3, [pc, #32]	; (4010ac <USBHS_Handler+0x1e4>)
  40108a:	4798      	blx	r3
  40108c:	e7ab      	b.n	400fe6 <USBHS_Handler+0x11e>
		_usb_d_dev_in_next(ept);
  40108e:	4b0b      	ldr	r3, [pc, #44]	; (4010bc <USBHS_Handler+0x1f4>)
  401090:	4798      	blx	r3
  401092:	e7a8      	b.n	400fe6 <USBHS_Handler+0x11e>
		_usb_d_dev_handle_overflow(ept);
  401094:	4b0a      	ldr	r3, [pc, #40]	; (4010c0 <USBHS_Handler+0x1f8>)
  401096:	4798      	blx	r3
  401098:	e7a5      	b.n	400fe6 <USBHS_Handler+0x11e>
		_usb_d_dev_out_next(ept);
  40109a:	4b0a      	ldr	r3, [pc, #40]	; (4010c4 <USBHS_Handler+0x1fc>)
  40109c:	4798      	blx	r3
  40109e:	e7a2      	b.n	400fe6 <USBHS_Handler+0x11e>
  4010a0:	40038000 	.word	0x40038000
  4010a4:	204000ac 	.word	0x204000ac
  4010a8:	00400b01 	.word	0x00400b01
  4010ac:	00400a5d 	.word	0x00400a5d
  4010b0:	00400b65 	.word	0x00400b65
  4010b4:	4003831c 	.word	0x4003831c
  4010b8:	00400b89 	.word	0x00400b89
  4010bc:	00400cd9 	.word	0x00400cd9
  4010c0:	00400cb1 	.word	0x00400cb1
  4010c4:	00400ded 	.word	0x00400ded

004010c8 <_usb_d_dev_init>:
{
  4010c8:	b508      	push	{r3, lr}
	tmp = ((Usbhs *)hw)->USBHS_CTRL;
  4010ca:	4b0e      	ldr	r3, [pc, #56]	; (401104 <_usb_d_dev_init+0x3c>)
  4010cc:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
	if (hri_usbhs_get_CTRL_USBE_bit(hw)) {
  4010d0:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  4010d4:	d113      	bne.n	4010fe <_usb_d_dev_init+0x36>
	dev_inst.callbacks.sof   = (_usb_d_dev_sof_cb_t)_dummy_func_no_return;
  4010d6:	4b0c      	ldr	r3, [pc, #48]	; (401108 <_usb_d_dev_init+0x40>)
  4010d8:	4a0c      	ldr	r2, [pc, #48]	; (40110c <_usb_d_dev_init+0x44>)
  4010da:	601a      	str	r2, [r3, #0]
	dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)_dummy_func_no_return;
  4010dc:	605a      	str	r2, [r3, #4]
	dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)_dummy_func_no_return;
  4010de:	609a      	str	r2, [r3, #8]
	dev_inst.ep_callbacks.more  = (_usb_d_dev_ep_cb_more_t)_dummy_func_return_false;
  4010e0:	490b      	ldr	r1, [pc, #44]	; (401110 <_usb_d_dev_init+0x48>)
  4010e2:	60d9      	str	r1, [r3, #12]
	dev_inst.ep_callbacks.done  = (_usb_d_dev_ep_cb_done_t)_dummy_func_no_return;
  4010e4:	611a      	str	r2, [r3, #16]
	_usb_d_dev_reset_epts();
  4010e6:	4b0b      	ldr	r3, [pc, #44]	; (401114 <_usb_d_dev_init+0x4c>)
  4010e8:	4798      	blx	r3
	((Usbhs *)hw)->USBHS_CTRL = data;
  4010ea:	4b06      	ldr	r3, [pc, #24]	; (401104 <_usb_d_dev_init+0x3c>)
  4010ec:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  4010f0:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
	((Usbhs *)hw)->USBHS_DEVCTRL = data;
  4010f4:	f44f 6250 	mov.w	r2, #3328	; 0xd00
  4010f8:	601a      	str	r2, [r3, #0]
	return ERR_NONE;
  4010fa:	2000      	movs	r0, #0
  4010fc:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
  4010fe:	f06f 0010 	mvn.w	r0, #16
}
  401102:	bd08      	pop	{r3, pc}
  401104:	40038000 	.word	0x40038000
  401108:	204000ac 	.word	0x204000ac
  40110c:	00400a55 	.word	0x00400a55
  401110:	00400a57 	.word	0x00400a57
  401114:	00400b01 	.word	0x00400b01

00401118 <_usb_d_dev_ep_stall>:
	uint8_t               epn = USB_EP_GET_N(ep);
  401118:	f000 000f 	and.w	r0, r0, #15
	struct _usb_d_dev_ep *ept = &dev_inst.ep[epn];
  40111c:	eb00 0280 	add.w	r2, r0, r0, lsl #2
  401120:	0093      	lsls	r3, r2, #2
  401122:	3310      	adds	r3, #16
  401124:	4a48      	ldr	r2, [pc, #288]	; (401248 <_usb_d_dev_ep_stall+0x130>)
  401126:	4413      	add	r3, r2
	if (epn > CONF_USB_D_MAX_EP_N) {
  401128:	2803      	cmp	r0, #3
  40112a:	f200 8083 	bhi.w	401234 <_usb_d_dev_ep_stall+0x11c>
  40112e:	3304      	adds	r3, #4
	if (USB_EP_STALL_SET == ctrl) {
  401130:	2901      	cmp	r1, #1
  401132:	d00a      	beq.n	40114a <_usb_d_dev_ep_stall+0x32>
	} else if (USB_EP_STALL_CLR == ctrl) {
  401134:	b3b9      	cbz	r1, 4011a6 <_usb_d_dev_ep_stall+0x8e>
	return ept->flags.bits.is_stalled;
  401136:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  40113a:	0082      	lsls	r2, r0, #2
  40113c:	4b42      	ldr	r3, [pc, #264]	; (401248 <_usb_d_dev_ep_stall+0x130>)
  40113e:	4413      	add	r3, r2
  401140:	f893 0027 	ldrb.w	r0, [r3, #39]	; 0x27
  401144:	f3c0 00c0 	ubfx	r0, r0, #3, #1
  401148:	4770      	bx	lr
	uint8_t epn = USB_EP_GET_N(ept->ep);
  40114a:	eb00 0380 	add.w	r3, r0, r0, lsl #2
  40114e:	009a      	lsls	r2, r3, #2
  401150:	4b3d      	ldr	r3, [pc, #244]	; (401248 <_usb_d_dev_ep_stall+0x130>)
  401152:	4413      	add	r3, r2
  401154:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
  401158:	f003 030f 	and.w	r3, r3, #15
	if (epn > CONF_USB_D_MAX_EP_N) {
  40115c:	2b03      	cmp	r3, #3
  40115e:	d86c      	bhi.n	40123a <_usb_d_dev_ep_stall+0x122>
	if (!ept->flags.bits.is_stalled) {
  401160:	eb00 0280 	add.w	r2, r0, r0, lsl #2
  401164:	0091      	lsls	r1, r2, #2
  401166:	4a38      	ldr	r2, [pc, #224]	; (401248 <_usb_d_dev_ep_stall+0x130>)
  401168:	440a      	add	r2, r1
  40116a:	f892 2027 	ldrb.w	r2, [r2, #39]	; 0x27
  40116e:	f012 0f08 	tst.w	r2, #8
  401172:	d165      	bne.n	401240 <_usb_d_dev_ep_stall+0x128>
		ept->flags.bits.is_stalled = 1;
  401174:	4a34      	ldr	r2, [pc, #208]	; (401248 <_usb_d_dev_ep_stall+0x130>)
  401176:	440a      	add	r2, r1
  401178:	f892 1027 	ldrb.w	r1, [r2, #39]	; 0x27
  40117c:	f041 0108 	orr.w	r1, r1, #8
  401180:	f882 1027 	strb.w	r1, [r2, #39]	; 0x27
	((Usbhs *)hw)->USBHS_DEVEPTIER[index] = data;
  401184:	4a31      	ldr	r2, [pc, #196]	; (40124c <_usb_d_dev_ep_stall+0x134>)
  401186:	f103 007c 	add.w	r0, r3, #124	; 0x7c
  40118a:	2140      	movs	r1, #64	; 0x40
  40118c:	f842 1020 	str.w	r1, [r2, r0, lsl #2]
	hri_usbhs_set_DEVIMR_reg(USBHS, USBHS_DEVIMR_PEP_0 << epn);
  401190:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  401194:	fa01 f303 	lsl.w	r3, r1, r3
	((Usbhs *)hw)->USBHS_DEVIER = mask;
  401198:	6193      	str	r3, [r2, #24]
	((Usbhs *)hw)->USBHS_DEVEPTIER[index] = data;
  40119a:	f44f 2300 	mov.w	r3, #524288	; 0x80000
  40119e:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
	return ERR_NONE;
  4011a2:	2000      	movs	r0, #0
  4011a4:	4770      	bx	lr
	uint8_t epn = USB_EP_GET_N(ept->ep);
  4011a6:	7c9a      	ldrb	r2, [r3, #18]
  4011a8:	f002 020f 	and.w	r2, r2, #15
	if (!ept->flags.bits.is_stalled) {
  4011ac:	7cd9      	ldrb	r1, [r3, #19]
  4011ae:	f011 0f08 	tst.w	r1, #8
  4011b2:	d047      	beq.n	401244 <_usb_d_dev_ep_stall+0x12c>
{
  4011b4:	b410      	push	{r4}
	((Usbhs *)hw)->USBHS_DEVEPTIDR[index] = data;
  4011b6:	4825      	ldr	r0, [pc, #148]	; (40124c <_usb_d_dev_ep_stall+0x134>)
  4011b8:	f102 0188 	add.w	r1, r2, #136	; 0x88
  4011bc:	f44f 2400 	mov.w	r4, #524288	; 0x80000
  4011c0:	f840 4021 	str.w	r4, [r0, r1, lsl #2]
  4011c4:	2440      	movs	r4, #64	; 0x40
  4011c6:	f840 4021 	str.w	r4, [r0, r1, lsl #2]
	return (((Usbhs *)hw)->USBHS_DEVEPTISR[index] & USBHS_DEVEPTISR_CTRL_STALLEDI) >> USBHS_DEVEPTISR_CTRL_STALLEDI_Pos;
  4011ca:	f102 014c 	add.w	r1, r2, #76	; 0x4c
  4011ce:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
	if (_usbd_ep_is_stall_sent(epn)) {
  4011d2:	f011 0f40 	tst.w	r1, #64	; 0x40
  4011d6:	d014      	beq.n	401202 <_usb_d_dev_ep_stall+0xea>
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  4011d8:	4601      	mov	r1, r0
  4011da:	f102 0058 	add.w	r0, r2, #88	; 0x58
  4011de:	f841 4020 	str.w	r4, [r1, r0, lsl #2]
	hri_usbhs_set_DEVEPT_reg(hw, USBHS_DEVEPT_EPRST0 << epn);
  4011e2:	f44f 3080 	mov.w	r0, #65536	; 0x10000
  4011e6:	4090      	lsls	r0, r2
	((Usbhs *)hw)->USBHS_DEVEPT |= mask;
  4011e8:	69cc      	ldr	r4, [r1, #28]
  4011ea:	4304      	orrs	r4, r0
  4011ec:	61cc      	str	r4, [r1, #28]
	((Usbhs *)hw)->USBHS_DEVEPT &= ~mask;
  4011ee:	69cc      	ldr	r4, [r1, #28]
  4011f0:	ea24 0000 	bic.w	r0, r4, r0
  4011f4:	61c8      	str	r0, [r1, #28]
	((Usbhs *)hw)->USBHS_DEVEPTIER[index] = data;
  4011f6:	f102 007c 	add.w	r0, r2, #124	; 0x7c
  4011fa:	f44f 2480 	mov.w	r4, #262144	; 0x40000
  4011fe:	f841 4020 	str.w	r4, [r1, r0, lsl #2]
	if (_usb_d_dev_ep_is_ctrl(ept)) {
  401202:	7cd9      	ldrb	r1, [r3, #19]
  401204:	f001 0107 	and.w	r1, r1, #7
  401208:	2901      	cmp	r1, #1
  40120a:	d007      	beq.n	40121c <_usb_d_dev_ep_stall+0x104>
		ept->flags.bits.is_stalled = 0;
  40120c:	7cda      	ldrb	r2, [r3, #19]
  40120e:	f36f 02c3 	bfc	r2, #3, #1
  401212:	74da      	strb	r2, [r3, #19]
		rc = _usb_d_dev_ep_stall_clr(ept);
  401214:	2000      	movs	r0, #0
}
  401216:	f85d 4b04 	ldr.w	r4, [sp], #4
  40121a:	4770      	bx	lr
	return ((Usbhs *)hw)->USBHS_DEVEPTISR[index];
  40121c:	324c      	adds	r2, #76	; 0x4c
  40121e:	490b      	ldr	r1, [pc, #44]	; (40124c <_usb_d_dev_ep_stall+0x134>)
  401220:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
		if ((hri_usbhs_read_DEVEPTISR_reg(USBHS, epn) & USBHS_DEVEPTISR_STALLEDI) == 0) {
  401224:	f012 0f40 	tst.w	r2, #64	; 0x40
  401228:	d1f4      	bne.n	401214 <_usb_d_dev_ep_stall+0xfc>
			ept->flags.bits.is_stalled = 0;
  40122a:	7cda      	ldrb	r2, [r3, #19]
  40122c:	f36f 02c3 	bfc	r2, #3, #1
  401230:	74da      	strb	r2, [r3, #19]
  401232:	e7ef      	b.n	401214 <_usb_d_dev_ep_stall+0xfc>
		return -USB_ERR_PARAM;
  401234:	f06f 0011 	mvn.w	r0, #17
  401238:	4770      	bx	lr
		return ERR_NOT_FOUND;
  40123a:	f06f 0009 	mvn.w	r0, #9
  40123e:	4770      	bx	lr
	return ERR_NONE;
  401240:	2000      	movs	r0, #0
  401242:	4770      	bx	lr
		rc = _usb_d_dev_ep_stall_clr(ept);
  401244:	2000      	movs	r0, #0
}
  401246:	4770      	bx	lr
  401248:	204000ac 	.word	0x204000ac
  40124c:	40038000 	.word	0x40038000

00401250 <_usb_d_dev_ep_read_req>:
}

int32_t _usb_d_dev_ep_read_req(const uint8_t ep, uint8_t *req_buf)
{
  401250:	b410      	push	{r4}
	uint8_t epn = USB_EP_GET_N(ep);
  401252:	f000 000f 	and.w	r0, r0, #15
	tmp = ((Usbhs *)hw)->USBHS_DEVEPTISR[index];
  401256:	f100 024c 	add.w	r2, r0, #76	; 0x4c
  40125a:	4b1b      	ldr	r3, [pc, #108]	; (4012c8 <_usb_d_dev_ep_read_req+0x78>)
  40125c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
	return (hri_usbhs_get_DEVEPTISR_reg(USBHS, epn, USBHS_DEVEPTISR_BYCT_Msk) >> USBHS_DEVEPTISR_BYCT_Pos);
  401260:	f3c2 520a 	ubfx	r2, r2, #20, #11

	uint16_t bytes = _usbd_ep_get_trans_count(epn);

	if (epn > CONF_USB_D_MAX_EP_N || !req_buf) {
  401264:	460c      	mov	r4, r1
  401266:	fab1 f181 	clz	r1, r1
  40126a:	0949      	lsrs	r1, r1, #5
  40126c:	2803      	cmp	r0, #3
  40126e:	bf88      	it	hi
  401270:	f041 0101 	orrhi.w	r1, r1, #1
  401274:	bb09      	cbnz	r1, 4012ba <_usb_d_dev_ep_read_req+0x6a>
	tmp = ((Usbhs *)hw)->USBHS_DEVEPTCFG[index];
  401276:	f100 0340 	add.w	r3, r0, #64	; 0x40
  40127a:	4913      	ldr	r1, [pc, #76]	; (4012c8 <_usb_d_dev_ep_read_req+0x78>)
  40127c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
		return -USB_ERR_PARAM;
	}

	if (!_usbd_ep_is_ctrl(epn)) {
  401280:	f413 5fc0 	tst.w	r3, #6144	; 0x1800
  401284:	d11c      	bne.n	4012c0 <_usb_d_dev_ep_read_req+0x70>
	return (((Usbhs *)hw)->USBHS_DEVEPTISR[index] & USBHS_DEVEPTISR_CTRL_RXSTPI) >> USBHS_DEVEPTISR_CTRL_RXSTPI_Pos;
  401286:	f100 034c 	add.w	r3, r0, #76	; 0x4c
  40128a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
		return -USB_ERR_FUNC;
	}

	if (!_usbd_ep_is_setup(epn)) {
  40128e:	f013 0f04 	tst.w	r3, #4
  401292:	d103      	bne.n	40129c <_usb_d_dev_ep_read_req+0x4c>
		return ERR_NONE;
  401294:	2000      	movs	r0, #0
	memcpy(req_buf, (void *)ptr, 8);

	_usbd_ep_ack_setup(epn);

	return bytes;
}
  401296:	f85d 4b04 	ldr.w	r4, [sp], #4
  40129a:	4770      	bx	lr
	uint8_t *ptr = (uint8_t *)&_usbd_ep_get_fifo_access(epn, 8);
  40129c:	4b0b      	ldr	r3, [pc, #44]	; (4012cc <_usb_d_dev_ep_read_req+0x7c>)
  40129e:	eb03 33c0 	add.w	r3, r3, r0, lsl #15
	memcpy(req_buf, (void *)ptr, 8);
  4012a2:	6819      	ldr	r1, [r3, #0]
  4012a4:	685b      	ldr	r3, [r3, #4]
  4012a6:	6021      	str	r1, [r4, #0]
  4012a8:	6063      	str	r3, [r4, #4]
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  4012aa:	f100 0358 	add.w	r3, r0, #88	; 0x58
  4012ae:	2004      	movs	r0, #4
  4012b0:	4905      	ldr	r1, [pc, #20]	; (4012c8 <_usb_d_dev_ep_read_req+0x78>)
  4012b2:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
	return bytes;
  4012b6:	4610      	mov	r0, r2
  4012b8:	e7ed      	b.n	401296 <_usb_d_dev_ep_read_req+0x46>
		return -USB_ERR_PARAM;
  4012ba:	f06f 0011 	mvn.w	r0, #17
  4012be:	e7ea      	b.n	401296 <_usb_d_dev_ep_read_req+0x46>
		return -USB_ERR_FUNC;
  4012c0:	f06f 0012 	mvn.w	r0, #18
  4012c4:	e7e7      	b.n	401296 <_usb_d_dev_ep_read_req+0x46>
  4012c6:	bf00      	nop
  4012c8:	40038000 	.word	0x40038000
  4012cc:	a0100000 	.word	0xa0100000

004012d0 <_usb_d_dev_ep_trans>:

int32_t _usb_d_dev_ep_trans(const struct usb_d_transfer *trans)
{
  4012d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4012d4:	b085      	sub	sp, #20
	Usbhs *               hw  = USBHS;
	uint8_t               epn = USB_EP_GET_N(trans->ep);
  4012d6:	7a07      	ldrb	r7, [r0, #8]
  4012d8:	f007 040f 	and.w	r4, r7, #15
  4012dc:	b27f      	sxtb	r7, r7
	bool                  dir = USB_EP_GET_DIR(trans->ep);
  4012de:	ea4f 79d7 	mov.w	r9, r7, lsr #31
	struct _usb_d_dev_ep *ept = &dev_inst.ep[epn];
  4012e2:	4a52      	ldr	r2, [pc, #328]	; (40142c <_usb_d_dev_ep_trans+0x15c>)
  4012e4:	00a3      	lsls	r3, r4, #2
  4012e6:	1919      	adds	r1, r3, r4
  4012e8:	008d      	lsls	r5, r1, #2
  4012ea:	3510      	adds	r5, #16
  4012ec:	4415      	add	r5, r2
  4012ee:	3504      	adds	r5, #4

	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
  4012f0:	0089      	lsls	r1, r1, #2
  4012f2:	440a      	add	r2, r1
  4012f4:	8c96      	ldrh	r6, [r2, #36]	; 0x24
  4012f6:	f240 33ff 	movw	r3, #1023	; 0x3ff
  4012fa:	429e      	cmp	r6, r3
  4012fc:	d001      	beq.n	401302 <_usb_d_dev_ep_trans+0x32>
  4012fe:	3e01      	subs	r6, #1
  401300:	b2b6      	uxth	r6, r6
	bool     size_n_aligned = (trans->size & size_mask);
  401302:	6843      	ldr	r3, [r0, #4]
  401304:	401e      	ands	r6, r3
	bool     is_ctrl        = _usb_d_dev_ep_is_ctrl(ept);
  401306:	eb04 0384 	add.w	r3, r4, r4, lsl #2
  40130a:	009a      	lsls	r2, r3, #2
  40130c:	4b47      	ldr	r3, [pc, #284]	; (40142c <_usb_d_dev_ep_trans+0x15c>)
  40130e:	4413      	add	r3, r2
  401310:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  401314:	f003 0a07 	and.w	sl, r3, #7

	volatile hal_atomic_t flags;

	if (epn > CONF_USB_D_MAX_EP_N) {
  401318:	2c03      	cmp	r4, #3
  40131a:	f200 8083 	bhi.w	401424 <_usb_d_dev_ep_trans+0x154>
		return -USB_ERR_PARAM;
	}

	/* Check halt */
	if (ept->flags.bits.is_stalled) {
  40131e:	f013 0f08 	tst.w	r3, #8
  401322:	d003      	beq.n	40132c <_usb_d_dev_ep_trans+0x5c>
		return USB_HALTED;
  401324:	2002      	movs	r0, #2
#if (CONF_USB_D_DMA_ENABLE == 1)
	}
#endif

	return ERR_NONE;
}
  401326:	b005      	add	sp, #20
  401328:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40132c:	4680      	mov	r8, r0
	atomic_enter_critical(&flags);
  40132e:	a803      	add	r0, sp, #12
  401330:	4b3f      	ldr	r3, [pc, #252]	; (401430 <_usb_d_dev_ep_trans+0x160>)
  401332:	4798      	blx	r3
	if (_usb_d_dev_ep_is_busy(ept)) {
  401334:	eb04 0384 	add.w	r3, r4, r4, lsl #2
  401338:	009a      	lsls	r2, r3, #2
  40133a:	4b3c      	ldr	r3, [pc, #240]	; (40142c <_usb_d_dev_ep_trans+0x15c>)
  40133c:	4413      	add	r3, r2
  40133e:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  401342:	f013 0f40 	tst.w	r3, #64	; 0x40
  401346:	d128      	bne.n	40139a <_usb_d_dev_ep_trans+0xca>
	ept->flags.bits.is_busy = 1;
  401348:	00a3      	lsls	r3, r4, #2
  40134a:	4423      	add	r3, r4
  40134c:	009a      	lsls	r2, r3, #2
  40134e:	4b37      	ldr	r3, [pc, #220]	; (40142c <_usb_d_dev_ep_trans+0x15c>)
  401350:	eb03 0b02 	add.w	fp, r3, r2
  401354:	f10b 0320 	add.w	r3, fp, #32
  401358:	4619      	mov	r1, r3
  40135a:	79db      	ldrb	r3, [r3, #7]
  40135c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  401360:	9101      	str	r1, [sp, #4]
  401362:	71cb      	strb	r3, [r1, #7]
	atomic_leave_critical(&flags);
  401364:	a803      	add	r0, sp, #12
  401366:	4b33      	ldr	r3, [pc, #204]	; (401434 <_usb_d_dev_ep_trans+0x164>)
  401368:	4798      	blx	r3
	ept->trans_buf   = trans->buf;
  40136a:	f8d8 3000 	ldr.w	r3, [r8]
  40136e:	f8cb 3014 	str.w	r3, [fp, #20]
	ept->trans_size  = trans->size;
  401372:	f8d8 3004 	ldr.w	r3, [r8, #4]
  401376:	f8cb 3018 	str.w	r3, [fp, #24]
	ept->trans_count = 0;
  40137a:	2300      	movs	r3, #0
  40137c:	f8cb 301c 	str.w	r3, [fp, #28]
	ept->trans_load  = 0;
  401380:	f8cb 3020 	str.w	r3, [fp, #32]
	ept->flags.bits.dir      = dir;
  401384:	9901      	ldr	r1, [sp, #4]
  401386:	79cb      	ldrb	r3, [r1, #7]
  401388:	f369 13c7 	bfi	r3, r9, #7, #1
  40138c:	71cb      	strb	r3, [r1, #7]
	ept->flags.bits.need_zlp = (trans->zlp && (!size_n_aligned));
  40138e:	f898 3009 	ldrb.w	r3, [r8, #9]
  401392:	b13b      	cbz	r3, 4013a4 <_usb_d_dev_ep_trans+0xd4>
  401394:	b386      	cbz	r6, 4013f8 <_usb_d_dev_ep_trans+0x128>
  401396:	2100      	movs	r1, #0
  401398:	e005      	b.n	4013a6 <_usb_d_dev_ep_trans+0xd6>
		atomic_leave_critical(&flags);
  40139a:	a803      	add	r0, sp, #12
  40139c:	4b25      	ldr	r3, [pc, #148]	; (401434 <_usb_d_dev_ep_trans+0x164>)
  40139e:	4798      	blx	r3
		return USB_BUSY;
  4013a0:	2001      	movs	r0, #1
  4013a2:	e7c0      	b.n	401326 <_usb_d_dev_ep_trans+0x56>
	ept->flags.bits.need_zlp = (trans->zlp && (!size_n_aligned));
  4013a4:	2100      	movs	r1, #0
  4013a6:	eb04 0384 	add.w	r3, r4, r4, lsl #2
  4013aa:	009a      	lsls	r2, r3, #2
  4013ac:	4b1f      	ldr	r3, [pc, #124]	; (40142c <_usb_d_dev_ep_trans+0x15c>)
  4013ae:	4413      	add	r3, r2
  4013b0:	f893 2027 	ldrb.w	r2, [r3, #39]	; 0x27
  4013b4:	f361 1204 	bfi	r2, r1, #4, #1
  4013b8:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
	if (_usb_d_dev_ep_is_dma(epn)) {
  4013bc:	1e63      	subs	r3, r4, #1
  4013be:	b2db      	uxtb	r3, r3
  4013c0:	2b05      	cmp	r3, #5
  4013c2:	d91b      	bls.n	4013fc <_usb_d_dev_ep_trans+0x12c>
		if (!is_ctrl) {
  4013c4:	f1ba 0f01 	cmp.w	sl, #1
  4013c8:	d004      	beq.n	4013d4 <_usb_d_dev_ep_trans+0x104>
			hri_usbhs_set_DEVIMR_reg(hw, (USBHS_DEVIER_PEP_0 << epn));
  4013ca:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  4013ce:	40a3      	lsls	r3, r4
	((Usbhs *)hw)->USBHS_DEVIER = mask;
  4013d0:	4a19      	ldr	r2, [pc, #100]	; (401438 <_usb_d_dev_ep_trans+0x168>)
  4013d2:	6193      	str	r3, [r2, #24]
	((Usbhs *)hw)->USBHS_DEVEPTCFG[index] &= ~USBHS_DEVEPTCFG_AUTOSW;
  4013d4:	4a18      	ldr	r2, [pc, #96]	; (401438 <_usb_d_dev_ep_trans+0x168>)
  4013d6:	f104 0140 	add.w	r1, r4, #64	; 0x40
  4013da:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
  4013de:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  4013e2:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
		if (dir) {
  4013e6:	2f00      	cmp	r7, #0
  4013e8:	db15      	blt.n	401416 <_usb_d_dev_ep_trans+0x146>
	((Usbhs *)hw)->USBHS_DEVEPTIER[index] = data;
  4013ea:	347c      	adds	r4, #124	; 0x7c
  4013ec:	2202      	movs	r2, #2
  4013ee:	4b12      	ldr	r3, [pc, #72]	; (401438 <_usb_d_dev_ep_trans+0x168>)
  4013f0:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
	return ERR_NONE;
  4013f4:	2000      	movs	r0, #0
  4013f6:	e796      	b.n	401326 <_usb_d_dev_ep_trans+0x56>
	ept->flags.bits.need_zlp = (trans->zlp && (!size_n_aligned));
  4013f8:	2101      	movs	r1, #1
  4013fa:	e7d4      	b.n	4013a6 <_usb_d_dev_ep_trans+0xd6>
	((Usbhs *)hw)->USBHS_DEVEPTCFG[index] |= USBHS_DEVEPTCFG_AUTOSW;
  4013fc:	4a0e      	ldr	r2, [pc, #56]	; (401438 <_usb_d_dev_ep_trans+0x168>)
  4013fe:	3440      	adds	r4, #64	; 0x40
  401400:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
  401404:	f443 7300 	orr.w	r3, r3, #512	; 0x200
  401408:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
		_usb_d_dev_dma_next(ept);
  40140c:	4628      	mov	r0, r5
  40140e:	4b0b      	ldr	r3, [pc, #44]	; (40143c <_usb_d_dev_ep_trans+0x16c>)
  401410:	4798      	blx	r3
	return ERR_NONE;
  401412:	2000      	movs	r0, #0
  401414:	e787      	b.n	401326 <_usb_d_dev_ep_trans+0x56>
	((Usbhs *)hw)->USBHS_DEVEPTIER[index] = data;
  401416:	347c      	adds	r4, #124	; 0x7c
  401418:	2201      	movs	r2, #1
  40141a:	4b07      	ldr	r3, [pc, #28]	; (401438 <_usb_d_dev_ep_trans+0x168>)
  40141c:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
  401420:	2000      	movs	r0, #0
  401422:	e780      	b.n	401326 <_usb_d_dev_ep_trans+0x56>
		return -USB_ERR_PARAM;
  401424:	f06f 0011 	mvn.w	r0, #17
  401428:	e77d      	b.n	401326 <_usb_d_dev_ep_trans+0x56>
  40142a:	bf00      	nop
  40142c:	204000ac 	.word	0x204000ac
  401430:	0040034d 	.word	0x0040034d
  401434:	0040035b 	.word	0x0040035b
  401438:	40038000 	.word	0x40038000
  40143c:	00400b89 	.word	0x00400b89

00401440 <_usb_d_dev_register_ep_callback>:
	}
}

void _usb_d_dev_register_ep_callback(const enum usb_d_dev_ep_cb_type type, const FUNC_PTR func)
{
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
  401440:	460b      	mov	r3, r1
  401442:	b129      	cbz	r1, 401450 <_usb_d_dev_register_ep_callback+0x10>

	if (type == USB_D_DEV_EP_CB_SETUP) {
  401444:	b130      	cbz	r0, 401454 <_usb_d_dev_register_ep_callback+0x14>
		dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)f;
	} else if (type == USB_D_DEV_EP_CB_MORE) {
  401446:	2801      	cmp	r0, #1
  401448:	d007      	beq.n	40145a <_usb_d_dev_register_ep_callback+0x1a>
		dev_inst.ep_callbacks.more = (_usb_d_dev_ep_cb_more_t)f;
	} else if (type == USB_D_DEV_EP_CB_DONE) {
  40144a:	2802      	cmp	r0, #2
  40144c:	d008      	beq.n	401460 <_usb_d_dev_register_ep_callback+0x20>
  40144e:	4770      	bx	lr
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
  401450:	4b05      	ldr	r3, [pc, #20]	; (401468 <_usb_d_dev_register_ep_callback+0x28>)
  401452:	e7f7      	b.n	401444 <_usb_d_dev_register_ep_callback+0x4>
		dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)f;
  401454:	4a05      	ldr	r2, [pc, #20]	; (40146c <_usb_d_dev_register_ep_callback+0x2c>)
  401456:	6093      	str	r3, [r2, #8]
  401458:	4770      	bx	lr
		dev_inst.ep_callbacks.more = (_usb_d_dev_ep_cb_more_t)f;
  40145a:	4a04      	ldr	r2, [pc, #16]	; (40146c <_usb_d_dev_register_ep_callback+0x2c>)
  40145c:	60d3      	str	r3, [r2, #12]
  40145e:	4770      	bx	lr
		dev_inst.ep_callbacks.done = (_usb_d_dev_ep_cb_done_t)f;
  401460:	4a02      	ldr	r2, [pc, #8]	; (40146c <_usb_d_dev_register_ep_callback+0x2c>)
  401462:	6113      	str	r3, [r2, #16]
	}
}
  401464:	e7f3      	b.n	40144e <_usb_d_dev_register_ep_callback+0xe>
  401466:	bf00      	nop
  401468:	00400a55 	.word	0x00400a55
  40146c:	204000ac 	.word	0x204000ac

00401470 <read_trig_channel>:
 *
 * \param[in] pin       The pin number for device
 */
static inline bool gpio_get_pin_level(const uint8_t pin)
{
	return (bool)(_gpio_get_level((enum gpio_port)GPIO_PORT(pin)) & (0x01U << GPIO_PIN(pin)));
  401470:	0942      	lsrs	r2, r0, #5
 * \brief Transfer gpio_port to hardware address
 */
static inline void *port_to_reg(const enum gpio_port port)
{
	/* PIO instance offset is 0x200 */
	return (void *)((uint32_t)PIOA + port * 0x200);
  401472:	4b07      	ldr	r3, [pc, #28]	; (401490 <read_trig_channel+0x20>)
  401474:	eb03 2342 	add.w	r3, r3, r2, lsl #9
	return ((Pio *)hw)->PIO_PDSR;
  401478:	6bda      	ldr	r2, [r3, #60]	; 0x3c
  40147a:	f000 001f 	and.w	r0, r0, #31
  40147e:	2301      	movs	r3, #1
  401480:	fa03 f000 	lsl.w	r0, r3, r0
  401484:	4202      	tst	r2, r0
bool read_trig_channel(const uint8_t ch)
{
	bool status = gpio_get_pin_level(ch);
	// printf("trigger status: %s", status ? "true" : "false"); // need to set up serial for this to work
	return status;
}
  401486:	bf14      	ite	ne
  401488:	4618      	movne	r0, r3
  40148a:	2000      	moveq	r0, #0
  40148c:	4770      	bx	lr
  40148e:	bf00      	nop
  401490:	400e0e00 	.word	0x400e0e00

00401494 <main>:

int main(void)
{
  401494:	b508      	push	{r3, lr}
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
  401496:	4b0a      	ldr	r3, [pc, #40]	; (4014c0 <main+0x2c>)
  401498:	4798      	blx	r3
	//delay_init(TC2);
	
	//output has been changed to be with TC1, on PC30, which is TIOB5
	delay_init(TC1);
  40149a:	480a      	ldr	r0, [pc, #40]	; (4014c4 <main+0x30>)
  40149c:	4b0a      	ldr	r3, [pc, #40]	; (4014c8 <main+0x34>)
  40149e:	4798      	blx	r3
  4014a0:	e003      	b.n	4014aa <main+0x16>
			//start_timer(TC2, 2);
			start_timer(TC1, 1);
		}
		else {
			//stop_timer(TC2, 2);
			stop_timer(TC1, 1);
  4014a2:	2101      	movs	r1, #1
  4014a4:	4807      	ldr	r0, [pc, #28]	; (4014c4 <main+0x30>)
  4014a6:	4b09      	ldr	r3, [pc, #36]	; (4014cc <main+0x38>)
  4014a8:	4798      	blx	r3
		bool ch_status = read_trig_channel(PB3_TRIG);
  4014aa:	2023      	movs	r0, #35	; 0x23
  4014ac:	4b08      	ldr	r3, [pc, #32]	; (4014d0 <main+0x3c>)
  4014ae:	4798      	blx	r3
		if (ch_status) 
  4014b0:	2800      	cmp	r0, #0
  4014b2:	d0f6      	beq.n	4014a2 <main+0xe>
			start_timer(TC1, 1);
  4014b4:	2101      	movs	r1, #1
  4014b6:	4803      	ldr	r0, [pc, #12]	; (4014c4 <main+0x30>)
  4014b8:	4b06      	ldr	r3, [pc, #24]	; (4014d4 <main+0x40>)
  4014ba:	4798      	blx	r3
  4014bc:	e7f5      	b.n	4014aa <main+0x16>
  4014be:	bf00      	nop
  4014c0:	004001d5 	.word	0x004001d5
  4014c4:	40010000 	.word	0x40010000
  4014c8:	00400369 	.word	0x00400369
  4014cc:	00400a49 	.word	0x00400a49
  4014d0:	00401471 	.word	0x00401471
  4014d4:	00400a3d 	.word	0x00400a3d

004014d8 <__libc_init_array>:
  4014d8:	b570      	push	{r4, r5, r6, lr}
  4014da:	4e0d      	ldr	r6, [pc, #52]	; (401510 <__libc_init_array+0x38>)
  4014dc:	4c0d      	ldr	r4, [pc, #52]	; (401514 <__libc_init_array+0x3c>)
  4014de:	1ba4      	subs	r4, r4, r6
  4014e0:	10a4      	asrs	r4, r4, #2
  4014e2:	2500      	movs	r5, #0
  4014e4:	42a5      	cmp	r5, r4
  4014e6:	d109      	bne.n	4014fc <__libc_init_array+0x24>
  4014e8:	4e0b      	ldr	r6, [pc, #44]	; (401518 <__libc_init_array+0x40>)
  4014ea:	4c0c      	ldr	r4, [pc, #48]	; (40151c <__libc_init_array+0x44>)
  4014ec:	f000 f84c 	bl	401588 <_init>
  4014f0:	1ba4      	subs	r4, r4, r6
  4014f2:	10a4      	asrs	r4, r4, #2
  4014f4:	2500      	movs	r5, #0
  4014f6:	42a5      	cmp	r5, r4
  4014f8:	d105      	bne.n	401506 <__libc_init_array+0x2e>
  4014fa:	bd70      	pop	{r4, r5, r6, pc}
  4014fc:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  401500:	4798      	blx	r3
  401502:	3501      	adds	r5, #1
  401504:	e7ee      	b.n	4014e4 <__libc_init_array+0xc>
  401506:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  40150a:	4798      	blx	r3
  40150c:	3501      	adds	r5, #1
  40150e:	e7f2      	b.n	4014f6 <__libc_init_array+0x1e>
  401510:	00401594 	.word	0x00401594
  401514:	00401594 	.word	0x00401594
  401518:	00401594 	.word	0x00401594
  40151c:	00401598 	.word	0x00401598

00401520 <memcpy>:
  401520:	b510      	push	{r4, lr}
  401522:	1e43      	subs	r3, r0, #1
  401524:	440a      	add	r2, r1
  401526:	4291      	cmp	r1, r2
  401528:	d100      	bne.n	40152c <memcpy+0xc>
  40152a:	bd10      	pop	{r4, pc}
  40152c:	f811 4b01 	ldrb.w	r4, [r1], #1
  401530:	f803 4f01 	strb.w	r4, [r3, #1]!
  401534:	e7f7      	b.n	401526 <memcpy+0x6>

00401536 <memset>:
  401536:	4402      	add	r2, r0
  401538:	4603      	mov	r3, r0
  40153a:	4293      	cmp	r3, r2
  40153c:	d100      	bne.n	401540 <memset+0xa>
  40153e:	4770      	bx	lr
  401540:	f803 1b01 	strb.w	r1, [r3], #1
  401544:	e7f9      	b.n	40153a <memset+0x4>
	...

00401548 <_ext_irq>:
	...

00401564 <_pio_irq_n>:
  401564:	0b0a 100c 0011 0000 2e2e 682f 6c70 702f     ........../hpl/p
  401574:	6f69 682f 6c70 705f 6f69 655f 7478 632e     io/hpl_pio_ext.c
  401584:	0000 0000                                   ....

00401588 <_init>:
  401588:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40158a:	bf00      	nop
  40158c:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40158e:	bc08      	pop	{r3}
  401590:	469e      	mov	lr, r3
  401592:	4770      	bx	lr

00401594 <__init_array_start>:
  401594:	0040018d 	.word	0x0040018d

00401598 <_fini>:
  401598:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40159a:	bf00      	nop
  40159c:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40159e:	bc08      	pop	{r3}
  4015a0:	469e      	mov	lr, r3
  4015a2:	4770      	bx	lr

004015a4 <__fini_array_start>:
  4015a4:	00400169 	.word	0x00400169
