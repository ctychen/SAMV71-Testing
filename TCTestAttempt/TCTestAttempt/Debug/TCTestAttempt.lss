
TCTestAttempt.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000015ac  00400000  00400000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000000  20400000  20400000  000115ac  2**0
                  CONTENTS
  2 .bss          00000110  20400000  20400000  00020000  2**2
                  ALLOC
  3 .heap         00000200  20400110  20400110  00020000  2**0
                  ALLOC
  4 .stack        00000400  20400310  20400310  00020000  2**0
                  ALLOC
  5 .ARM.attributes 0000002e  00000000  00000000  000115ac  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  000115da  2**0
                  CONTENTS, READONLY
  7 .debug_info   0000d830  00000000  00000000  00011633  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00002050  00000000  00000000  0001ee63  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00005ec4  00000000  00000000  00020eb3  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000500  00000000  00000000  00026d77  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000004f0  00000000  00000000  00027277  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  0003c54e  00000000  00000000  00027767  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000cf9f  00000000  00000000  00063cb5  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00148504  00000000  00000000  00070c54  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00000c1c  00000000  00000000  001b9158  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <exception_table>:
  400000:	10 07 40 20 e5 01 40 00 e1 01 40 00 e1 01 40 00     ..@ ..@...@...@.
  400010:	e1 01 40 00 e1 01 40 00 e1 01 40 00 00 00 00 00     ..@...@...@.....
	...
  40002c:	e1 01 40 00 e1 01 40 00 00 00 00 00 e1 01 40 00     ..@...@.......@.
  40003c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40004c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40005c:	e1 01 40 00 e1 01 40 00 00 00 00 00 1d 09 40 00     ..@...@.......@.
  40006c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40007c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40008c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40009c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  4000ac:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  4000bc:	e1 01 40 00 e1 01 40 00 e1 01 40 00 cd 0e 40 00     ..@...@...@...@.
  4000cc:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  4000dc:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  4000ec:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  4000fc:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40010c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 00 00 00 00     ..@...@...@.....
  40011c:	00 00 00 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ......@...@...@.
  40012c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40013c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40014c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40015c:	e1 01 40 00 e1 01 40 00 e1 01 40 00                 ..@...@...@.

00400168 <__do_global_dtors_aux>:
  400168:	b510      	push	{r4, lr}
  40016a:	4c05      	ldr	r4, [pc, #20]	; (400180 <__do_global_dtors_aux+0x18>)
  40016c:	7823      	ldrb	r3, [r4, #0]
  40016e:	b933      	cbnz	r3, 40017e <__do_global_dtors_aux+0x16>
  400170:	4b04      	ldr	r3, [pc, #16]	; (400184 <__do_global_dtors_aux+0x1c>)
  400172:	b113      	cbz	r3, 40017a <__do_global_dtors_aux+0x12>
  400174:	4804      	ldr	r0, [pc, #16]	; (400188 <__do_global_dtors_aux+0x20>)
  400176:	f3af 8000 	nop.w
  40017a:	2301      	movs	r3, #1
  40017c:	7023      	strb	r3, [r4, #0]
  40017e:	bd10      	pop	{r4, pc}
  400180:	20400000 	.word	0x20400000
  400184:	00000000 	.word	0x00000000
  400188:	004015ac 	.word	0x004015ac

0040018c <frame_dummy>:
  40018c:	4b0c      	ldr	r3, [pc, #48]	; (4001c0 <frame_dummy+0x34>)
  40018e:	b143      	cbz	r3, 4001a2 <frame_dummy+0x16>
  400190:	480c      	ldr	r0, [pc, #48]	; (4001c4 <frame_dummy+0x38>)
  400192:	490d      	ldr	r1, [pc, #52]	; (4001c8 <frame_dummy+0x3c>)
  400194:	b510      	push	{r4, lr}
  400196:	f3af 8000 	nop.w
  40019a:	480c      	ldr	r0, [pc, #48]	; (4001cc <frame_dummy+0x40>)
  40019c:	6803      	ldr	r3, [r0, #0]
  40019e:	b923      	cbnz	r3, 4001aa <frame_dummy+0x1e>
  4001a0:	bd10      	pop	{r4, pc}
  4001a2:	480a      	ldr	r0, [pc, #40]	; (4001cc <frame_dummy+0x40>)
  4001a4:	6803      	ldr	r3, [r0, #0]
  4001a6:	b933      	cbnz	r3, 4001b6 <frame_dummy+0x2a>
  4001a8:	4770      	bx	lr
  4001aa:	4b09      	ldr	r3, [pc, #36]	; (4001d0 <frame_dummy+0x44>)
  4001ac:	2b00      	cmp	r3, #0
  4001ae:	d0f7      	beq.n	4001a0 <frame_dummy+0x14>
  4001b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  4001b4:	4718      	bx	r3
  4001b6:	4b06      	ldr	r3, [pc, #24]	; (4001d0 <frame_dummy+0x44>)
  4001b8:	2b00      	cmp	r3, #0
  4001ba:	d0f5      	beq.n	4001a8 <frame_dummy+0x1c>
  4001bc:	4718      	bx	r3
  4001be:	bf00      	nop
  4001c0:	00000000 	.word	0x00000000
  4001c4:	004015ac 	.word	0x004015ac
  4001c8:	20400004 	.word	0x20400004
  4001cc:	004015ac 	.word	0x004015ac
  4001d0:	00000000 	.word	0x00000000

004001d4 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
  4001d4:	b508      	push	{r3, lr}
	system_init();
  4001d6:	4b01      	ldr	r3, [pc, #4]	; (4001dc <atmel_start_init+0x8>)
  4001d8:	4798      	blx	r3
  4001da:	bd08      	pop	{r3, pc}
  4001dc:	004002f5 	.word	0x004002f5

004001e0 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  4001e0:	e7fe      	b.n	4001e0 <Dummy_Handler>
	...

004001e4 <Reset_Handler>:
{
  4001e4:	b508      	push	{r3, lr}
        if (pSrc != pDest) {
  4001e6:	4b10      	ldr	r3, [pc, #64]	; (400228 <Reset_Handler+0x44>)
  4001e8:	4a10      	ldr	r2, [pc, #64]	; (40022c <Reset_Handler+0x48>)
  4001ea:	429a      	cmp	r2, r3
  4001ec:	d009      	beq.n	400202 <Reset_Handler+0x1e>
  4001ee:	4b0e      	ldr	r3, [pc, #56]	; (400228 <Reset_Handler+0x44>)
  4001f0:	4a0e      	ldr	r2, [pc, #56]	; (40022c <Reset_Handler+0x48>)
  4001f2:	e003      	b.n	4001fc <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
  4001f4:	6811      	ldr	r1, [r2, #0]
  4001f6:	6019      	str	r1, [r3, #0]
  4001f8:	3304      	adds	r3, #4
  4001fa:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
  4001fc:	490c      	ldr	r1, [pc, #48]	; (400230 <Reset_Handler+0x4c>)
  4001fe:	428b      	cmp	r3, r1
  400200:	d3f8      	bcc.n	4001f4 <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
  400202:	4b0c      	ldr	r3, [pc, #48]	; (400234 <Reset_Handler+0x50>)
  400204:	e002      	b.n	40020c <Reset_Handler+0x28>
                *pDest++ = 0;
  400206:	2200      	movs	r2, #0
  400208:	601a      	str	r2, [r3, #0]
  40020a:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
  40020c:	4a0a      	ldr	r2, [pc, #40]	; (400238 <Reset_Handler+0x54>)
  40020e:	4293      	cmp	r3, r2
  400210:	d3f9      	bcc.n	400206 <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  400212:	4a0a      	ldr	r2, [pc, #40]	; (40023c <Reset_Handler+0x58>)
  400214:	4b0a      	ldr	r3, [pc, #40]	; (400240 <Reset_Handler+0x5c>)
  400216:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  40021a:	6093      	str	r3, [r2, #8]
        __libc_init_array();
  40021c:	4b09      	ldr	r3, [pc, #36]	; (400244 <Reset_Handler+0x60>)
  40021e:	4798      	blx	r3
        main();
  400220:	4b09      	ldr	r3, [pc, #36]	; (400248 <Reset_Handler+0x64>)
  400222:	4798      	blx	r3
  400224:	e7fe      	b.n	400224 <Reset_Handler+0x40>
  400226:	bf00      	nop
  400228:	20400000 	.word	0x20400000
  40022c:	004015ac 	.word	0x004015ac
  400230:	20400000 	.word	0x20400000
  400234:	20400000 	.word	0x20400000
  400238:	20400110 	.word	0x20400110
  40023c:	e000ed00 	.word	0xe000ed00
  400240:	00400000 	.word	0x00400000
  400244:	004014dd 	.word	0x004014dd
  400248:	00401499 	.word	0x00401499

0040024c <TIMER_0_PORT_init>:
}

static inline void hri_pio_set_ABCDSR_reg(const void *const hw, uint8_t index, hri_pio_abcdsr_reg_t mask)
{
	PIO_CRITICAL_SECTION_ENTER();
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  40024c:	4b05      	ldr	r3, [pc, #20]	; (400264 <TIMER_0_PORT_init+0x18>)
  40024e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400250:	f042 0240 	orr.w	r2, r2, #64	; 0x40
  400254:	671a      	str	r2, [r3, #112]	; 0x70
}

static inline void hri_pio_clear_ABCDSR_reg(const void *const hw, uint8_t index, hri_pio_abcdsr_reg_t mask)
{
	PIO_CRITICAL_SECTION_ENTER();
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400256:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400258:	f022 0240 	bic.w	r2, r2, #64	; 0x40
  40025c:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  40025e:	2240      	movs	r2, #64	; 0x40
  400260:	605a      	str	r2, [r3, #4]
  400262:	4770      	bx	lr
  400264:	400e0e00 	.word	0x400e0e00

00400268 <TIMER_0_CLOCK_init>:
}

static inline hri_pmc_pcsr1_reg_t hri_pmc_get_PCSR1_reg(const void *const hw, hri_pmc_pcsr1_reg_t mask)
{
	uint32_t tmp;
	tmp = ((Pmc *)hw)->PMC_PCSR1;
  400268:	4b10      	ldr	r3, [pc, #64]	; (4002ac <TIMER_0_CLOCK_init+0x44>)
  40026a:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
		if (!hri_pmc_get_PCSR0_reg(PMC, (1 << periph_id))) {
			hri_pmc_set_PCSR0_reg(PMC, (1 << periph_id));
		}
	} else if (periph_id < 64) {
		periph_id -= 32;
		if (!hri_pmc_get_PCSR1_reg(PMC, (1 << periph_id))) {
  40026e:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  400272:	d104      	bne.n	40027e <TIMER_0_CLOCK_init+0x16>
	((Pmc *)hw)->PMC_PCER1 = mask;
  400274:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  400278:	4b0c      	ldr	r3, [pc, #48]	; (4002ac <TIMER_0_CLOCK_init+0x44>)
  40027a:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	tmp = ((Pmc *)hw)->PMC_PCSR1;
  40027e:	4b0b      	ldr	r3, [pc, #44]	; (4002ac <TIMER_0_CLOCK_init+0x44>)
  400280:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
  400284:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  400288:	d104      	bne.n	400294 <TIMER_0_CLOCK_init+0x2c>
	((Pmc *)hw)->PMC_PCER1 = mask;
  40028a:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  40028e:	4b07      	ldr	r3, [pc, #28]	; (4002ac <TIMER_0_CLOCK_init+0x44>)
  400290:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	tmp = ((Pmc *)hw)->PMC_PCSR1;
  400294:	4b05      	ldr	r3, [pc, #20]	; (4002ac <TIMER_0_CLOCK_init+0x44>)
  400296:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
  40029a:	f413 3f00 	tst.w	r3, #131072	; 0x20000
  40029e:	d104      	bne.n	4002aa <TIMER_0_CLOCK_init+0x42>
	((Pmc *)hw)->PMC_PCER1 = mask;
  4002a0:	f44f 3200 	mov.w	r2, #131072	; 0x20000
  4002a4:	4b01      	ldr	r3, [pc, #4]	; (4002ac <TIMER_0_CLOCK_init+0x44>)
  4002a6:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  4002aa:	4770      	bx	lr
  4002ac:	400e0600 	.word	0x400e0600

004002b0 <delay_driver_init>:
	_pmc_enable_periph_clock(ID_TC2_CHANNEL1);
	_pmc_enable_periph_clock(ID_TC2_CHANNEL2);
}

void delay_driver_init(void)
{
  4002b0:	b508      	push	{r3, lr}
	delay_init(SysTick);
  4002b2:	4802      	ldr	r0, [pc, #8]	; (4002bc <delay_driver_init+0xc>)
  4002b4:	4b02      	ldr	r3, [pc, #8]	; (4002c0 <delay_driver_init+0x10>)
  4002b6:	4798      	blx	r3
  4002b8:	bd08      	pop	{r3, pc}
  4002ba:	bf00      	nop
  4002bc:	e000e010 	.word	0xe000e010
  4002c0:	0040036d 	.word	0x0040036d

004002c4 <USB_0_CLOCK_init>:
	tmp = ((Pmc *)hw)->PMC_PCSR1;
  4002c4:	4b05      	ldr	r3, [pc, #20]	; (4002dc <USB_0_CLOCK_init+0x18>)
  4002c6:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
  4002ca:	f013 0f04 	tst.w	r3, #4
  4002ce:	d103      	bne.n	4002d8 <USB_0_CLOCK_init+0x14>
	((Pmc *)hw)->PMC_PCER1 = mask;
  4002d0:	2204      	movs	r2, #4
  4002d2:	4b02      	ldr	r3, [pc, #8]	; (4002dc <USB_0_CLOCK_init+0x18>)
  4002d4:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  4002d8:	4770      	bx	lr
  4002da:	bf00      	nop
  4002dc:	400e0600 	.word	0x400e0600

004002e0 <USB_0_init>:
{
	_pmc_enable_periph_clock(ID_USBHS);
}

void USB_0_init(void)
{
  4002e0:	b508      	push	{r3, lr}
	USB_0_CLOCK_init();
  4002e2:	4b02      	ldr	r3, [pc, #8]	; (4002ec <USB_0_init+0xc>)
  4002e4:	4798      	blx	r3
	usb_d_init();
  4002e6:	4b02      	ldr	r3, [pc, #8]	; (4002f0 <USB_0_init+0x10>)
  4002e8:	4798      	blx	r3
  4002ea:	bd08      	pop	{r3, pc}
  4002ec:	004002c5 	.word	0x004002c5
  4002f0:	00400655 	.word	0x00400655

004002f4 <system_init>:
}

void system_init(void)
{
  4002f4:	b508      	push	{r3, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
  4002f6:	4b0d      	ldr	r3, [pc, #52]	; (40032c <system_init+0x38>)
  4002f8:	4798      	blx	r3
}

static inline void hri_wdt_set_MR_WDDIS_bit(const void *const hw)
{
	WDT_CRITICAL_SECTION_ENTER();
	((Wdt *)hw)->WDT_MR |= WDT_MR_WDDIS;
  4002fa:	4a0d      	ldr	r2, [pc, #52]	; (400330 <system_init+0x3c>)
  4002fc:	6853      	ldr	r3, [r2, #4]
  4002fe:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  400302:	6053      	str	r3, [r2, #4]
	((Pio *)hw)->PIO_ODR = mask;
  400304:	2208      	movs	r2, #8
  400306:	4b0b      	ldr	r3, [pc, #44]	; (400334 <system_init+0x40>)
  400308:	615a      	str	r2, [r3, #20]
	((Pio *)hw)->PIO_OER = mask;
  40030a:	2240      	movs	r2, #64	; 0x40
  40030c:	f5a3 7300 	sub.w	r3, r3, #512	; 0x200
  400310:	611a      	str	r2, [r3, #16]
	// TC channel 2: output - generating PWM waveform
	gpio_set_pin_direction(PB3_TRIG, GPIO_DIRECTION_IN);
	gpio_set_pin_direction(PA6_OUT, GPIO_DIRECTION_OUT);
	

	TIMER_0_CLOCK_init();
  400312:	4b09      	ldr	r3, [pc, #36]	; (400338 <system_init+0x44>)
  400314:	4798      	blx	r3
	TIMER_0_PORT_init();
  400316:	4b09      	ldr	r3, [pc, #36]	; (40033c <system_init+0x48>)
  400318:	4798      	blx	r3
	TIMER_0_init();
  40031a:	4b09      	ldr	r3, [pc, #36]	; (400340 <system_init+0x4c>)
  40031c:	4798      	blx	r3

	delay_driver_init();
  40031e:	4b09      	ldr	r3, [pc, #36]	; (400344 <system_init+0x50>)
  400320:	4798      	blx	r3

	USB_0_init();
  400322:	4b09      	ldr	r3, [pc, #36]	; (400348 <system_init+0x54>)
  400324:	4798      	blx	r3

	ext_irq_init();
  400326:	4b09      	ldr	r3, [pc, #36]	; (40034c <system_init+0x58>)
  400328:	4798      	blx	r3
  40032a:	bd08      	pop	{r3, pc}
  40032c:	004006c9 	.word	0x004006c9
  400330:	400e1850 	.word	0x400e1850
  400334:	400e1000 	.word	0x400e1000
  400338:	00400269 	.word	0x00400269
  40033c:	0040024d 	.word	0x0040024d
  400340:	00400a19 	.word	0x00400a19
  400344:	004002b1 	.word	0x004002b1
  400348:	004002e1 	.word	0x004002e1
  40034c:	004003c5 	.word	0x004003c5

00400350 <atomic_enter_critical>:
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
  400350:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
  400354:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  400356:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
  400358:	f3bf 8f5f 	dmb	sy
  40035c:	4770      	bx	lr

0040035e <atomic_leave_critical>:
  40035e:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
  400362:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
  400364:	f383 8810 	msr	PRIMASK, r3
  400368:	4770      	bx	lr
	...

0040036c <delay_init>:

/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
  40036c:	b508      	push	{r3, lr}
	_delay_init(hardware = hw);
  40036e:	4b02      	ldr	r3, [pc, #8]	; (400378 <delay_init+0xc>)
  400370:	6018      	str	r0, [r3, #0]
  400372:	4b02      	ldr	r3, [pc, #8]	; (40037c <delay_init+0x10>)
  400374:	4798      	blx	r3
  400376:	bd08      	pop	{r3, pc}
  400378:	2040001c 	.word	0x2040001c
  40037c:	00400a0d 	.word	0x00400a0d

00400380 <process_ext_irq>:
 * \brief Interrupt processing routine
 *
 * \param[in] pin The pin which triggered the interrupt
 */
static void process_ext_irq(const uint32_t pin)
{
  400380:	b538      	push	{r3, r4, r5, lr}
	uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;
  400382:	2501      	movs	r5, #1
  400384:	2400      	movs	r4, #0

	while (upper >= lower) {
  400386:	e007      	b.n	400398 <process_ext_irq+0x18>
		if (middle >= EXT_IRQ_AMOUNT) {
			return;
		}

		if (ext_irqs[middle].pin == pin) {
			if (ext_irqs[middle].cb) {
  400388:	4a0d      	ldr	r2, [pc, #52]	; (4003c0 <process_ext_irq+0x40>)
  40038a:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
  40038e:	b1b3      	cbz	r3, 4003be <process_ext_irq+0x3e>
				ext_irqs[middle].cb();
  400390:	4798      	blx	r3
  400392:	bd38      	pop	{r3, r4, r5, pc}
		}

		if (ext_irqs[middle].pin < pin) {
			lower = middle + 1;
		} else {
			upper = middle - 1;
  400394:	3901      	subs	r1, #1
  400396:	b2cd      	uxtb	r5, r1
	while (upper >= lower) {
  400398:	42ac      	cmp	r4, r5
  40039a:	d810      	bhi.n	4003be <process_ext_irq+0x3e>
		middle = (upper + lower) >> 1;
  40039c:	192b      	adds	r3, r5, r4
  40039e:	105b      	asrs	r3, r3, #1
		if (middle >= EXT_IRQ_AMOUNT) {
  4003a0:	f013 01ff 	ands.w	r1, r3, #255	; 0xff
  4003a4:	d10b      	bne.n	4003be <process_ext_irq+0x3e>
  4003a6:	b2db      	uxtb	r3, r3
		if (ext_irqs[middle].pin == pin) {
  4003a8:	4a05      	ldr	r2, [pc, #20]	; (4003c0 <process_ext_irq+0x40>)
  4003aa:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
  4003ae:	6852      	ldr	r2, [r2, #4]
  4003b0:	4282      	cmp	r2, r0
  4003b2:	d0e9      	beq.n	400388 <process_ext_irq+0x8>
		if (ext_irqs[middle].pin < pin) {
  4003b4:	4282      	cmp	r2, r0
  4003b6:	d2ed      	bcs.n	400394 <process_ext_irq+0x14>
			lower = middle + 1;
  4003b8:	3101      	adds	r1, #1
  4003ba:	b2cc      	uxtb	r4, r1
  4003bc:	e7ec      	b.n	400398 <process_ext_irq+0x18>
  4003be:	bd38      	pop	{r3, r4, r5, pc}
  4003c0:	20400020 	.word	0x20400020

004003c4 <ext_irq_init>:
{
  4003c4:	b508      	push	{r3, lr}
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
  4003c6:	2300      	movs	r3, #0
  4003c8:	b11b      	cbz	r3, 4003d2 <ext_irq_init+0xe>
	return _ext_irq_init(process_ext_irq);
  4003ca:	4808      	ldr	r0, [pc, #32]	; (4003ec <ext_irq_init+0x28>)
  4003cc:	4b08      	ldr	r3, [pc, #32]	; (4003f0 <ext_irq_init+0x2c>)
  4003ce:	4798      	blx	r3
}
  4003d0:	bd08      	pop	{r3, pc}
		ext_irqs[i].pin = 0xFFFFFFFF;
  4003d2:	4a08      	ldr	r2, [pc, #32]	; (4003f4 <ext_irq_init+0x30>)
  4003d4:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
  4003d8:	f04f 30ff 	mov.w	r0, #4294967295
  4003dc:	6048      	str	r0, [r1, #4]
		ext_irqs[i].cb  = NULL;
  4003de:	2100      	movs	r1, #0
  4003e0:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
  4003e4:	3301      	adds	r3, #1
  4003e6:	b29b      	uxth	r3, r3
  4003e8:	e7ee      	b.n	4003c8 <ext_irq_init+0x4>
  4003ea:	bf00      	nop
  4003ec:	00400381 	.word	0x00400381
  4003f0:	00400929 	.word	0x00400929
  4003f4:	20400020 	.word	0x20400020

004003f8 <_usb_d_find_ep>:
 * \retval <0 Not found (endpoint is not initialized).
 */
static int8_t _usb_d_find_ep(const uint8_t ep)
{
	int8_t i;
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
  4003f8:	2300      	movs	r3, #0
  4003fa:	2b03      	cmp	r3, #3
  4003fc:	dc21      	bgt.n	400442 <_usb_d_find_ep+0x4a>
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
  4003fe:	4a13      	ldr	r2, [pc, #76]	; (40044c <_usb_d_find_ep+0x54>)
  400400:	eb02 1243 	add.w	r2, r2, r3, lsl #5
  400404:	7851      	ldrb	r1, [r2, #1]
  400406:	4281      	cmp	r1, r0
  400408:	d01d      	beq.n	400446 <_usb_d_find_ep+0x4e>
{
  40040a:	b410      	push	{r4}
  40040c:	e009      	b.n	400422 <_usb_d_find_ep+0x2a>
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
  40040e:	3301      	adds	r3, #1
  400410:	b25b      	sxtb	r3, r3
  400412:	2b03      	cmp	r3, #3
  400414:	dc0f      	bgt.n	400436 <_usb_d_find_ep+0x3e>
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
  400416:	4a0d      	ldr	r2, [pc, #52]	; (40044c <_usb_d_find_ep+0x54>)
  400418:	eb02 1243 	add.w	r2, r2, r3, lsl #5
  40041c:	7851      	ldrb	r1, [r2, #1]
  40041e:	4281      	cmp	r1, r0
  400420:	d00b      	beq.n	40043a <_usb_d_find_ep+0x42>
			return i;
		}
		if (usb_d_inst.ep[i].xfer.hdr.type == USB_EP_XTYPE_CTRL
  400422:	015a      	lsls	r2, r3, #5
  400424:	4c09      	ldr	r4, [pc, #36]	; (40044c <_usb_d_find_ep+0x54>)
  400426:	5ca2      	ldrb	r2, [r4, r2]
  400428:	2a00      	cmp	r2, #0
  40042a:	d1f0      	bne.n	40040e <_usb_d_find_ep+0x16>
		    && (ep & USB_EP_N_MASK) == usb_d_inst.ep[i].xfer.hdr.ep) {
  40042c:	f000 020f 	and.w	r2, r0, #15
  400430:	428a      	cmp	r2, r1
  400432:	d1ec      	bne.n	40040e <_usb_d_find_ep+0x16>
  400434:	e001      	b.n	40043a <_usb_d_find_ep+0x42>
			return i;
		}
	}
	return -1;
  400436:	f04f 33ff 	mov.w	r3, #4294967295
}
  40043a:	4618      	mov	r0, r3
  40043c:	f85d 4b04 	ldr.w	r4, [sp], #4
  400440:	4770      	bx	lr
	return -1;
  400442:	f04f 33ff 	mov.w	r3, #4294967295
}
  400446:	4618      	mov	r0, r3
  400448:	4770      	bx	lr
  40044a:	bf00      	nop
  40044c:	20400028 	.word	0x20400028

00400450 <usb_d_dummy_cb_false>:
{
	(void)unused0;
	(void)unused1;
	(void)unused2;
	return false;
}
  400450:	2000      	movs	r0, #0
  400452:	4770      	bx	lr

00400454 <usb_d_cb_trans_more>:
 * \brief Callback invoked when request more data
 * \param[in] ep Endpoint number with transfer direction on bit 8.
 * \param[in] transfered Number of bytes transfered.
 */
static bool usb_d_cb_trans_more(const uint8_t ep, const uint32_t transfered)
{
  400454:	b538      	push	{r3, r4, r5, lr}
  400456:	4604      	mov	r4, r0
  400458:	460d      	mov	r5, r1
	int8_t           ep_index = _usb_d_find_ep(ep);
  40045a:	4b09      	ldr	r3, [pc, #36]	; (400480 <usb_d_cb_trans_more+0x2c>)
  40045c:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ept->xfer.hdr.state == USB_EP_S_X_DATA) {
  40045e:	4b09      	ldr	r3, [pc, #36]	; (400484 <usb_d_cb_trans_more+0x30>)
  400460:	eb03 1340 	add.w	r3, r3, r0, lsl #5
  400464:	789b      	ldrb	r3, [r3, #2]
  400466:	2b03      	cmp	r3, #3
  400468:	d001      	beq.n	40046e <usb_d_cb_trans_more+0x1a>
		return ept->callbacks.more(ep, transfered);
	}
	return false;
  40046a:	2000      	movs	r0, #0
}
  40046c:	bd38      	pop	{r3, r4, r5, pc}
		return ept->callbacks.more(ep, transfered);
  40046e:	4b05      	ldr	r3, [pc, #20]	; (400484 <usb_d_cb_trans_more+0x30>)
  400470:	eb03 1040 	add.w	r0, r3, r0, lsl #5
  400474:	6983      	ldr	r3, [r0, #24]
  400476:	4629      	mov	r1, r5
  400478:	4620      	mov	r0, r4
  40047a:	4798      	blx	r3
  40047c:	bd38      	pop	{r3, r4, r5, pc}
  40047e:	bf00      	nop
  400480:	004003f9 	.word	0x004003f9
  400484:	20400028 	.word	0x20400028

00400488 <_usb_d_cb_trans_done>:

/**
 * Callback when USB transactions are finished.
 */
static void _usb_d_cb_trans_done(const uint8_t ep, const int32_t code, const uint32_t transferred)
{
  400488:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40048c:	b084      	sub	sp, #16
  40048e:	4607      	mov	r7, r0
  400490:	460d      	mov	r5, r1
  400492:	4690      	mov	r8, r2
	int8_t           ep_index = _usb_d_find_ep(ep);
  400494:	4b48      	ldr	r3, [pc, #288]	; (4005b8 <_usb_d_cb_trans_done+0x130>)
  400496:	4798      	blx	r3
  400498:	4604      	mov	r4, r0
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
  40049a:	4e48      	ldr	r6, [pc, #288]	; (4005bc <_usb_d_cb_trans_done+0x134>)
  40049c:	eb06 1640 	add.w	r6, r6, r0, lsl #5

	if (code == USB_TRANS_DONE) {
  4004a0:	2d00      	cmp	r5, #0
  4004a2:	d14f      	bne.n	400544 <_usb_d_cb_trans_done+0xbc>
		ept->xfer.hdr.status = USB_XFER_DONE;
  4004a4:	4a45      	ldr	r2, [pc, #276]	; (4005bc <_usb_d_cb_trans_done+0x134>)
  4004a6:	0143      	lsls	r3, r0, #5
  4004a8:	2000      	movs	r0, #0
  4004aa:	70f0      	strb	r0, [r6, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
  4004ac:	5cd3      	ldrb	r3, [r2, r3]
  4004ae:	b17b      	cbz	r3, 4004d0 <_usb_d_cb_trans_done+0x48>
			usb_d_ctrl_trans_done(ept);
			return;
		}
		ept->xfer.hdr.state = USB_EP_S_IDLE;
  4004b0:	4b42      	ldr	r3, [pc, #264]	; (4005bc <_usb_d_cb_trans_done+0x134>)
  4004b2:	eb03 1344 	add.w	r3, r3, r4, lsl #5
  4004b6:	2201      	movs	r2, #1
  4004b8:	709a      	strb	r2, [r3, #2]
	} else {
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
		ept->xfer.hdr.status = USB_XFER_ERROR;
	}

	ept->callbacks.xfer(ep, (enum usb_xfer_code)ept->xfer.hdr.status, (void *)transferred);
  4004ba:	4b40      	ldr	r3, [pc, #256]	; (4005bc <_usb_d_cb_trans_done+0x134>)
  4004bc:	eb03 1444 	add.w	r4, r3, r4, lsl #5
  4004c0:	69e3      	ldr	r3, [r4, #28]
  4004c2:	4642      	mov	r2, r8
  4004c4:	78e1      	ldrb	r1, [r4, #3]
  4004c6:	4638      	mov	r0, r7
  4004c8:	4798      	blx	r3
}
  4004ca:	b004      	add	sp, #16
  4004cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uint8_t state   = ept->xfer.hdr.state;
  4004d0:	78b3      	ldrb	r3, [r6, #2]
  4004d2:	f996 400c 	ldrsb.w	r4, [r6, #12]
	if (state == USB_EP_S_X_DATA) {
  4004d6:	2b03      	cmp	r3, #3
  4004d8:	d008      	beq.n	4004ec <_usb_d_cb_trans_done+0x64>
		ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DONE, ept->xfer.req);
  4004da:	69f3      	ldr	r3, [r6, #28]
  4004dc:	f106 020c 	add.w	r2, r6, #12
  4004e0:	2100      	movs	r1, #0
  4004e2:	7870      	ldrb	r0, [r6, #1]
  4004e4:	4798      	blx	r3
		ept->xfer.hdr.state = USB_EP_S_X_SETUP;
  4004e6:	2302      	movs	r3, #2
  4004e8:	70b3      	strb	r3, [r6, #2]
  4004ea:	e7ee      	b.n	4004ca <_usb_d_cb_trans_done+0x42>
		bool err = ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DATA, ept->xfer.req);
  4004ec:	69f3      	ldr	r3, [r6, #28]
  4004ee:	f106 020c 	add.w	r2, r6, #12
  4004f2:	2101      	movs	r1, #1
  4004f4:	7870      	ldrb	r0, [r6, #1]
  4004f6:	4798      	blx	r3
		if (err) {
  4004f8:	b170      	cbz	r0, 400518 <_usb_d_cb_trans_done+0x90>
			ept->xfer.hdr.state  = USB_EP_S_HALTED;
  4004fa:	2305      	movs	r3, #5
  4004fc:	70b3      	strb	r3, [r6, #2]
			ept->xfer.hdr.status = USB_XFER_HALT;
  4004fe:	2302      	movs	r3, #2
  400500:	70f3      	strb	r3, [r6, #3]
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
  400502:	2c00      	cmp	r4, #0
  400504:	db06      	blt.n	400514 <_usb_d_cb_trans_done+0x8c>
  400506:	7870      	ldrb	r0, [r6, #1]
  400508:	f040 0080 	orr.w	r0, r0, #128	; 0x80
  40050c:	2101      	movs	r1, #1
  40050e:	4b2c      	ldr	r3, [pc, #176]	; (4005c0 <_usb_d_cb_trans_done+0x138>)
  400510:	4798      	blx	r3
  400512:	e7da      	b.n	4004ca <_usb_d_cb_trans_done+0x42>
  400514:	7870      	ldrb	r0, [r6, #1]
  400516:	e7f9      	b.n	40050c <_usb_d_cb_trans_done+0x84>
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
  400518:	2304      	movs	r3, #4
  40051a:	70b3      	strb	r3, [r6, #2]
			_usb_d_trans(ept->xfer.hdr.ep, !req_dir, NULL, 0, 1);
  40051c:	7873      	ldrb	r3, [r6, #1]
	struct usb_d_transfer trans
  40051e:	2200      	movs	r2, #0
  400520:	9201      	str	r2, [sp, #4]
  400522:	9202      	str	r2, [sp, #8]
  400524:	4294      	cmp	r4, r2
  400526:	db0a      	blt.n	40053e <_usb_d_cb_trans_done+0xb6>
  400528:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  40052c:	f88d 300c 	strb.w	r3, [sp, #12]
  400530:	2301      	movs	r3, #1
  400532:	f88d 300d 	strb.w	r3, [sp, #13]
	return _usb_d_dev_ep_trans(&trans);
  400536:	a801      	add	r0, sp, #4
  400538:	4b22      	ldr	r3, [pc, #136]	; (4005c4 <_usb_d_cb_trans_done+0x13c>)
  40053a:	4798      	blx	r3
  40053c:	e7c5      	b.n	4004ca <_usb_d_cb_trans_done+0x42>
	struct usb_d_transfer trans
  40053e:	f003 030f 	and.w	r3, r3, #15
  400542:	e7f3      	b.n	40052c <_usb_d_cb_trans_done+0xa4>
	} else if (code == USB_TRANS_STALL) {
  400544:	2d01      	cmp	r5, #1
  400546:	d00a      	beq.n	40055e <_usb_d_cb_trans_done+0xd6>
	} else if (code == USB_TRANS_ABORT) {
  400548:	2d02      	cmp	r5, #2
  40054a:	d01c      	beq.n	400586 <_usb_d_cb_trans_done+0xfe>
	} else if (code == USB_TRANS_RESET) {
  40054c:	2d03      	cmp	r5, #3
  40054e:	d02a      	beq.n	4005a6 <_usb_d_cb_trans_done+0x11e>
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
  400550:	4b1a      	ldr	r3, [pc, #104]	; (4005bc <_usb_d_cb_trans_done+0x134>)
  400552:	eb03 1340 	add.w	r3, r3, r0, lsl #5
  400556:	2206      	movs	r2, #6
  400558:	709a      	strb	r2, [r3, #2]
		ept->xfer.hdr.status = USB_XFER_ERROR;
  40055a:	70da      	strb	r2, [r3, #3]
  40055c:	e7ad      	b.n	4004ba <_usb_d_cb_trans_done+0x32>
		ept->xfer.hdr.status = USB_XFER_HALT;
  40055e:	4a17      	ldr	r2, [pc, #92]	; (4005bc <_usb_d_cb_trans_done+0x134>)
  400560:	0143      	lsls	r3, r0, #5
  400562:	18d1      	adds	r1, r2, r3
  400564:	2002      	movs	r0, #2
  400566:	70c8      	strb	r0, [r1, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
  400568:	5cd3      	ldrb	r3, [r2, r3]
  40056a:	b12b      	cbz	r3, 400578 <_usb_d_cb_trans_done+0xf0>
			ept->xfer.hdr.state = USB_EP_S_HALTED;
  40056c:	4b13      	ldr	r3, [pc, #76]	; (4005bc <_usb_d_cb_trans_done+0x134>)
  40056e:	eb03 1344 	add.w	r3, r3, r4, lsl #5
  400572:	2205      	movs	r2, #5
  400574:	709a      	strb	r2, [r3, #2]
  400576:	e7a0      	b.n	4004ba <_usb_d_cb_trans_done+0x32>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
  400578:	460b      	mov	r3, r1
  40057a:	7098      	strb	r0, [r3, #2]
			_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
  40057c:	2100      	movs	r1, #0
  40057e:	4638      	mov	r0, r7
  400580:	4b0f      	ldr	r3, [pc, #60]	; (4005c0 <_usb_d_cb_trans_done+0x138>)
  400582:	4798      	blx	r3
  400584:	e799      	b.n	4004ba <_usb_d_cb_trans_done+0x32>
		ept->xfer.hdr.status = USB_XFER_ABORT;
  400586:	4a0d      	ldr	r2, [pc, #52]	; (4005bc <_usb_d_cb_trans_done+0x134>)
  400588:	0143      	lsls	r3, r0, #5
  40058a:	18d1      	adds	r1, r2, r3
  40058c:	2004      	movs	r0, #4
  40058e:	70c8      	strb	r0, [r1, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
  400590:	5cd3      	ldrb	r3, [r2, r3]
  400592:	b12b      	cbz	r3, 4005a0 <_usb_d_cb_trans_done+0x118>
		ept->xfer.hdr.state = USB_EP_S_IDLE;
  400594:	4b09      	ldr	r3, [pc, #36]	; (4005bc <_usb_d_cb_trans_done+0x134>)
  400596:	eb03 1344 	add.w	r3, r3, r4, lsl #5
  40059a:	2201      	movs	r2, #1
  40059c:	709a      	strb	r2, [r3, #2]
  40059e:	e78c      	b.n	4004ba <_usb_d_cb_trans_done+0x32>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
  4005a0:	2302      	movs	r3, #2
  4005a2:	708b      	strb	r3, [r1, #2]
			return;
  4005a4:	e791      	b.n	4004ca <_usb_d_cb_trans_done+0x42>
		ept->xfer.hdr.state  = USB_EP_S_DISABLED;
  4005a6:	4b05      	ldr	r3, [pc, #20]	; (4005bc <_usb_d_cb_trans_done+0x134>)
  4005a8:	eb03 1340 	add.w	r3, r3, r0, lsl #5
  4005ac:	2200      	movs	r2, #0
  4005ae:	709a      	strb	r2, [r3, #2]
		ept->xfer.hdr.status = USB_XFER_RESET;
  4005b0:	2205      	movs	r2, #5
  4005b2:	70da      	strb	r2, [r3, #3]
  4005b4:	e781      	b.n	4004ba <_usb_d_cb_trans_done+0x32>
  4005b6:	bf00      	nop
  4005b8:	004003f9 	.word	0x004003f9
  4005bc:	20400028 	.word	0x20400028
  4005c0:	0040111d 	.word	0x0040111d
  4005c4:	004012d5 	.word	0x004012d5

004005c8 <usb_d_cb_trans_setup>:
{
  4005c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4005cc:	4605      	mov	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
  4005ce:	4b1d      	ldr	r3, [pc, #116]	; (400644 <usb_d_cb_trans_setup+0x7c>)
  4005d0:	4798      	blx	r3
  4005d2:	4606      	mov	r6, r0
	uint8_t *        req      = ept->xfer.req;
  4005d4:	0144      	lsls	r4, r0, #5
  4005d6:	f104 0308 	add.w	r3, r4, #8
  4005da:	4c1b      	ldr	r4, [pc, #108]	; (400648 <usb_d_cb_trans_setup+0x80>)
  4005dc:	441c      	add	r4, r3
  4005de:	3404      	adds	r4, #4
	uint8_t n = _usb_d_dev_ep_read_req(ep, req);
  4005e0:	4621      	mov	r1, r4
  4005e2:	4628      	mov	r0, r5
  4005e4:	4b19      	ldr	r3, [pc, #100]	; (40064c <usb_d_cb_trans_setup+0x84>)
  4005e6:	4798      	blx	r3
  4005e8:	b2c0      	uxtb	r0, r0
	if (n != 8) {
  4005ea:	2808      	cmp	r0, #8
  4005ec:	d009      	beq.n	400602 <usb_d_cb_trans_setup+0x3a>
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
  4005ee:	2101      	movs	r1, #1
  4005f0:	4628      	mov	r0, r5
  4005f2:	4c17      	ldr	r4, [pc, #92]	; (400650 <usb_d_cb_trans_setup+0x88>)
  4005f4:	47a0      	blx	r4
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
  4005f6:	2101      	movs	r1, #1
  4005f8:	f045 0080 	orr.w	r0, r5, #128	; 0x80
  4005fc:	47a0      	blx	r4
		return;
  4005fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
  400602:	2100      	movs	r1, #0
  400604:	4628      	mov	r0, r5
  400606:	4f12      	ldr	r7, [pc, #72]	; (400650 <usb_d_cb_trans_setup+0x88>)
  400608:	47b8      	blx	r7
	_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_CLR);
  40060a:	f045 0880 	orr.w	r8, r5, #128	; 0x80
  40060e:	2100      	movs	r1, #0
  400610:	4640      	mov	r0, r8
  400612:	47b8      	blx	r7
	ept->xfer.hdr.state = USB_EP_S_IDLE;
  400614:	4b0c      	ldr	r3, [pc, #48]	; (400648 <usb_d_cb_trans_setup+0x80>)
  400616:	eb03 1346 	add.w	r3, r3, r6, lsl #5
  40061a:	2201      	movs	r2, #1
  40061c:	709a      	strb	r2, [r3, #2]
	if (!ept->callbacks.req(ep, req)) {
  40061e:	695b      	ldr	r3, [r3, #20]
  400620:	4621      	mov	r1, r4
  400622:	4628      	mov	r0, r5
  400624:	4798      	blx	r3
  400626:	b108      	cbz	r0, 40062c <usb_d_cb_trans_setup+0x64>
  400628:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		ept->xfer.hdr.state = USB_EP_S_HALTED;
  40062c:	4b06      	ldr	r3, [pc, #24]	; (400648 <usb_d_cb_trans_setup+0x80>)
  40062e:	eb03 1646 	add.w	r6, r3, r6, lsl #5
  400632:	2305      	movs	r3, #5
  400634:	70b3      	strb	r3, [r6, #2]
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
  400636:	2101      	movs	r1, #1
  400638:	4628      	mov	r0, r5
  40063a:	47b8      	blx	r7
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
  40063c:	2101      	movs	r1, #1
  40063e:	4640      	mov	r0, r8
  400640:	47b8      	blx	r7
  400642:	e7f1      	b.n	400628 <usb_d_cb_trans_setup+0x60>
  400644:	004003f9 	.word	0x004003f9
  400648:	20400028 	.word	0x20400028
  40064c:	00401255 	.word	0x00401255
  400650:	0040111d 	.word	0x0040111d

00400654 <usb_d_init>:

int32_t usb_d_init(void)
{
  400654:	b510      	push	{r4, lr}
	int32_t rc = _usb_d_dev_init();
  400656:	4b12      	ldr	r3, [pc, #72]	; (4006a0 <usb_d_init+0x4c>)
  400658:	4798      	blx	r3
	uint8_t i;
	if (rc < 0) {
  40065a:	2800      	cmp	r0, #0
  40065c:	db1e      	blt.n	40069c <usb_d_init+0x48>
		return rc;
	}
	memset(usb_d_inst.ep, 0x00, sizeof(struct usb_d_ep) * CONF_USB_D_NUM_EP_SP);
  40065e:	2280      	movs	r2, #128	; 0x80
  400660:	2100      	movs	r1, #0
  400662:	4810      	ldr	r0, [pc, #64]	; (4006a4 <usb_d_init+0x50>)
  400664:	4b10      	ldr	r3, [pc, #64]	; (4006a8 <usb_d_init+0x54>)
  400666:	4798      	blx	r3
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
  400668:	2200      	movs	r2, #0
  40066a:	e00a      	b.n	400682 <usb_d_init+0x2e>
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
  40066c:	4b0d      	ldr	r3, [pc, #52]	; (4006a4 <usb_d_init+0x50>)
  40066e:	eb03 1342 	add.w	r3, r3, r2, lsl #5
  400672:	21ff      	movs	r1, #255	; 0xff
  400674:	7059      	strb	r1, [r3, #1]
		usb_d_inst.ep[i].callbacks.req  = (usb_d_ep_cb_setup_t)usb_d_dummy_cb_false;
  400676:	490d      	ldr	r1, [pc, #52]	; (4006ac <usb_d_init+0x58>)
  400678:	6159      	str	r1, [r3, #20]
		usb_d_inst.ep[i].callbacks.more = (usb_d_ep_cb_more_t)usb_d_dummy_cb_false;
  40067a:	6199      	str	r1, [r3, #24]
		usb_d_inst.ep[i].callbacks.xfer = (usb_d_ep_cb_xfer_t)usb_d_dummy_cb_false;
  40067c:	61d9      	str	r1, [r3, #28]
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
  40067e:	3201      	adds	r2, #1
  400680:	b2d2      	uxtb	r2, r2
  400682:	2a03      	cmp	r2, #3
  400684:	d9f2      	bls.n	40066c <usb_d_init+0x18>
	}
	/* Handles device driver endpoint callbacks to build transfer. */
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_SETUP, (FUNC_PTR)usb_d_cb_trans_setup);
  400686:	490a      	ldr	r1, [pc, #40]	; (4006b0 <usb_d_init+0x5c>)
  400688:	2000      	movs	r0, #0
  40068a:	4c0a      	ldr	r4, [pc, #40]	; (4006b4 <usb_d_init+0x60>)
  40068c:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_MORE, (FUNC_PTR)usb_d_cb_trans_more);
  40068e:	490a      	ldr	r1, [pc, #40]	; (4006b8 <usb_d_init+0x64>)
  400690:	2001      	movs	r0, #1
  400692:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_DONE, (FUNC_PTR)_usb_d_cb_trans_done);
  400694:	4909      	ldr	r1, [pc, #36]	; (4006bc <usb_d_init+0x68>)
  400696:	2002      	movs	r0, #2
  400698:	47a0      	blx	r4
	return ERR_NONE;
  40069a:	2000      	movs	r0, #0
}
  40069c:	bd10      	pop	{r4, pc}
  40069e:	bf00      	nop
  4006a0:	004010cd 	.word	0x004010cd
  4006a4:	20400028 	.word	0x20400028
  4006a8:	0040153b 	.word	0x0040153b
  4006ac:	00400451 	.word	0x00400451
  4006b0:	004005c9 	.word	0x004005c9
  4006b4:	00401445 	.word	0x00401445
  4006b8:	00400455 	.word	0x00400455
  4006bc:	00400489 	.word	0x00400489

004006c0 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
  4006c0:	b900      	cbnz	r0, 4006c4 <assert+0x4>
		__asm("BKPT #0");
  4006c2:	be00      	bkpt	0x0000
  4006c4:	4770      	bx	lr
	...

004006c8 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
  4006c8:	b500      	push	{lr}
  4006ca:	b083      	sub	sp, #12
/**
 * \brief Enable FPU
 */
static inline void _fpu_enable(void)
{
	CRITICAL_SECTION_ENTER()
  4006cc:	a801      	add	r0, sp, #4
  4006ce:	4b0e      	ldr	r3, [pc, #56]	; (400708 <_init_chip+0x40>)
  4006d0:	4798      	blx	r3
	/** Set bits 20-23 to enable CP10 and CP11 coprocessors */
	SCB->CPACR |= (0xFu << 20);
  4006d2:	4a0e      	ldr	r2, [pc, #56]	; (40070c <_init_chip+0x44>)
  4006d4:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
  4006d8:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  4006dc:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
  4006e0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  4006e4:	f3bf 8f6f 	isb	sy
	__DSB();
	__ISB();
	CRITICAL_SECTION_LEAVE()
  4006e8:	a801      	add	r0, sp, #4
  4006ea:	4b09      	ldr	r3, [pc, #36]	; (400710 <_init_chip+0x48>)
  4006ec:	4798      	blx	r3

static inline void hri_efc_write_EEFC_FMR_FWS_bf(const void *const hw, hri_efc_eefc_fmr_reg_t data)
{
	uint32_t tmp;
	EFC_CRITICAL_SECTION_ENTER();
	tmp = ((Efc *)hw)->EEFC_FMR;
  4006ee:	4a09      	ldr	r2, [pc, #36]	; (400714 <_init_chip+0x4c>)
  4006f0:	6813      	ldr	r3, [r2, #0]
	tmp &= ~EEFC_FMR_FWS_Msk;
  4006f2:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
	tmp |= EEFC_FMR_FWS(data);
  4006f6:	f443 63c0 	orr.w	r3, r3, #1536	; 0x600
	((Efc *)hw)->EEFC_FMR = tmp;
  4006fa:	6013      	str	r3, [r2, #0]
#if CONF_DMA_ENABLE
	_pmc_enable_periph_clock(ID_XDMAC);
	_dma_init();

#endif
	_pmc_init();
  4006fc:	4b06      	ldr	r3, [pc, #24]	; (400718 <_init_chip+0x50>)
  4006fe:	4798      	blx	r3
}
  400700:	b003      	add	sp, #12
  400702:	f85d fb04 	ldr.w	pc, [sp], #4
  400706:	bf00      	nop
  400708:	00400351 	.word	0x00400351
  40070c:	e000ed00 	.word	0xe000ed00
  400710:	0040035f 	.word	0x0040035f
  400714:	400e0c00 	.word	0x400e0c00
  400718:	004009e5 	.word	0x004009e5

0040071c <_ffs>:
};
#endif

/* Find the first bit set */
static int _ffs(uint32_t *v, uint8_t len)
{
  40071c:	b430      	push	{r4, r5}
	uint32_t i, j, bit;

	for (i = 0; i < len; i++) {
  40071e:	2500      	movs	r5, #0
  400720:	428d      	cmp	r5, r1
  400722:	d210      	bcs.n	400746 <_ffs+0x2a>
  400724:	2201      	movs	r2, #1
  400726:	2300      	movs	r3, #0
		bit = 1;
		for (j = 0; j < sizeof(uint32_t) * 8; j++) {
  400728:	2b1f      	cmp	r3, #31
  40072a:	d80a      	bhi.n	400742 <_ffs+0x26>
			if (v[i] & bit) {
  40072c:	f850 4025 	ldr.w	r4, [r0, r5, lsl #2]
  400730:	4222      	tst	r2, r4
  400732:	d102      	bne.n	40073a <_ffs+0x1e>
				return i * 32 + j;
			}
			bit <<= 1;
  400734:	0052      	lsls	r2, r2, #1
		for (j = 0; j < sizeof(uint32_t) * 8; j++) {
  400736:	3301      	adds	r3, #1
  400738:	e7f6      	b.n	400728 <_ffs+0xc>
				return i * 32 + j;
  40073a:	eb03 1045 	add.w	r0, r3, r5, lsl #5
		}
	}

	return -1;
}
  40073e:	bc30      	pop	{r4, r5}
  400740:	4770      	bx	lr
	for (i = 0; i < len; i++) {
  400742:	3501      	adds	r5, #1
  400744:	e7ec      	b.n	400720 <_ffs+0x4>
	return -1;
  400746:	f04f 30ff 	mov.w	r0, #4294967295
  40074a:	e7f8      	b.n	40073e <_ffs+0x22>

0040074c <_ext_irq_handler>:

/**
 * \brief External interrupt handler
 */
static void _ext_irq_handler(void)
{
  40074c:	b510      	push	{r4, lr}
  40074e:	b086      	sub	sp, #24
	uint32_t flag_total = 0, flags[5] = {
  400750:	2300      	movs	r3, #0
  400752:	9301      	str	r3, [sp, #4]
  400754:	9302      	str	r3, [sp, #8]
  400756:	9303      	str	r3, [sp, #12]
  400758:	9304      	str	r3, [sp, #16]
  40075a:	9305      	str	r3, [sp, #20]
	                             0,
	                         };
	int pos;

	ASSERT(callback);
  40075c:	4b1b      	ldr	r3, [pc, #108]	; (4007cc <_ext_irq_handler+0x80>)
  40075e:	6818      	ldr	r0, [r3, #0]
  400760:	22f8      	movs	r2, #248	; 0xf8
  400762:	491b      	ldr	r1, [pc, #108]	; (4007d0 <_ext_irq_handler+0x84>)
  400764:	3000      	adds	r0, #0
  400766:	bf18      	it	ne
  400768:	2001      	movne	r0, #1
  40076a:	4b1a      	ldr	r3, [pc, #104]	; (4007d4 <_ext_irq_handler+0x88>)
  40076c:	4798      	blx	r3
	return ((Pio *)hw)->PIO_ISR;
  40076e:	4a1a      	ldr	r2, [pc, #104]	; (4007d8 <_ext_irq_handler+0x8c>)
  400770:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  400772:	6c92      	ldr	r2, [r2, #72]	; 0x48

#if CONF_EXTIRQ_0_ENABLE == 1 && defined(PIOA)
	flags[0] = hri_pio_read_ISR_reg(PIOA);
	flags[0] &= hri_pio_read_IMR_reg(PIOA);
  400774:	4013      	ands	r3, r2
  400776:	9301      	str	r3, [sp, #4]
	flags[4] = hri_pio_read_ISR_reg(PIOE);
	flags[4] &= hri_pio_read_IMR_reg(PIOE);
	flag_total |= flags[4];
#endif

	while (flag_total) {
  400778:	e01f      	b.n	4007ba <_ext_irq_handler+0x6e>
		pos = _ffs(flags, 5);
		while (-1 != pos) {
			callback(pos);
  40077a:	4b14      	ldr	r3, [pc, #80]	; (4007cc <_ext_irq_handler+0x80>)
  40077c:	681b      	ldr	r3, [r3, #0]
  40077e:	4620      	mov	r0, r4
  400780:	4798      	blx	r3

			flags[pos >> 5] &= ~(1 << (pos & 31));
  400782:	1163      	asrs	r3, r4, #5
  400784:	f004 041f 	and.w	r4, r4, #31
  400788:	2201      	movs	r2, #1
  40078a:	fa02 f404 	lsl.w	r4, r2, r4
  40078e:	aa06      	add	r2, sp, #24
  400790:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400794:	f853 2c14 	ldr.w	r2, [r3, #-20]
  400798:	ea22 0204 	bic.w	r2, r2, r4
  40079c:	f843 2c14 	str.w	r2, [r3, #-20]
			pos = _ffs(flags, 5);
  4007a0:	2105      	movs	r1, #5
  4007a2:	a801      	add	r0, sp, #4
  4007a4:	4b0d      	ldr	r3, [pc, #52]	; (4007dc <_ext_irq_handler+0x90>)
  4007a6:	4798      	blx	r3
  4007a8:	4604      	mov	r4, r0
		while (-1 != pos) {
  4007aa:	f1b4 3fff 	cmp.w	r4, #4294967295
  4007ae:	d1e4      	bne.n	40077a <_ext_irq_handler+0x2e>
	return ((Pio *)hw)->PIO_ISR;
  4007b0:	4a09      	ldr	r2, [pc, #36]	; (4007d8 <_ext_irq_handler+0x8c>)
  4007b2:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  4007b4:	6c93      	ldr	r3, [r2, #72]	; 0x48
		}
		flag_total = 0;

#if CONF_EXTIRQ_0_ENABLE == 1 && defined(PIOA)
		flags[0] = hri_pio_read_ISR_reg(PIOA);
		flags[0] &= hri_pio_read_IMR_reg(PIOA);
  4007b6:	400b      	ands	r3, r1
  4007b8:	9301      	str	r3, [sp, #4]
	while (flag_total) {
  4007ba:	b12b      	cbz	r3, 4007c8 <_ext_irq_handler+0x7c>
		pos = _ffs(flags, 5);
  4007bc:	2105      	movs	r1, #5
  4007be:	a801      	add	r0, sp, #4
  4007c0:	4b06      	ldr	r3, [pc, #24]	; (4007dc <_ext_irq_handler+0x90>)
  4007c2:	4798      	blx	r3
  4007c4:	4604      	mov	r4, r0
		while (-1 != pos) {
  4007c6:	e7f0      	b.n	4007aa <_ext_irq_handler+0x5e>
		flags[4] = hri_pio_read_ISR_reg(PIOE);
		flags[4] &= hri_pio_read_IMR_reg(PIOE);
		flag_total |= flags[4];
#endif
	}
}
  4007c8:	b006      	add	sp, #24
  4007ca:	bd10      	pop	{r4, pc}
  4007cc:	204000a8 	.word	0x204000a8
  4007d0:	00401570 	.word	0x00401570
  4007d4:	004006c1 	.word	0x004006c1
  4007d8:	400e0e00 	.word	0x400e0e00
  4007dc:	0040071d 	.word	0x0040071d

004007e0 <_pio_get_hardware_index>:
{
  4007e0:	b510      	push	{r4, lr}
	ASSERT(hw);
  4007e2:	4604      	mov	r4, r0
  4007e4:	22d2      	movs	r2, #210	; 0xd2
  4007e6:	4905      	ldr	r1, [pc, #20]	; (4007fc <_pio_get_hardware_index+0x1c>)
  4007e8:	3000      	adds	r0, #0
  4007ea:	bf18      	it	ne
  4007ec:	2001      	movne	r0, #1
  4007ee:	4b04      	ldr	r3, [pc, #16]	; (400800 <_pio_get_hardware_index+0x20>)
  4007f0:	4798      	blx	r3
	return ((uint32_t)hw - (uint32_t)PIOA) >> 9;
  4007f2:	4804      	ldr	r0, [pc, #16]	; (400804 <_pio_get_hardware_index+0x24>)
  4007f4:	4420      	add	r0, r4
}
  4007f6:	f3c0 2047 	ubfx	r0, r0, #9, #8
  4007fa:	bd10      	pop	{r4, pc}
  4007fc:	00401570 	.word	0x00401570
  400800:	004006c1 	.word	0x004006c1
  400804:	bff1f200 	.word	0xbff1f200

00400808 <_pio_get_index>:
{
  400808:	b510      	push	{r4, lr}
	ASSERT(hw);
  40080a:	4604      	mov	r4, r0
  40080c:	22e0      	movs	r2, #224	; 0xe0
  40080e:	490d      	ldr	r1, [pc, #52]	; (400844 <_pio_get_index+0x3c>)
  400810:	3000      	adds	r0, #0
  400812:	bf18      	it	ne
  400814:	2001      	movne	r0, #1
  400816:	4b0c      	ldr	r3, [pc, #48]	; (400848 <_pio_get_index+0x40>)
  400818:	4798      	blx	r3
	uint8_t offset = _pio_get_hardware_index(hw);
  40081a:	4620      	mov	r0, r4
  40081c:	4b0b      	ldr	r3, [pc, #44]	; (40084c <_pio_get_index+0x44>)
  40081e:	4798      	blx	r3
	for (i = 0; i < ARRAY_SIZE(_ext_irq); i++) {
  400820:	2300      	movs	r3, #0
  400822:	b113      	cbz	r3, 40082a <_pio_get_index+0x22>
	return ERR_INVALID_DATA;
  400824:	f04f 30ff 	mov.w	r0, #4294967295
}
  400828:	bd10      	pop	{r4, pc}
		if (_ext_irq[i].number == offset) {
  40082a:	ebc3 01c3 	rsb	r1, r3, r3, lsl #3
  40082e:	008a      	lsls	r2, r1, #2
  400830:	4907      	ldr	r1, [pc, #28]	; (400850 <_pio_get_index+0x48>)
  400832:	5c8a      	ldrb	r2, [r1, r2]
  400834:	4290      	cmp	r0, r2
  400836:	d002      	beq.n	40083e <_pio_get_index+0x36>
	for (i = 0; i < ARRAY_SIZE(_ext_irq); i++) {
  400838:	3301      	adds	r3, #1
  40083a:	b2db      	uxtb	r3, r3
  40083c:	e7f1      	b.n	400822 <_pio_get_index+0x1a>
			return i;
  40083e:	b258      	sxtb	r0, r3
  400840:	bd10      	pop	{r4, pc}
  400842:	bf00      	nop
  400844:	00401570 	.word	0x00401570
  400848:	004006c1 	.word	0x004006c1
  40084c:	004007e1 	.word	0x004007e1
  400850:	0040154c 	.word	0x0040154c

00400854 <_pio_init>:
 * \return The status of instance initial
 * \retval ERR_NONE Initial status OK
 * \retval ERR_DENIED No need to initial
 */
static int32_t _pio_init(void *const hw)
{
  400854:	b538      	push	{r3, r4, r5, lr}
	int8_t i;

	ASSERT(hw);
  400856:	4604      	mov	r4, r0
  400858:	f44f 72aa 	mov.w	r2, #340	; 0x154
  40085c:	4929      	ldr	r1, [pc, #164]	; (400904 <_pio_init+0xb0>)
  40085e:	3000      	adds	r0, #0
  400860:	bf18      	it	ne
  400862:	2001      	movne	r0, #1
  400864:	4b28      	ldr	r3, [pc, #160]	; (400908 <_pio_init+0xb4>)
  400866:	4798      	blx	r3

	i = _pio_get_index(hw);
  400868:	4620      	mov	r0, r4
  40086a:	4b28      	ldr	r3, [pc, #160]	; (40090c <_pio_init+0xb8>)
  40086c:	4798      	blx	r3
	if (i < 0) {
  40086e:	2800      	cmp	r0, #0
  400870:	db43      	blt.n	4008fa <_pio_init+0xa6>
		return ERR_DENIED;
	}

	hri_pio_set_AIMMR_reg(hw, _ext_irq[i].add_irq_enable);
  400872:	4d27      	ldr	r5, [pc, #156]	; (400910 <_pio_init+0xbc>)
  400874:	00c2      	lsls	r2, r0, #3
  400876:	1a11      	subs	r1, r2, r0
  400878:	008b      	lsls	r3, r1, #2
  40087a:	442b      	add	r3, r5
  40087c:	6899      	ldr	r1, [r3, #8]
	((Pio *)hw)->PIO_AIMER = mask;
  40087e:	f8c4 10b0 	str.w	r1, [r4, #176]	; 0xb0
	hri_pio_clear_ELSR_reg(hw, _ext_irq[i].esr);
  400882:	68d9      	ldr	r1, [r3, #12]
	((Pio *)hw)->PIO_ESR = mask;
  400884:	f8c4 10c0 	str.w	r1, [r4, #192]	; 0xc0
	hri_pio_set_ELSR_reg(hw, _ext_irq[i].lsr);
  400888:	691b      	ldr	r3, [r3, #16]
	((Pio *)hw)->PIO_LSR = mask;
  40088a:	f8c4 30c4 	str.w	r3, [r4, #196]	; 0xc4
	((Pio *)hw)->PIO_FELLSR = mask;
  40088e:	2300      	movs	r3, #0
  400890:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
	hri_pio_clear_FRLHSR_reg(hw, _ext_irq[i].fellsr);
	hri_pio_set_FRLHSR_reg(hw, _ext_irq[i].rehlsr);
  400894:	1a10      	subs	r0, r2, r0
  400896:	0083      	lsls	r3, r0, #2
  400898:	442b      	add	r3, r5
  40089a:	695b      	ldr	r3, [r3, #20]
	((Pio *)hw)->PIO_REHLSR = mask;
  40089c:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4

	i = _pio_irq_n[_pio_get_hardware_index(hw)];
  4008a0:	4620      	mov	r0, r4
  4008a2:	4b1c      	ldr	r3, [pc, #112]	; (400914 <_pio_init+0xc0>)
  4008a4:	4798      	blx	r3
  4008a6:	4428      	add	r0, r5
  4008a8:	f990 301c 	ldrsb.w	r3, [r0, #28]
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  4008ac:	2b00      	cmp	r3, #0
  4008ae:	db0c      	blt.n	4008ca <_pio_init+0x76>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  4008b0:	095a      	lsrs	r2, r3, #5
  4008b2:	f003 001f 	and.w	r0, r3, #31
  4008b6:	2101      	movs	r1, #1
  4008b8:	4081      	lsls	r1, r0
  4008ba:	3220      	adds	r2, #32
  4008bc:	4816      	ldr	r0, [pc, #88]	; (400918 <_pio_init+0xc4>)
  4008be:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
  4008c2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  4008c6:	f3bf 8f6f 	isb	sy
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  4008ca:	2b00      	cmp	r3, #0
  4008cc:	db08      	blt.n	4008e0 <_pio_init+0x8c>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  4008ce:	095a      	lsrs	r2, r3, #5
  4008d0:	f003 001f 	and.w	r0, r3, #31
  4008d4:	2101      	movs	r1, #1
  4008d6:	4081      	lsls	r1, r0
  4008d8:	3260      	adds	r2, #96	; 0x60
  4008da:	480f      	ldr	r0, [pc, #60]	; (400918 <_pio_init+0xc4>)
  4008dc:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
  if ((int32_t)(IRQn) >= 0)
  4008e0:	2b00      	cmp	r3, #0
  4008e2:	db0d      	blt.n	400900 <_pio_init+0xac>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  4008e4:	0959      	lsrs	r1, r3, #5
  4008e6:	f003 031f 	and.w	r3, r3, #31
  4008ea:	2201      	movs	r2, #1
  4008ec:	fa02 f303 	lsl.w	r3, r2, r3
  4008f0:	4a09      	ldr	r2, [pc, #36]	; (400918 <_pio_init+0xc4>)
  4008f2:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
	NVIC_DisableIRQ((IRQn_Type)i);
	NVIC_ClearPendingIRQ((IRQn_Type)i);
	NVIC_EnableIRQ((IRQn_Type)i);

	return ERR_NONE;
  4008f6:	2000      	movs	r0, #0
  4008f8:	bd38      	pop	{r3, r4, r5, pc}
		return ERR_DENIED;
  4008fa:	f06f 0010 	mvn.w	r0, #16
  4008fe:	bd38      	pop	{r3, r4, r5, pc}
	return ERR_NONE;
  400900:	2000      	movs	r0, #0
}
  400902:	bd38      	pop	{r3, r4, r5, pc}
  400904:	00401570 	.word	0x00401570
  400908:	004006c1 	.word	0x004006c1
  40090c:	00400809 	.word	0x00400809
  400910:	0040154c 	.word	0x0040154c
  400914:	004007e1 	.word	0x004007e1
  400918:	e000e100 	.word	0xe000e100

0040091c <PIOA_Handler>:
{
  40091c:	b508      	push	{r3, lr}
	_ext_irq_handler();
  40091e:	4b01      	ldr	r3, [pc, #4]	; (400924 <PIOA_Handler+0x8>)
  400920:	4798      	blx	r3
  400922:	bd08      	pop	{r3, pc}
  400924:	0040074d 	.word	0x0040074d

00400928 <_ext_irq_init>:

int32_t _ext_irq_init(void (*cb)(const uint32_t pin))
{
  400928:	b510      	push	{r4, lr}
  40092a:	4604      	mov	r4, r0

#if CONF_EXTIRQ_0_ENABLE == 1 && defined(PIOA)
	_pio_init(PIOA);
  40092c:	4803      	ldr	r0, [pc, #12]	; (40093c <_ext_irq_init+0x14>)
  40092e:	4b04      	ldr	r3, [pc, #16]	; (400940 <_ext_irq_init+0x18>)
  400930:	4798      	blx	r3

#if CONF_EXTIRQ_4_ENABLE == 1 && defined(PIOE)
	_pio_init(PIOE);
#endif

	callback = cb;
  400932:	4b04      	ldr	r3, [pc, #16]	; (400944 <_ext_irq_init+0x1c>)
  400934:	601c      	str	r4, [r3, #0]

	return ERR_NONE;
}
  400936:	2000      	movs	r0, #0
  400938:	bd10      	pop	{r4, pc}
  40093a:	bf00      	nop
  40093c:	400e0e00 	.word	0x400e0e00
  400940:	00400855 	.word	0x00400855
  400944:	204000a8 	.word	0x204000a8

00400948 <_pmc_init_sources>:
	PMC_CRITICAL_SECTION_LEAVE();
}

static inline hri_pmc_ckgr_mor_reg_t hri_pmc_read_CKGR_MOR_reg(const void *const hw)
{
	return ((Pmc *)hw)->CKGR_MOR;
  400948:	490e      	ldr	r1, [pc, #56]	; (400984 <_pmc_init_sources+0x3c>)
  40094a:	6a0a      	ldr	r2, [r1, #32]
	/* Enable Main XTAL oscillator */
	data = hri_pmc_read_CKGR_MOR_reg(PMC) & ~CKGR_MOR_MOSCXTEN;
	data |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY | CKGR_MOR_MOSCSEL;
	hri_pmc_write_CKGR_MOR_reg(PMC, data);
#else
	data = hri_pmc_read_CKGR_MOR_reg(PMC) & ~CKGR_MOR_MOSCXTBY;
  40094c:	f022 0202 	bic.w	r2, r2, #2
	data |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCXTST(CONF_XOSC20M_STARTUP_TIME);
  400950:	4b0d      	ldr	r3, [pc, #52]	; (400988 <_pmc_init_sources+0x40>)
  400952:	4313      	orrs	r3, r2
	((Pmc *)hw)->CKGR_MOR = data;
  400954:	620b      	str	r3, [r1, #32]
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MOSCXTS) > 0;
  400956:	4b0b      	ldr	r3, [pc, #44]	; (400984 <_pmc_init_sources+0x3c>)
  400958:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	hri_pmc_write_CKGR_MOR_reg(PMC, data);
	while (!hri_pmc_get_SR_MOSCXTS_bit(PMC)) {
  40095a:	f013 0f01 	tst.w	r3, #1
  40095e:	d0fa      	beq.n	400956 <_pmc_init_sources+0xe>
	((Pmc *)hw)->CKGR_MOR |= mask;
  400960:	4b08      	ldr	r3, [pc, #32]	; (400984 <_pmc_init_sources+0x3c>)
  400962:	6a19      	ldr	r1, [r3, #32]
  400964:	4a09      	ldr	r2, [pc, #36]	; (40098c <_pmc_init_sources+0x44>)
  400966:	430a      	orrs	r2, r1
  400968:	621a      	str	r2, [r3, #32]

static inline void hri_pmc_write_CKGR_PLLAR_MULA_bf(const void *const hw, hri_pmc_ckgr_pllar_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->CKGR_PLLAR;
  40096a:	6a99      	ldr	r1, [r3, #40]	; 0x28
	tmp &= ~CKGR_PLLAR_MULA_Msk;
  40096c:	4a08      	ldr	r2, [pc, #32]	; (400990 <_pmc_init_sources+0x48>)
  40096e:	400a      	ands	r2, r1
	tmp |= CKGR_PLLAR_MULA(data);
	((Pmc *)hw)->CKGR_PLLAR = tmp;
  400970:	629a      	str	r2, [r3, #40]	; 0x28
}

static inline void hri_pmc_write_CKGR_PLLAR_reg(const void *const hw, hri_pmc_ckgr_pllar_reg_t data)
{
	PMC_CRITICAL_SECTION_ENTER();
	((Pmc *)hw)->CKGR_PLLAR = data;
  400972:	4a08      	ldr	r2, [pc, #32]	; (400994 <_pmc_init_sources+0x4c>)
  400974:	629a      	str	r2, [r3, #40]	; 0x28
	return (((Pmc *)hw)->PMC_SR & PMC_SR_LOCKA) > 0;
  400976:	4b03      	ldr	r3, [pc, #12]	; (400984 <_pmc_init_sources+0x3c>)
  400978:	6e9b      	ldr	r3, [r3, #104]	; 0x68
#if (CONF_PLLACK_ENABLE == 1)
	data = CKGR_PLLAR_MULA(CONF_PLLACK_MUL - 1) | CKGR_PLLAR_DIVA(CONF_PLLACK_DIV) | CKGR_PLLAR_PLLACOUNT(PLL_COUNT);
	/* Stop PLL first */
	hri_pmc_write_CKGR_PLLAR_MULA_bf(PMC, 0);
	hri_pmc_write_CKGR_PLLAR_reg(PMC, (CKGR_PLLAR_ONE | data));
	while (!hri_pmc_get_SR_LOCKA_bit(PMC)) {
  40097a:	f013 0f02 	tst.w	r3, #2
  40097e:	d0fa      	beq.n	400976 <_pmc_init_sources+0x2e>
#if (CONF_CLK_CFDEN_ENABLE == 1)
	/* Enable main clock failure detection */
	hri_pmc_set_CKGR_MOR_CFDEN_bit(PMC);
#endif
#endif
}
  400980:	4770      	bx	lr
  400982:	bf00      	nop
  400984:	400e0600 	.word	0x400e0600
  400988:	00373e01 	.word	0x00373e01
  40098c:	01370000 	.word	0x01370000
  400990:	f800ffff 	.word	0xf800ffff
  400994:	20183f01 	.word	0x20183f01

00400998 <_pmc_init_master_clock>:

static inline void hri_pmc_write_MCKR_PRES_bf(const void *const hw, hri_pmc_mckr_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->PMC_MCKR;
  400998:	4a11      	ldr	r2, [pc, #68]	; (4009e0 <_pmc_init_master_clock+0x48>)
  40099a:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_PRES_Msk;
  40099c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
	tmp |= PMC_MCKR_PRES(data);
	((Pmc *)hw)->PMC_MCKR = tmp;
  4009a0:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  4009a2:	4b0f      	ldr	r3, [pc, #60]	; (4009e0 <_pmc_init_master_clock+0x48>)
  4009a4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
		/* Wait until master clock is ready */
	}
#elif ((CONF_CLK_GEN_MCKR_SRC == CLK_SRC_OPTION_PLLACK) || (CONF_CLK_GEN_MCKR_SRC == CLK_SRC_OPTION_UPLLCKDIV))
	hri_pmc_write_MCKR_PRES_bf(PMC, CONF_MCKR_PRESC);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  4009a6:	f013 0f08 	tst.w	r3, #8
  4009aa:	d0fa      	beq.n	4009a2 <_pmc_init_master_clock+0xa>

static inline void hri_pmc_write_MCKR_MDIV_bf(const void *const hw, hri_pmc_mckr_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->PMC_MCKR;
  4009ac:	4a0c      	ldr	r2, [pc, #48]	; (4009e0 <_pmc_init_master_clock+0x48>)
  4009ae:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_MDIV_Msk;
  4009b0:	f423 7340 	bic.w	r3, r3, #768	; 0x300
	tmp |= PMC_MCKR_MDIV(data);
  4009b4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	((Pmc *)hw)->PMC_MCKR = tmp;
  4009b8:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  4009ba:	4b09      	ldr	r3, [pc, #36]	; (4009e0 <_pmc_init_master_clock+0x48>)
  4009bc:	6e9b      	ldr	r3, [r3, #104]	; 0x68
		/* Wait until master clock is ready */
	}
	hri_pmc_write_MCKR_MDIV_bf(PMC, CONF_MCK_DIV);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  4009be:	f013 0f08 	tst.w	r3, #8
  4009c2:	d0fa      	beq.n	4009ba <_pmc_init_master_clock+0x22>
	tmp = ((Pmc *)hw)->PMC_MCKR;
  4009c4:	4a06      	ldr	r2, [pc, #24]	; (4009e0 <_pmc_init_master_clock+0x48>)
  4009c6:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_CSS_Msk;
  4009c8:	f023 0303 	bic.w	r3, r3, #3
	tmp |= PMC_MCKR_CSS(data);
  4009cc:	f043 0302 	orr.w	r3, r3, #2
	((Pmc *)hw)->PMC_MCKR = tmp;
  4009d0:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  4009d2:	4b03      	ldr	r3, [pc, #12]	; (4009e0 <_pmc_init_master_clock+0x48>)
  4009d4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
		/* Wait until master clock is ready */
	}
	hri_pmc_write_MCKR_CSS_bf(PMC, CONF_CLK_GEN_MCKR_SRC);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  4009d6:	f013 0f08 	tst.w	r3, #8
  4009da:	d0fa      	beq.n	4009d2 <_pmc_init_master_clock+0x3a>
		/* Wait until master clock is ready */
	}
#endif
#endif
}
  4009dc:	4770      	bx	lr
  4009de:	bf00      	nop
  4009e0:	400e0600 	.word	0x400e0600

004009e4 <_pmc_init>:
/**
 * \brief Initializes cortex M7 core clock
 *
 */
void _pmc_init(void)
{
  4009e4:	b508      	push	{r3, lr}
	_pmc_init_sources();
  4009e6:	4b02      	ldr	r3, [pc, #8]	; (4009f0 <_pmc_init+0xc>)
  4009e8:	4798      	blx	r3
	_pmc_init_master_clock();
  4009ea:	4b02      	ldr	r3, [pc, #8]	; (4009f4 <_pmc_init+0x10>)
  4009ec:	4798      	blx	r3
  4009ee:	bd08      	pop	{r3, pc}
  4009f0:	00400949 	.word	0x00400949
  4009f4:	00400999 	.word	0x00400999

004009f8 <_system_time_init>:
 * \brief Initialize system time module
 */
void _system_time_init(void *const hw)
{
	(void)hw;
	SysTick->LOAD = (0xFFFFFF << SysTick_LOAD_RELOAD_Pos);
  4009f8:	4b03      	ldr	r3, [pc, #12]	; (400a08 <_system_time_init+0x10>)
  4009fa:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
  4009fe:	605a      	str	r2, [r3, #4]
	SysTick->CTRL = (1 << SysTick_CTRL_ENABLE_Pos) | (CONF_SYSTICK_TICKINT << SysTick_CTRL_TICKINT_Pos)
  400a00:	2205      	movs	r2, #5
  400a02:	601a      	str	r2, [r3, #0]
  400a04:	4770      	bx	lr
  400a06:	bf00      	nop
  400a08:	e000e010 	.word	0xe000e010

00400a0c <_delay_init>:
}
/**
 * \brief Initialize delay functionality
 */
void _delay_init(void *const hw)
{
  400a0c:	b508      	push	{r3, lr}
	_system_time_init(hw);
  400a0e:	4b01      	ldr	r3, [pc, #4]	; (400a14 <_delay_init+0x8>)
  400a10:	4798      	blx	r3
  400a12:	bd08      	pop	{r3, pc}
  400a14:	004009f9 	.word	0x004009f9

00400a18 <TIMER_0_init>:
}

static inline void hri_tc_write_BCR_reg(const void *const hw, hri_tc_bcr_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->TC_BCR = data;
  400a18:	4b06      	ldr	r3, [pc, #24]	; (400a34 <TIMER_0_init+0x1c>)
  400a1a:	2201      	movs	r2, #1
  400a1c:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
	((Tc *)hw)->TcChannel[submodule_index].TC_CMR = data;
  400a20:	f44f 4216 	mov.w	r2, #38400	; 0x9600
  400a24:	605a      	str	r2, [r3, #4]
  400a26:	4a04      	ldr	r2, [pc, #16]	; (400a38 <TIMER_0_init+0x20>)
  400a28:	645a      	str	r2, [r3, #68]	; 0x44
  400a2a:	4a04      	ldr	r2, [pc, #16]	; (400a3c <TIMER_0_init+0x24>)
  400a2c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	                     TC_CHANNEL_2,
	                     6 << TC_CMR_TCCLKS_Pos | 2 << TC_CMR_WAVEFORM_WAVSEL_Pos | 1 << TC_CMR_WAVE_Pos
	                         | 3 << TC_CMR_WAVEFORM_BCPC_Pos);

	return 0;
}
  400a30:	2000      	movs	r0, #0
  400a32:	4770      	bx	lr
  400a34:	40014000 	.word	0x40014000
  400a38:	000c8403 	.word	0x000c8403
  400a3c:	0c00c006 	.word	0x0c00c006

00400a40 <start_timer>:

void start_timer(const void *hw, uint8_t channel)
{
	if (channel < TC_CHANNEL_COUNT) {
  400a40:	2902      	cmp	r1, #2
  400a42:	d802      	bhi.n	400a4a <start_timer+0xa>
	((Tc *)hw)->TcChannel[submodule_index].TC_CCR = data;
  400a44:	0189      	lsls	r1, r1, #6
  400a46:	2305      	movs	r3, #5
  400a48:	5043      	str	r3, [r0, r1]
  400a4a:	4770      	bx	lr

00400a4c <stop_timer>:
	}
}

void stop_timer(const void *hw, uint8_t channel)
{
	if (channel < TC_CHANNEL_COUNT) {
  400a4c:	2902      	cmp	r1, #2
  400a4e:	d802      	bhi.n	400a56 <stop_timer+0xa>
  400a50:	0189      	lsls	r1, r1, #6
  400a52:	2302      	movs	r3, #2
  400a54:	5043      	str	r3, [r0, r1]
  400a56:	4770      	bx	lr

00400a58 <_dummy_func_no_return>:

/**
 * \brief Dummy callback function
 */
static void _dummy_func_no_return(uint32_t unused0, uint32_t unused1)
{
  400a58:	4770      	bx	lr

00400a5a <_dummy_func_return_false>:
static bool _dummy_func_return_false(uint32_t unused0, uint32_t unused1)
{
	(void)unused0;
	(void)unused1;
	return false;
}
  400a5a:	2000      	movs	r0, #0
  400a5c:	4770      	bx	lr
	...

00400a60 <_usb_d_dev_handle_setup>:
 * \brief Handles setup received interrupt
 * \param[in] ept Pointer to endpoint information.
 */
static void _usb_d_dev_handle_setup(struct _usb_d_dev_ep *ept)
{
	uint8_t epn     = USB_EP_GET_N(ept->ep);
  400a60:	7c83      	ldrb	r3, [r0, #18]
  400a62:	f003 030f 	and.w	r3, r3, #15
	bool    is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
  400a66:	7cc2      	ldrb	r2, [r0, #19]
  400a68:	f002 0107 	and.w	r1, r2, #7

	if (!is_ctrl) {
  400a6c:	2901      	cmp	r1, #1
  400a6e:	d009      	beq.n	400a84 <_usb_d_dev_handle_setup+0x24>
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = mask;
}

static inline void hri_usbhs_write_DEVEPTICR_reg(const void *const hw, uint8_t index, hri_usbhs_deveptisr_reg_t data)
{
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  400a70:	4a17      	ldr	r2, [pc, #92]	; (400ad0 <_usb_d_dev_handle_setup+0x70>)
  400a72:	f103 0058 	add.w	r0, r3, #88	; 0x58
  400a76:	2104      	movs	r1, #4
  400a78:	f842 1020 	str.w	r1, [r2, r0, lsl #2]
}

static inline void hri_usbhs_write_DEVEPTIDR_reg(const void *const hw, uint8_t index, hri_usbhs_deveptidr_reg_t data)
{
	USBHS_CRITICAL_SECTION_ENTER();
	((Usbhs *)hw)->USBHS_DEVEPTIDR[index] = data;
  400a7c:	3388      	adds	r3, #136	; 0x88
  400a7e:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
  400a82:	4770      	bx	lr
{
  400a84:	b510      	push	{r4, lr}

	/* Control transfer:
	 * SETUP transaction will terminate IN/OUT transaction,
	 * and start new transaction with received SETUP packet.
	 */
	if (_usb_d_dev_ep_is_busy(ept)) {
  400a86:	f012 0f40 	tst.w	r2, #64	; 0x40
  400a8a:	d00e      	beq.n	400aaa <_usb_d_dev_handle_setup+0x4a>
		ept->flags.bits.is_busy = 0;
  400a8c:	7cc2      	ldrb	r2, [r0, #19]
  400a8e:	f36f 1286 	bfc	r2, #6, #1
  400a92:	74c2      	strb	r2, [r0, #19]
	((Usbhs *)hw)->USBHS_DEVEPTIFR[index] = data;
  400a94:	490e      	ldr	r1, [pc, #56]	; (400ad0 <_usb_d_dev_handle_setup+0x70>)
  400a96:	f103 0264 	add.w	r2, r3, #100	; 0x64
  400a9a:	2401      	movs	r4, #1
  400a9c:	f841 4022 	str.w	r4, [r1, r2, lsl #2]
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  400aa0:	f103 0258 	add.w	r2, r3, #88	; 0x58
  400aa4:	2402      	movs	r4, #2
  400aa6:	f841 4022 	str.w	r4, [r1, r2, lsl #2]
		/* Stop transfer on either direction. */
		_usbd_ep_set_in_rdy(epn, false);
		_usbd_ep_set_out_rdy(epn, false);
	}

	ept->flags.bits.is_stalled = 0;
  400aaa:	7cc2      	ldrb	r2, [r0, #19]
  400aac:	f36f 02c3 	bfc	r2, #3, #1
  400ab0:	74c2      	strb	r2, [r0, #19]
  400ab2:	4a07      	ldr	r2, [pc, #28]	; (400ad0 <_usb_d_dev_handle_setup+0x70>)
  400ab4:	f103 0458 	add.w	r4, r3, #88	; 0x58
  400ab8:	2118      	movs	r1, #24
  400aba:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
	((Usbhs *)hw)->USBHS_DEVEPTIDR[index] = data;
  400abe:	3388      	adds	r3, #136	; 0x88
  400ac0:	f842 1023 	str.w	r1, [r2, r3, lsl #2]

	/* Clear status and notify SETUP */
	_usbd_ep_int_ack(epn, USBHS_DEVEPTISR_NAKINI | USBHS_DEVEPTISR_NAKOUTI);
	_usbd_ep_int_dis(epn, USBHS_DEVEPTIMR_NAKINE | USBHS_DEVEPTIMR_NAKOUTE);
	/* Invoke callback. */
	dev_inst.ep_callbacks.setup(ept->ep);
  400ac4:	4b03      	ldr	r3, [pc, #12]	; (400ad4 <_usb_d_dev_handle_setup+0x74>)
  400ac6:	689b      	ldr	r3, [r3, #8]
  400ac8:	7c80      	ldrb	r0, [r0, #18]
  400aca:	4798      	blx	r3
  400acc:	bd10      	pop	{r4, pc}
  400ace:	bf00      	nop
  400ad0:	40038000 	.word	0x40038000
  400ad4:	204000ac 	.word	0x204000ac

00400ad8 <_usb_d_dev_trans_done>:
 *  \brief Finish the transaction and invoke callback
 * \param[in, out] ept Pointer to endpoint information.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_done(struct _usb_d_dev_ep *ept, const int32_t code)
{
  400ad8:	b538      	push	{r3, r4, r5, lr}
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
  400ada:	7c84      	ldrb	r4, [r0, #18]
  400adc:	2cff      	cmp	r4, #255	; 0xff
  400ade:	d003      	beq.n	400ae8 <_usb_d_dev_trans_done+0x10>
  400ae0:	7cc3      	ldrb	r3, [r0, #19]
  400ae2:	f013 0f40 	tst.w	r3, #64	; 0x40
  400ae6:	d100      	bne.n	400aea <_usb_d_dev_trans_done+0x12>
  400ae8:	bd38      	pop	{r3, r4, r5, pc}
		return;
	}

	ept->flags.bits.is_busy = 0;
  400aea:	7cc2      	ldrb	r2, [r0, #19]
  400aec:	f36f 1286 	bfc	r2, #6, #1
  400af0:	74c2      	strb	r2, [r0, #19]
	dev_inst.ep_callbacks.done(ept->ep, code, ept->trans_count);
  400af2:	4a03      	ldr	r2, [pc, #12]	; (400b00 <_usb_d_dev_trans_done+0x28>)
  400af4:	6915      	ldr	r5, [r2, #16]
  400af6:	6882      	ldr	r2, [r0, #8]
  400af8:	4620      	mov	r0, r4
  400afa:	47a8      	blx	r5
  400afc:	e7f4      	b.n	400ae8 <_usb_d_dev_trans_done+0x10>
  400afe:	bf00      	nop
  400b00:	204000ac 	.word	0x204000ac

00400b04 <_usb_d_dev_reset_epts>:
{
  400b04:	b570      	push	{r4, r5, r6, lr}
	((Usbhs *)hw)->USBHS_DEVCTRL &= ~USBHS_DEVCTRL_ADDEN;
  400b06:	4b15      	ldr	r3, [pc, #84]	; (400b5c <_usb_d_dev_reset_epts+0x58>)
  400b08:	681a      	ldr	r2, [r3, #0]
  400b0a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
  400b0e:	601a      	str	r2, [r3, #0]
	tmp = ((Usbhs *)hw)->USBHS_DEVCTRL;
  400b10:	681a      	ldr	r2, [r3, #0]
	tmp &= ~USBHS_DEVCTRL_UADD_Msk;
  400b12:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
	((Usbhs *)hw)->USBHS_DEVCTRL = tmp;
  400b16:	601a      	str	r2, [r3, #0]
	((Usbhs *)hw)->USBHS_DEVCTRL |= USBHS_DEVCTRL_ADDEN;
  400b18:	681a      	ldr	r2, [r3, #0]
  400b1a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
  400b1e:	601a      	str	r2, [r3, #0]
	for (i = 0; i < USB_D_N_EP; i++) {
  400b20:	2400      	movs	r4, #0
  400b22:	e017      	b.n	400b54 <_usb_d_dev_reset_epts+0x50>
		_usb_d_dev_trans_done(&dev_inst.ep[i], USB_TRANS_RESET);
  400b24:	4e0e      	ldr	r6, [pc, #56]	; (400b60 <_usb_d_dev_reset_epts+0x5c>)
  400b26:	00a5      	lsls	r5, r4, #2
  400b28:	192b      	adds	r3, r5, r4
  400b2a:	0098      	lsls	r0, r3, #2
  400b2c:	3010      	adds	r0, #16
  400b2e:	4430      	add	r0, r6
  400b30:	2103      	movs	r1, #3
  400b32:	3004      	adds	r0, #4
  400b34:	4b0b      	ldr	r3, [pc, #44]	; (400b64 <_usb_d_dev_reset_epts+0x60>)
  400b36:	4798      	blx	r3
		dev_inst.ep[i].ep       = 0xFF;
  400b38:	192a      	adds	r2, r5, r4
  400b3a:	0093      	lsls	r3, r2, #2
  400b3c:	4433      	add	r3, r6
  400b3e:	22ff      	movs	r2, #255	; 0xff
  400b40:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
		dev_inst.ep[i].flags.u8 = 0;
  400b44:	4425      	add	r5, r4
  400b46:	00ab      	lsls	r3, r5, #2
  400b48:	441e      	add	r6, r3
  400b4a:	2300      	movs	r3, #0
  400b4c:	f886 3027 	strb.w	r3, [r6, #39]	; 0x27
	for (i = 0; i < USB_D_N_EP; i++) {
  400b50:	3401      	adds	r4, #1
  400b52:	b2e4      	uxtb	r4, r4
  400b54:	2c03      	cmp	r4, #3
  400b56:	d9e5      	bls.n	400b24 <_usb_d_dev_reset_epts+0x20>
}
  400b58:	bd70      	pop	{r4, r5, r6, pc}
  400b5a:	bf00      	nop
  400b5c:	40038000 	.word	0x40038000
  400b60:	204000ac 	.word	0x204000ac
  400b64:	00400ad9 	.word	0x00400ad9

00400b68 <_usb_d_dev_handle_stall>:
{
  400b68:	b508      	push	{r3, lr}
	uint8_t epn = USB_EP_GET_N(ept->ep);
  400b6a:	7c83      	ldrb	r3, [r0, #18]
  400b6c:	f003 030f 	and.w	r3, r3, #15
	((Usbhs *)hw)->USBHS_DEVEPTIDR[index] = data;
  400b70:	3388      	adds	r3, #136	; 0x88
  400b72:	2140      	movs	r1, #64	; 0x40
  400b74:	4a03      	ldr	r2, [pc, #12]	; (400b84 <_usb_d_dev_handle_stall+0x1c>)
  400b76:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	_usb_d_dev_trans_done(ept, USB_TRANS_STALL);
  400b7a:	2101      	movs	r1, #1
  400b7c:	4b02      	ldr	r3, [pc, #8]	; (400b88 <_usb_d_dev_handle_stall+0x20>)
  400b7e:	4798      	blx	r3
  400b80:	bd08      	pop	{r3, pc}
  400b82:	bf00      	nop
  400b84:	40038000 	.word	0x40038000
  400b88:	00400ad9 	.word	0x00400ad9

00400b8c <_usb_d_dev_dma_next>:
{
  400b8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t  epn = USB_EP_GET_N(ept->ep);
  400b8e:	7c83      	ldrb	r3, [r0, #18]
	if (!ept->flags.bits.is_busy) {
  400b90:	7cc2      	ldrb	r2, [r0, #19]
  400b92:	f012 0f40 	tst.w	r2, #64	; 0x40
  400b96:	d031      	beq.n	400bfc <_usb_d_dev_dma_next+0x70>
  400b98:	f003 030f 	and.w	r3, r3, #15
	if (ept->trans_count != ept->trans_size) {
  400b9c:	6887      	ldr	r7, [r0, #8]
  400b9e:	6845      	ldr	r5, [r0, #4]
  400ba0:	42af      	cmp	r7, r5
  400ba2:	d023      	beq.n	400bec <_usb_d_dev_dma_next+0x60>
		trans_next = ept->trans_size - ept->trans_count;
  400ba4:	1bed      	subs	r5, r5, r7
		if (trans_next > USB_D_DEV_TRANS_MAX) {
  400ba6:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
  400baa:	d828      	bhi.n	400bfe <_usb_d_dev_dma_next+0x72>
			dma_ctrl = USBHS_DEVDMACONTROL_BUFF_LENGTH(trans_next);
  400bac:	0429      	lsls	r1, r5, #16
		if ((ept->flags.bits.dir) && (!ept->flags.bits.need_zlp)) {
  400bae:	f002 0690 	and.w	r6, r2, #144	; 0x90
  400bb2:	2e80      	cmp	r6, #128	; 0x80
  400bb4:	d027      	beq.n	400c06 <_usb_d_dev_dma_next+0x7a>
			if ((ept->flags.bits.eptype != USB_D_EPTYPE_ISOCH) || (trans_next <= ept->size)) {
  400bb6:	f002 0207 	and.w	r2, r2, #7
  400bba:	2a02      	cmp	r2, #2
  400bbc:	d026      	beq.n	400c0c <_usb_d_dev_dma_next+0x80>
				dma_ctrl |= USBHS_DEVDMACONTROL_END_TR_IT | USBHS_DEVDMACONTROL_END_TR_EN;
  400bbe:	f041 0114 	orr.w	r1, r1, #20
		hri_usbhs_write_DEVDMAADDRESS_reg(hw, (epn - 1), (uint32_t)&ept->trans_buf[ept->trans_count]);
  400bc2:	1e5a      	subs	r2, r3, #1
  400bc4:	b2d2      	uxtb	r2, r2
  400bc6:	6806      	ldr	r6, [r0, #0]
  400bc8:	4437      	add	r7, r6

static inline void hri_usbhs_write_DEVDMAADDRESS_reg(const void *const hw, uint8_t submodule_index,
                                                     hri_usbhs_devdmaaddress_reg_t data)
{
	USBHS_CRITICAL_SECTION_ENTER();
	((Usbhs *)hw)->UsbhsDevdma[submodule_index].USBHS_DEVDMAADDRESS = data;
  400bca:	4c28      	ldr	r4, [pc, #160]	; (400c6c <_usb_d_dev_dma_next+0xe0>)
  400bcc:	f102 0631 	add.w	r6, r2, #49	; 0x31
  400bd0:	eb04 1606 	add.w	r6, r4, r6, lsl #4
  400bd4:	6077      	str	r7, [r6, #4]
		dma_ctrl |= USBHS_DEVDMACONTROL_END_BUFFIT | USBHS_DEVDMACONTROL_CHANN_ENB;
  400bd6:	f041 0121 	orr.w	r1, r1, #33	; 0x21
	USBHS_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_usbhs_get_DEVDMASTATUS_END_TR_ST_bit(const void *const hw, uint8_t submodule_index)
{
	return (((Usbhs *)hw)->UsbhsDevdma[submodule_index].USBHS_DEVDMASTATUS & USBHS_DEVDMASTATUS_END_TR_ST)
  400bda:	eb04 1402 	add.w	r4, r4, r2, lsl #4
  400bde:	f8d4 431c 	ldr.w	r4, [r4, #796]	; 0x31c
		if (!hri_usbhs_get_DEVDMASTATUS_END_TR_ST_bit(hw, (epn - 1))) {
  400be2:	f014 0f10 	tst.w	r4, #16
  400be6:	d015      	beq.n	400c14 <_usb_d_dev_dma_next+0x88>
		ept->trans_size = ept->trans_count;
  400be8:	6882      	ldr	r2, [r0, #8]
  400bea:	6042      	str	r2, [r0, #4]
	if ((ept->flags.bits.dir) && (ept->flags.bits.need_zlp)) {
  400bec:	7cc2      	ldrb	r2, [r0, #19]
  400bee:	f002 0290 	and.w	r2, r2, #144	; 0x90
  400bf2:	2a90      	cmp	r2, #144	; 0x90
  400bf4:	d01d      	beq.n	400c32 <_usb_d_dev_dma_next+0xa6>
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
  400bf6:	2100      	movs	r1, #0
  400bf8:	4b1d      	ldr	r3, [pc, #116]	; (400c70 <_usb_d_dev_dma_next+0xe4>)
  400bfa:	4798      	blx	r3
  400bfc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			dma_ctrl = USBHS_DEVDMACONTROL_BUFF_LENGTH(0);
  400bfe:	2100      	movs	r1, #0
			trans_next = USB_D_DEV_TRANS_MAX;
  400c00:	f44f 3580 	mov.w	r5, #65536	; 0x10000
  400c04:	e7d3      	b.n	400bae <_usb_d_dev_dma_next+0x22>
			dma_ctrl |= USBHS_DEVDMACONTROL_END_B_EN;
  400c06:	f041 0108 	orr.w	r1, r1, #8
  400c0a:	e7da      	b.n	400bc2 <_usb_d_dev_dma_next+0x36>
			if ((ept->flags.bits.eptype != USB_D_EPTYPE_ISOCH) || (trans_next <= ept->size)) {
  400c0c:	8a02      	ldrh	r2, [r0, #16]
  400c0e:	4295      	cmp	r5, r2
  400c10:	d8d7      	bhi.n	400bc2 <_usb_d_dev_dma_next+0x36>
  400c12:	e7d4      	b.n	400bbe <_usb_d_dev_dma_next+0x32>
	((Usbhs *)hw)->UsbhsDevdma[submodule_index].USBHS_DEVDMACONTROL = data;
  400c14:	4c15      	ldr	r4, [pc, #84]	; (400c6c <_usb_d_dev_dma_next+0xe0>)
  400c16:	eb04 1202 	add.w	r2, r4, r2, lsl #4
  400c1a:	f8c2 1318 	str.w	r1, [r2, #792]	; 0x318
			ept->trans_count += trans_next;
  400c1e:	6882      	ldr	r2, [r0, #8]
  400c20:	442a      	add	r2, r5
  400c22:	6082      	str	r2, [r0, #8]
			ept->trans_load = trans_next;
  400c24:	60c5      	str	r5, [r0, #12]
			hri_usbhs_set_DEVIMR_reg(hw, (USBHS_DEVIMR_DMA_1 << (epn - 1)));
  400c26:	1e5a      	subs	r2, r3, #1
  400c28:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
  400c2c:	4093      	lsls	r3, r2
	((Usbhs *)hw)->USBHS_DEVIER = mask;
  400c2e:	61a3      	str	r3, [r4, #24]
  400c30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  400c32:	490e      	ldr	r1, [pc, #56]	; (400c6c <_usb_d_dev_dma_next+0xe0>)
  400c34:	f103 0258 	add.w	r2, r3, #88	; 0x58
  400c38:	2001      	movs	r0, #1
  400c3a:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
	return (((Usbhs *)hw)->USBHS_DEVEPTISR[index] & USBHS_DEVEPTISR_RWALL) >> USBHS_DEVEPTISR_RWALL_Pos;
  400c3e:	f103 024c 	add.w	r2, r3, #76	; 0x4c
  400c42:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
		if (hri_usbhs_get_DEVEPTISR_RWALL_bit(hw, epn)) {
  400c46:	f412 3f80 	tst.w	r2, #65536	; 0x10000
  400c4a:	d003      	beq.n	400c54 <_usb_d_dev_dma_next+0xc8>
	((Usbhs *)hw)->USBHS_DEVEPTIFR[index] = data;
  400c4c:	f103 0264 	add.w	r2, r3, #100	; 0x64
  400c50:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
	((Usbhs *)hw)->USBHS_DEVEPTIER[index] = data;
  400c54:	4905      	ldr	r1, [pc, #20]	; (400c6c <_usb_d_dev_dma_next+0xe0>)
  400c56:	f103 027c 	add.w	r2, r3, #124	; 0x7c
  400c5a:	2001      	movs	r0, #1
  400c5c:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
		hri_usbhs_set_DEVIMR_reg(hw, (USBHS_DEVIER_PEP_0 << epn));
  400c60:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  400c64:	fa02 f303 	lsl.w	r3, r2, r3
	((Usbhs *)hw)->USBHS_DEVIER = mask;
  400c68:	618b      	str	r3, [r1, #24]
  400c6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  400c6c:	40038000 	.word	0x40038000
  400c70:	00400ad9 	.word	0x00400ad9

00400c74 <_usb_d_dev_trans_stop>:
 * \param[in] dir Endpoint direction.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_stop(struct _usb_d_dev_ep *ept, bool dir, const int32_t code)
{
	uint8_t epn = USB_EP_GET_N(ept->ep);
  400c74:	7c83      	ldrb	r3, [r0, #18]

	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
  400c76:	2bff      	cmp	r3, #255	; 0xff
  400c78:	d016      	beq.n	400ca8 <_usb_d_dev_trans_stop+0x34>
{
  400c7a:	b510      	push	{r4, lr}
  400c7c:	f003 040f 	and.w	r4, r3, #15
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
  400c80:	7cc3      	ldrb	r3, [r0, #19]
  400c82:	f013 0f40 	tst.w	r3, #64	; 0x40
  400c86:	d008      	beq.n	400c9a <_usb_d_dev_trans_stop+0x26>
		return;
	}

	/* Stop transfer */
	if (dir) {
  400c88:	b141      	cbz	r1, 400c9c <_usb_d_dev_trans_stop+0x28>
	((Usbhs *)hw)->USBHS_DEVEPTIFR[index] = data;
  400c8a:	3464      	adds	r4, #100	; 0x64
  400c8c:	2101      	movs	r1, #1
  400c8e:	4b07      	ldr	r3, [pc, #28]	; (400cac <_usb_d_dev_trans_stop+0x38>)
  400c90:	f843 1024 	str.w	r1, [r3, r4, lsl #2]
  400c94:	4611      	mov	r1, r2
	} else {
		/* NAK OUT */
		_usbd_ep_set_out_rdy(epn, false);
	}

	_usb_d_dev_trans_done(ept, code);
  400c96:	4b06      	ldr	r3, [pc, #24]	; (400cb0 <_usb_d_dev_trans_stop+0x3c>)
  400c98:	4798      	blx	r3
  400c9a:	bd10      	pop	{r4, pc}
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  400c9c:	3458      	adds	r4, #88	; 0x58
  400c9e:	2102      	movs	r1, #2
  400ca0:	4b02      	ldr	r3, [pc, #8]	; (400cac <_usb_d_dev_trans_stop+0x38>)
  400ca2:	f843 1024 	str.w	r1, [r3, r4, lsl #2]
  400ca6:	e7f5      	b.n	400c94 <_usb_d_dev_trans_stop+0x20>
  400ca8:	4770      	bx	lr
  400caa:	bf00      	nop
  400cac:	40038000 	.word	0x40038000
  400cb0:	00400ad9 	.word	0x00400ad9

00400cb4 <_usb_d_dev_handle_overflow>:
{
  400cb4:	b510      	push	{r4, lr}
	uint8_t epn = USB_EP_GET_N(ept->ep);
  400cb6:	7c83      	ldrb	r3, [r0, #18]
  400cb8:	f003 030f 	and.w	r3, r3, #15
  400cbc:	3358      	adds	r3, #88	; 0x58
  400cbe:	2420      	movs	r4, #32
  400cc0:	4904      	ldr	r1, [pc, #16]	; (400cd4 <_usb_d_dev_handle_overflow+0x20>)
  400cc2:	f841 4023 	str.w	r4, [r1, r3, lsl #2]
	_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_ERROR);
  400cc6:	7cc1      	ldrb	r1, [r0, #19]
  400cc8:	2204      	movs	r2, #4
  400cca:	09c9      	lsrs	r1, r1, #7
  400ccc:	4b02      	ldr	r3, [pc, #8]	; (400cd8 <_usb_d_dev_handle_overflow+0x24>)
  400cce:	4798      	blx	r3
  400cd0:	bd10      	pop	{r4, pc}
  400cd2:	bf00      	nop
  400cd4:	40038000 	.word	0x40038000
  400cd8:	00400c75 	.word	0x00400c75

00400cdc <_usb_d_dev_in_next>:
{
  400cdc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  400cde:	4604      	mov	r4, r0
	uint8_t  epn      = USB_EP_GET_N(ept->ep);
  400ce0:	7c85      	ldrb	r5, [r0, #18]
  400ce2:	f005 050f 	and.w	r5, r5, #15
	uint8_t *ptr_dest = (uint8_t *)&_usbd_ep_get_fifo_access(epn, 8);
  400ce6:	483d      	ldr	r0, [pc, #244]	; (400ddc <_usb_d_dev_in_next+0x100>)
  400ce8:	eb00 30c5 	add.w	r0, r0, r5, lsl #15
	uint16_t trans_count = ept->trans_load;
  400cec:	68e2      	ldr	r2, [r4, #12]
	uint16_t last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
  400cee:	8a26      	ldrh	r6, [r4, #16]
  400cf0:	f240 33ff 	movw	r3, #1023	; 0x3ff
  400cf4:	429e      	cmp	r6, r3
  400cf6:	d02a      	beq.n	400d4e <_usb_d_dev_in_next+0x72>
  400cf8:	1e73      	subs	r3, r6, #1
  400cfa:	b21b      	sxth	r3, r3
  400cfc:	4013      	ands	r3, r2
  400cfe:	b29a      	uxth	r2, r3
	bool     is_ctrl  = _usb_d_dev_ep_is_ctrl(ept);
  400d00:	f894 e013 	ldrb.w	lr, [r4, #19]
  400d04:	f00e 0707 	and.w	r7, lr, #7
	if (ept->trans_count >= ept->trans_size) {
  400d08:	68a1      	ldr	r1, [r4, #8]
  400d0a:	6863      	ldr	r3, [r4, #4]
  400d0c:	4299      	cmp	r1, r3
  400d0e:	d345      	bcc.n	400d9c <_usb_d_dev_in_next+0xc0>
		if (ept->flags.bits.need_zlp) {
  400d10:	f01e 0f10 	tst.w	lr, #16
  400d14:	d01d      	beq.n	400d52 <_usb_d_dev_in_next+0x76>
			ept->trans_load          = 0;
  400d16:	2200      	movs	r2, #0
  400d18:	60e2      	str	r2, [r4, #12]
			ept->flags.bits.need_zlp = 0;
  400d1a:	7ce3      	ldrb	r3, [r4, #19]
  400d1c:	f362 1304 	bfi	r3, r2, #4, #1
  400d20:	74e3      	strb	r3, [r4, #19]
  400d22:	4a2f      	ldr	r2, [pc, #188]	; (400de0 <_usb_d_dev_in_next+0x104>)
  400d24:	f105 0358 	add.w	r3, r5, #88	; 0x58
  400d28:	2101      	movs	r1, #1
  400d2a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
  400d2e:	2108      	movs	r1, #8
  400d30:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	((Usbhs *)hw)->USBHS_DEVEPTIER[index] = data;
  400d34:	f105 037c 	add.w	r3, r5, #124	; 0x7c
  400d38:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
			if (!is_ctrl) {
  400d3c:	2f01      	cmp	r7, #1
  400d3e:	d04b      	beq.n	400dd8 <_usb_d_dev_in_next+0xfc>
	((Usbhs *)hw)->USBHS_DEVEPTIDR[index] = data;
  400d40:	3588      	adds	r5, #136	; 0x88
  400d42:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  400d46:	4b26      	ldr	r3, [pc, #152]	; (400de0 <_usb_d_dev_in_next+0x104>)
  400d48:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
  400d4c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uint16_t last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
  400d4e:	b233      	sxth	r3, r6
  400d50:	e7d4      	b.n	400cfc <_usb_d_dev_in_next+0x20>
  400d52:	f105 0388 	add.w	r3, r5, #136	; 0x88
  400d56:	2001      	movs	r0, #1
  400d58:	4921      	ldr	r1, [pc, #132]	; (400de0 <_usb_d_dev_in_next+0x104>)
  400d5a:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
		if (!is_ctrl) {
  400d5e:	4287      	cmp	r7, r0
  400d60:	d004      	beq.n	400d6c <_usb_d_dev_in_next+0x90>
			hri_usbhs_clear_DEVIMR_reg(hw, (USBHS_DEVIER_PEP_0 << epn));
  400d62:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  400d66:	fa03 f505 	lsl.w	r5, r3, r5
	((Usbhs *)hw)->USBHS_DEVIDR = mask;
  400d6a:	614d      	str	r5, [r1, #20]
		ept->trans_size = ept->trans_count;
  400d6c:	68a1      	ldr	r1, [r4, #8]
  400d6e:	6061      	str	r1, [r4, #4]
		if (last_pkt == ept->size) {
  400d70:	8a23      	ldrh	r3, [r4, #16]
  400d72:	429a      	cmp	r2, r3
  400d74:	d004      	beq.n	400d80 <_usb_d_dev_in_next+0xa4>
		_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
  400d76:	2100      	movs	r1, #0
  400d78:	4620      	mov	r0, r4
  400d7a:	4b1a      	ldr	r3, [pc, #104]	; (400de4 <_usb_d_dev_in_next+0x108>)
  400d7c:	4798      	blx	r3
		return;
  400d7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			ept->flags.bits.is_busy = 0;
  400d80:	7ce3      	ldrb	r3, [r4, #19]
  400d82:	f36f 1386 	bfc	r3, #6, #1
  400d86:	74e3      	strb	r3, [r4, #19]
			if (dev_inst.ep_callbacks.more(ept->ep, ept->trans_count)) {
  400d88:	4b17      	ldr	r3, [pc, #92]	; (400de8 <_usb_d_dev_in_next+0x10c>)
  400d8a:	68db      	ldr	r3, [r3, #12]
  400d8c:	7ca0      	ldrb	r0, [r4, #18]
  400d8e:	4798      	blx	r3
  400d90:	bb10      	cbnz	r0, 400dd8 <_usb_d_dev_in_next+0xfc>
			ept->flags.bits.is_busy = 1;
  400d92:	7ce3      	ldrb	r3, [r4, #19]
  400d94:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  400d98:	74e3      	strb	r3, [r4, #19]
  400d9a:	e7ec      	b.n	400d76 <_usb_d_dev_in_next+0x9a>
		trans_next = ept->trans_size - ept->trans_count;
  400d9c:	b29b      	uxth	r3, r3
  400d9e:	b28a      	uxth	r2, r1
  400da0:	1a9b      	subs	r3, r3, r2
  400da2:	b29b      	uxth	r3, r3
		if (trans_next > ept->size) {
  400da4:	429e      	cmp	r6, r3
  400da6:	d300      	bcc.n	400daa <_usb_d_dev_in_next+0xce>
		trans_next = ept->trans_size - ept->trans_count;
  400da8:	461e      	mov	r6, r3
		ptr_src = &ept->trans_buf[ept->trans_count];
  400daa:	6823      	ldr	r3, [r4, #0]
		memcpy(ptr_dest, ptr_src, trans_next);
  400dac:	4632      	mov	r2, r6
  400dae:	4419      	add	r1, r3
  400db0:	4b0e      	ldr	r3, [pc, #56]	; (400dec <_usb_d_dev_in_next+0x110>)
  400db2:	4798      	blx	r3
		ept->trans_load = trans_next;
  400db4:	60e6      	str	r6, [r4, #12]
		ept->trans_count += trans_next;
  400db6:	68a3      	ldr	r3, [r4, #8]
  400db8:	441e      	add	r6, r3
  400dba:	60a6      	str	r6, [r4, #8]
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  400dbc:	f105 0358 	add.w	r3, r5, #88	; 0x58
  400dc0:	2101      	movs	r1, #1
  400dc2:	4a07      	ldr	r2, [pc, #28]	; (400de0 <_usb_d_dev_in_next+0x104>)
  400dc4:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		if (!is_ctrl) {
  400dc8:	428f      	cmp	r7, r1
  400dca:	d005      	beq.n	400dd8 <_usb_d_dev_in_next+0xfc>
	((Usbhs *)hw)->USBHS_DEVEPTIDR[index] = data;
  400dcc:	3588      	adds	r5, #136	; 0x88
  400dce:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  400dd2:	4b03      	ldr	r3, [pc, #12]	; (400de0 <_usb_d_dev_in_next+0x104>)
  400dd4:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
  400dd8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  400dda:	bf00      	nop
  400ddc:	a0100000 	.word	0xa0100000
  400de0:	40038000 	.word	0x40038000
  400de4:	00400ad9 	.word	0x00400ad9
  400de8:	204000ac 	.word	0x204000ac
  400dec:	00401525 	.word	0x00401525

00400df0 <_usb_d_dev_out_next>:
{
  400df0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  400df4:	4604      	mov	r4, r0
	uint8_t  epn         = USB_EP_GET_N(ept->ep);
  400df6:	7c86      	ldrb	r6, [r0, #18]
  400df8:	f006 060f 	and.w	r6, r6, #15
	tmp = ((Usbhs *)hw)->USBHS_DEVEPTISR[index];
  400dfc:	4a2f      	ldr	r2, [pc, #188]	; (400ebc <_usb_d_dev_out_next+0xcc>)
  400dfe:	f106 034c 	add.w	r3, r6, #76	; 0x4c
  400e02:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	return (hri_usbhs_get_DEVEPTISR_reg(USBHS, epn, USBHS_DEVEPTISR_BYCT_Msk) >> USBHS_DEVEPTISR_BYCT_Pos);
  400e06:	f3c3 530a 	ubfx	r3, r3, #20, #11
	uint16_t last_remain = ept->trans_size - ept->trans_count;
  400e0a:	8885      	ldrh	r5, [r0, #4]
  400e0c:	8901      	ldrh	r1, [r0, #8]
  400e0e:	1a6d      	subs	r5, r5, r1
	uint8_t *ptr         = (uint8_t *)&_usbd_ep_get_fifo_access(epn, 8);
  400e10:	492b      	ldr	r1, [pc, #172]	; (400ec0 <_usb_d_dev_out_next+0xd0>)
  400e12:	eb01 31c6 	add.w	r1, r1, r6, lsl #15
	bool     is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
  400e16:	7cc7      	ldrb	r7, [r0, #19]
  400e18:	f007 0707 	and.w	r7, r7, #7
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  400e1c:	f106 0058 	add.w	r0, r6, #88	; 0x58
  400e20:	f04f 0e02 	mov.w	lr, #2
  400e24:	f842 e020 	str.w	lr, [r2, r0, lsl #2]
	if (last_trans > 0) {
  400e28:	2b00      	cmp	r3, #0
  400e2a:	d03a      	beq.n	400ea2 <_usb_d_dev_out_next+0xb2>
  400e2c:	b2ad      	uxth	r5, r5
		if (last_trans > last_remain) {
  400e2e:	429d      	cmp	r5, r3
  400e30:	d334      	bcc.n	400e9c <_usb_d_dev_out_next+0xac>
	uint16_t last_trans  = _usbd_ep_get_trans_count(epn);
  400e32:	461d      	mov	r5, r3
	bool     is_full = false, is_short = false;
  400e34:	f04f 0800 	mov.w	r8, #0
		memcpy(&ept->trans_buf[ept->trans_count], ptr, last_trans);
  400e38:	6820      	ldr	r0, [r4, #0]
  400e3a:	68a3      	ldr	r3, [r4, #8]
  400e3c:	462a      	mov	r2, r5
  400e3e:	4418      	add	r0, r3
  400e40:	4b20      	ldr	r3, [pc, #128]	; (400ec4 <_usb_d_dev_out_next+0xd4>)
  400e42:	4798      	blx	r3
		ept->trans_count += last_trans;
  400e44:	68a3      	ldr	r3, [r4, #8]
  400e46:	442b      	add	r3, r5
  400e48:	60a3      	str	r3, [r4, #8]
		ept->trans_load = last_trans;
  400e4a:	60e5      	str	r5, [r4, #12]
	((Usbhs *)hw)->USBHS_DEVEPTIDR[index] = data;
  400e4c:	f106 0388 	add.w	r3, r6, #136	; 0x88
  400e50:	f44f 4180 	mov.w	r1, #16384	; 0x4000
  400e54:	4a19      	ldr	r2, [pc, #100]	; (400ebc <_usb_d_dev_out_next+0xcc>)
  400e56:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
  400e5a:	462b      	mov	r3, r5
	if (last_trans < ept->size) {
  400e5c:	8a22      	ldrh	r2, [r4, #16]
  400e5e:	4293      	cmp	r3, r2
  400e60:	d222      	bcs.n	400ea8 <_usb_d_dev_out_next+0xb8>
		ept->flags.bits.need_zlp = 0;
  400e62:	7ce3      	ldrb	r3, [r4, #19]
  400e64:	f36f 1304 	bfc	r3, #4, #1
  400e68:	74e3      	strb	r3, [r4, #19]
		is_short                 = true;
  400e6a:	2301      	movs	r3, #1
	if (is_full || is_short) {
  400e6c:	ea58 0303 	orrs.w	r3, r8, r3
  400e70:	d012      	beq.n	400e98 <_usb_d_dev_out_next+0xa8>
  400e72:	f106 0388 	add.w	r3, r6, #136	; 0x88
  400e76:	2102      	movs	r1, #2
  400e78:	4a10      	ldr	r2, [pc, #64]	; (400ebc <_usb_d_dev_out_next+0xcc>)
  400e7a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		if (!is_ctrl) {
  400e7e:	2f01      	cmp	r7, #1
  400e80:	d004      	beq.n	400e8c <_usb_d_dev_out_next+0x9c>
			hri_usbhs_clear_DEVIMR_reg(hw, (USBHS_DEVIER_PEP_0 << epn));
  400e82:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  400e86:	fa03 f606 	lsl.w	r6, r3, r6
	((Usbhs *)hw)->USBHS_DEVIDR = mask;
  400e8a:	6156      	str	r6, [r2, #20]
		ept->trans_size = ept->trans_count;
  400e8c:	68a3      	ldr	r3, [r4, #8]
  400e8e:	6063      	str	r3, [r4, #4]
		_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
  400e90:	2100      	movs	r1, #0
  400e92:	4620      	mov	r0, r4
  400e94:	4b0c      	ldr	r3, [pc, #48]	; (400ec8 <_usb_d_dev_out_next+0xd8>)
  400e96:	4798      	blx	r3
  400e98:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			is_full    = true;
  400e9c:	f04f 0801 	mov.w	r8, #1
  400ea0:	e7ca      	b.n	400e38 <_usb_d_dev_out_next+0x48>
	bool     is_full = false, is_short = false;
  400ea2:	f04f 0800 	mov.w	r8, #0
  400ea6:	e7d9      	b.n	400e5c <_usb_d_dev_out_next+0x6c>
	} else if (ept->trans_count >= ept->trans_size) {
  400ea8:	68a2      	ldr	r2, [r4, #8]
  400eaa:	6863      	ldr	r3, [r4, #4]
  400eac:	429a      	cmp	r2, r3
  400eae:	d201      	bcs.n	400eb4 <_usb_d_dev_out_next+0xc4>
	bool     is_full = false, is_short = false;
  400eb0:	2300      	movs	r3, #0
  400eb2:	e7db      	b.n	400e6c <_usb_d_dev_out_next+0x7c>
  400eb4:	2300      	movs	r3, #0
		is_full = true;
  400eb6:	f04f 0801 	mov.w	r8, #1
  400eba:	e7d7      	b.n	400e6c <_usb_d_dev_out_next+0x7c>
  400ebc:	40038000 	.word	0x40038000
  400ec0:	a0100000 	.word	0xa0100000
  400ec4:	00401525 	.word	0x00401525
  400ec8:	00400ad9 	.word	0x00400ad9

00400ecc <USBHS_Handler>:
{
  400ecc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return ((Usbhs *)hw)->USBHS_DEVISR;
  400ece:	4b75      	ldr	r3, [pc, #468]	; (4010a4 <USBHS_Handler+0x1d8>)
  400ed0:	685a      	ldr	r2, [r3, #4]
	return ((Usbhs *)hw)->USBHS_DEVIMR;
  400ed2:	691d      	ldr	r5, [r3, #16]
	flags = hri_usbhs_read_DEVISR_reg(hw) & hri_usbhs_read_DEVIMR_reg(hw);
  400ed4:	4015      	ands	r5, r2
	ep_int = (flags & USBHS_DEVISR_PEP__Msk) >> USBHS_DEVISR_PEP__Pos;
  400ed6:	f3c5 3609 	ubfx	r6, r5, #12, #10
	if ((ep_int == 0) && (dma_int == 0)) {
  400eda:	0e6d      	lsrs	r5, r5, #25
  400edc:	bf0c      	ite	eq
  400ede:	2401      	moveq	r4, #1
  400ee0:	2400      	movne	r4, #0
  400ee2:	2e00      	cmp	r6, #0
  400ee4:	bf14      	ite	ne
  400ee6:	2400      	movne	r4, #0
  400ee8:	f004 0401 	andeq.w	r4, r4, #1
  400eec:	b90c      	cbnz	r4, 400ef2 <USBHS_Handler+0x26>
		rc = false;
  400eee:	2400      	movs	r4, #0
  400ef0:	e07d      	b.n	400fee <USBHS_Handler+0x122>
	return ((Usbhs *)hw)->USBHS_DEVISR;
  400ef2:	461a      	mov	r2, r3
  400ef4:	685b      	ldr	r3, [r3, #4]
	uint16_t flags = hri_usbhs_read_DEVISR_reg(USBHS);
  400ef6:	b29b      	uxth	r3, r3
	return ((Usbhs *)hw)->USBHS_DEVIMR;
  400ef8:	6912      	ldr	r2, [r2, #16]
	flags &= hri_usbhs_read_DEVIMR_reg(USBHS);
  400efa:	4013      	ands	r3, r2
	if (flags & USBHS_DEVISR_SOF) {
  400efc:	f013 0f04 	tst.w	r3, #4
  400f00:	d10f      	bne.n	400f22 <USBHS_Handler+0x56>
	} else if (flags & USBHS_DEVISR_MSOF) {
  400f02:	f013 0f02 	tst.w	r3, #2
  400f06:	d113      	bne.n	400f30 <USBHS_Handler+0x64>
	if (flags & USB_D_WAKEUP_INT_FLAGS) {
  400f08:	f013 0f70 	tst.w	r3, #112	; 0x70
  400f0c:	d117      	bne.n	400f3e <USBHS_Handler+0x72>
	} else if (flags & USBHS_DEVISR_EORST) {
  400f0e:	f013 0f08 	tst.w	r3, #8
  400f12:	d120      	bne.n	400f56 <USBHS_Handler+0x8a>
	} else if (flags & USBHS_DEVISR_SUSP) {
  400f14:	f013 0f01 	tst.w	r3, #1
  400f18:	d12c      	bne.n	400f74 <USBHS_Handler+0xa8>
		rc = false;
  400f1a:	2400      	movs	r4, #0
		if (_usb_d_dev_handle_nep()) {
  400f1c:	2c00      	cmp	r4, #0
  400f1e:	d0e6      	beq.n	400eee <USBHS_Handler+0x22>
  400f20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	((Usbhs *)hw)->USBHS_DEVICR = data;
  400f22:	2204      	movs	r2, #4
  400f24:	4b5f      	ldr	r3, [pc, #380]	; (4010a4 <USBHS_Handler+0x1d8>)
  400f26:	609a      	str	r2, [r3, #8]
	dev_inst.callbacks.sof();
  400f28:	4b5f      	ldr	r3, [pc, #380]	; (4010a8 <USBHS_Handler+0x1dc>)
  400f2a:	681b      	ldr	r3, [r3, #0]
  400f2c:	4798      	blx	r3
  400f2e:	e7f5      	b.n	400f1c <USBHS_Handler+0x50>
  400f30:	2202      	movs	r2, #2
  400f32:	4b5c      	ldr	r3, [pc, #368]	; (4010a4 <USBHS_Handler+0x1d8>)
  400f34:	609a      	str	r2, [r3, #8]
	dev_inst.callbacks.sof();
  400f36:	4b5c      	ldr	r3, [pc, #368]	; (4010a8 <USBHS_Handler+0x1dc>)
  400f38:	681b      	ldr	r3, [r3, #0]
  400f3a:	4798      	blx	r3
  400f3c:	e7ee      	b.n	400f1c <USBHS_Handler+0x50>
  400f3e:	4b59      	ldr	r3, [pc, #356]	; (4010a4 <USBHS_Handler+0x1d8>)
  400f40:	2270      	movs	r2, #112	; 0x70
  400f42:	609a      	str	r2, [r3, #8]
	((Usbhs *)hw)->USBHS_DEVIDR = mask;
  400f44:	615a      	str	r2, [r3, #20]
	((Usbhs *)hw)->USBHS_DEVIER = USBHS_DEVIMR_SUSPE;
  400f46:	2201      	movs	r2, #1
  400f48:	619a      	str	r2, [r3, #24]
	dev_inst.callbacks.event(USB_EV_WAKEUP, 0);
  400f4a:	4b57      	ldr	r3, [pc, #348]	; (4010a8 <USBHS_Handler+0x1dc>)
  400f4c:	685b      	ldr	r3, [r3, #4]
  400f4e:	2100      	movs	r1, #0
  400f50:	2002      	movs	r0, #2
  400f52:	4798      	blx	r3
  400f54:	e7e2      	b.n	400f1c <USBHS_Handler+0x50>
	((Usbhs *)hw)->USBHS_DEVICR = data;
  400f56:	4b53      	ldr	r3, [pc, #332]	; (4010a4 <USBHS_Handler+0x1d8>)
  400f58:	2208      	movs	r2, #8
  400f5a:	609a      	str	r2, [r3, #8]
	((Usbhs *)hw)->USBHS_DEVIDR = mask;
  400f5c:	2270      	movs	r2, #112	; 0x70
  400f5e:	615a      	str	r2, [r3, #20]
	((Usbhs *)hw)->USBHS_DEVIER = mask;
  400f60:	2701      	movs	r7, #1
  400f62:	619f      	str	r7, [r3, #24]
	_usb_d_dev_reset_epts();
  400f64:	4b51      	ldr	r3, [pc, #324]	; (4010ac <USBHS_Handler+0x1e0>)
  400f66:	4798      	blx	r3
	dev_inst.callbacks.event(USB_EV_RESET, 0);
  400f68:	4b4f      	ldr	r3, [pc, #316]	; (4010a8 <USBHS_Handler+0x1dc>)
  400f6a:	685b      	ldr	r3, [r3, #4]
  400f6c:	2100      	movs	r1, #0
  400f6e:	4638      	mov	r0, r7
  400f70:	4798      	blx	r3
  400f72:	e7d3      	b.n	400f1c <USBHS_Handler+0x50>
	((Usbhs *)hw)->USBHS_DEVICR = data;
  400f74:	4b4b      	ldr	r3, [pc, #300]	; (4010a4 <USBHS_Handler+0x1d8>)
  400f76:	2201      	movs	r2, #1
  400f78:	609a      	str	r2, [r3, #8]
	((Usbhs *)hw)->USBHS_DEVIDR = mask;
  400f7a:	615a      	str	r2, [r3, #20]
	((Usbhs *)hw)->USBHS_DEVIER = mask;
  400f7c:	2270      	movs	r2, #112	; 0x70
  400f7e:	619a      	str	r2, [r3, #24]
	dev_inst.callbacks.event(USB_EV_SUSPEND, 0);
  400f80:	4b49      	ldr	r3, [pc, #292]	; (4010a8 <USBHS_Handler+0x1dc>)
  400f82:	685b      	ldr	r3, [r3, #4]
  400f84:	2100      	movs	r1, #0
  400f86:	2004      	movs	r0, #4
  400f88:	4798      	blx	r3
  400f8a:	e7c7      	b.n	400f1c <USBHS_Handler+0x50>
	uint8_t epn = USB_EP_GET_N(ept->ep);
  400f8c:	7c83      	ldrb	r3, [r0, #18]
  400f8e:	f003 030f 	and.w	r3, r3, #15
	if (!(epint & (1u << epn))) {
  400f92:	2201      	movs	r2, #1
  400f94:	409a      	lsls	r2, r3
  400f96:	4216      	tst	r6, r2
  400f98:	d027      	beq.n	400fea <USBHS_Handler+0x11e>
	return ((Usbhs *)hw)->USBHS_DEVEPTISR[index];
  400f9a:	4942      	ldr	r1, [pc, #264]	; (4010a4 <USBHS_Handler+0x1d8>)
  400f9c:	f103 024c 	add.w	r2, r3, #76	; 0x4c
  400fa0:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
	return ((Usbhs *)hw)->USBHS_DEVEPTIMR[index];
  400fa4:	3370      	adds	r3, #112	; 0x70
  400fa6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
	mask  = hri_usbhs_read_DEVEPTIMR_reg(hw, epn);
  400faa:	b2db      	uxtb	r3, r3
	if (flags) {
  400fac:	401a      	ands	r2, r3
  400fae:	d01c      	beq.n	400fea <USBHS_Handler+0x11e>
		if (flags & USBHS_DEVEPTISR_STALLEDI) {
  400fb0:	f012 0f40 	tst.w	r2, #64	; 0x40
  400fb4:	d117      	bne.n	400fe6 <USBHS_Handler+0x11a>
		} else if (!_usb_d_dev_ep_is_busy(ept)) {
  400fb6:	7cc3      	ldrb	r3, [r0, #19]
  400fb8:	f013 0f40 	tst.w	r3, #64	; 0x40
  400fbc:	d04f      	beq.n	40105e <USBHS_Handler+0x192>
		} else if (_usb_d_dev_ep_is_in(ept)) {
  400fbe:	f013 0f80 	tst.w	r3, #128	; 0x80
  400fc2:	d158      	bne.n	401076 <USBHS_Handler+0x1aa>
	if (flags & USBHS_DEVEPTISR_OVERFI) {
  400fc4:	f012 0f20 	tst.w	r2, #32
  400fc8:	d166      	bne.n	401098 <USBHS_Handler+0x1cc>
	} else if (flags & USBHS_DEVEPTISR_RXOUTI) {
  400fca:	f012 0f02 	tst.w	r2, #2
  400fce:	d166      	bne.n	40109e <USBHS_Handler+0x1d2>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
  400fd0:	7cc3      	ldrb	r3, [r0, #19]
  400fd2:	f003 0307 	and.w	r3, r3, #7
  400fd6:	2b01      	cmp	r3, #1
  400fd8:	d107      	bne.n	400fea <USBHS_Handler+0x11e>
		if (flags & USBHS_DEVEPTISR_RXSTPI) {
  400fda:	f012 0f04 	tst.w	r2, #4
  400fde:	d004      	beq.n	400fea <USBHS_Handler+0x11e>
			_usb_d_dev_handle_setup(ept);
  400fe0:	4b33      	ldr	r3, [pc, #204]	; (4010b0 <USBHS_Handler+0x1e4>)
  400fe2:	4798      	blx	r3
  400fe4:	e001      	b.n	400fea <USBHS_Handler+0x11e>
			_usb_d_dev_handle_stall(ept);
  400fe6:	4b33      	ldr	r3, [pc, #204]	; (4010b4 <USBHS_Handler+0x1e8>)
  400fe8:	4798      	blx	r3
	for (i = 0; i < USB_D_N_EP; i++) {
  400fea:	3401      	adds	r4, #1
  400fec:	b2e4      	uxtb	r4, r4
  400fee:	2c03      	cmp	r4, #3
  400ff0:	d896      	bhi.n	400f20 <USBHS_Handler+0x54>
		struct _usb_d_dev_ep *ept = &dev_inst.ep[i];
  400ff2:	4a2d      	ldr	r2, [pc, #180]	; (4010a8 <USBHS_Handler+0x1dc>)
  400ff4:	00a3      	lsls	r3, r4, #2
  400ff6:	1919      	adds	r1, r3, r4
  400ff8:	0088      	lsls	r0, r1, #2
  400ffa:	4601      	mov	r1, r0
  400ffc:	3010      	adds	r0, #16
  400ffe:	4410      	add	r0, r2
  401000:	3004      	adds	r0, #4
		if (ept->ep == 0xFF) {
  401002:	440a      	add	r2, r1
  401004:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
  401008:	2bff      	cmp	r3, #255	; 0xff
  40100a:	d0ee      	beq.n	400fea <USBHS_Handler+0x11e>
		if (ep_int) {
  40100c:	2e00      	cmp	r6, #0
  40100e:	d1bd      	bne.n	400f8c <USBHS_Handler+0xc0>
		else if ((dma_int) && (_usb_d_dev_ep_is_dma(i))) {
  401010:	2d00      	cmp	r5, #0
  401012:	d0ea      	beq.n	400fea <USBHS_Handler+0x11e>
  401014:	1e63      	subs	r3, r4, #1
  401016:	b2db      	uxtb	r3, r3
  401018:	2b05      	cmp	r3, #5
  40101a:	d8e6      	bhi.n	400fea <USBHS_Handler+0x11e>
	uint8_t  epn = USB_EP_GET_N(ept->ep);
  40101c:	7c83      	ldrb	r3, [r0, #18]
  40101e:	f003 030f 	and.w	r3, r3, #15
	if (!(epint & (1u << (epn - 1)))) {
  401022:	1e5f      	subs	r7, r3, #1
  401024:	2201      	movs	r2, #1
  401026:	40ba      	lsls	r2, r7
  401028:	4215      	tst	r5, r2
  40102a:	d0de      	beq.n	400fea <USBHS_Handler+0x11e>
	if (hri_usbhs_get_DEVDMASTATUS_CHANN_ENB_bit(hw, (epn - 1))) {
  40102c:	b2fb      	uxtb	r3, r7
	return (((Usbhs *)hw)->UsbhsDevdma[submodule_index].USBHS_DEVDMASTATUS & USBHS_DEVDMASTATUS_CHANN_ENB)
  40102e:	0119      	lsls	r1, r3, #4
  401030:	4a21      	ldr	r2, [pc, #132]	; (4010b8 <USBHS_Handler+0x1ec>)
  401032:	5852      	ldr	r2, [r2, r1]
  401034:	f012 0f01 	tst.w	r2, #1
  401038:	d1d7      	bne.n	400fea <USBHS_Handler+0x11e>
	hri_usbhs_clear_DEVIMR_reg(hw, (USBHS_DEVIMR_DMA_1 << (epn - 1)));
  40103a:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
  40103e:	40b9      	lsls	r1, r7
	((Usbhs *)hw)->USBHS_DEVIDR = mask;
  401040:	4a18      	ldr	r2, [pc, #96]	; (4010a4 <USBHS_Handler+0x1d8>)
  401042:	6151      	str	r1, [r2, #20]
}

static inline hri_usbhs_devdmastatus_reg_t hri_usbhs_read_DEVDMASTATUS_BUFF_COUNT_bf(const void *const hw,
                                                                                     uint8_t           submodule_index)
{
	return (((Usbhs *)hw)->UsbhsDevdma[submodule_index].USBHS_DEVDMASTATUS & USBHS_DEVDMASTATUS_BUFF_COUNT_Msk)
  401044:	eb02 1303 	add.w	r3, r2, r3, lsl #4
  401048:	f8d3 231c 	ldr.w	r2, [r3, #796]	; 0x31c
	if (trans_next) {
  40104c:	0c12      	lsrs	r2, r2, #16
  40104e:	d003      	beq.n	401058 <USBHS_Handler+0x18c>
		ept->trans_count -= trans_next;
  401050:	6883      	ldr	r3, [r0, #8]
  401052:	1a9b      	subs	r3, r3, r2
  401054:	6083      	str	r3, [r0, #8]
		ept->trans_size = ept->trans_count;
  401056:	6043      	str	r3, [r0, #4]
	_usb_d_dev_dma_next(ept);
  401058:	4b18      	ldr	r3, [pc, #96]	; (4010bc <USBHS_Handler+0x1f0>)
  40105a:	4798      	blx	r3
  40105c:	e7c5      	b.n	400fea <USBHS_Handler+0x11e>
	if (flags & USBHS_DEVEPTISR_RXSTPI) {
  40105e:	f012 0f04 	tst.w	r2, #4
  401062:	d105      	bne.n	401070 <USBHS_Handler+0x1a4>
	} else if (flags & USBHS_DEVEPTISR_STALLEDI) {
  401064:	f012 0f40 	tst.w	r2, #64	; 0x40
  401068:	d0bf      	beq.n	400fea <USBHS_Handler+0x11e>
		_usb_d_dev_handle_stall(ept);
  40106a:	4b12      	ldr	r3, [pc, #72]	; (4010b4 <USBHS_Handler+0x1e8>)
  40106c:	4798      	blx	r3
  40106e:	e7bc      	b.n	400fea <USBHS_Handler+0x11e>
		_usb_d_dev_handle_setup(ept);
  401070:	4b0f      	ldr	r3, [pc, #60]	; (4010b0 <USBHS_Handler+0x1e4>)
  401072:	4798      	blx	r3
  401074:	e7b9      	b.n	400fea <USBHS_Handler+0x11e>
	if (flags & USBHS_DEVEPTISR_TXINI) {
  401076:	f012 0f01 	tst.w	r2, #1
  40107a:	d10a      	bne.n	401092 <USBHS_Handler+0x1c6>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
  40107c:	7cc3      	ldrb	r3, [r0, #19]
  40107e:	f003 0307 	and.w	r3, r3, #7
  401082:	2b01      	cmp	r3, #1
  401084:	d1b1      	bne.n	400fea <USBHS_Handler+0x11e>
		if (flags & USBHS_DEVEPTISR_RXSTPI) {
  401086:	f012 0f04 	tst.w	r2, #4
  40108a:	d0ae      	beq.n	400fea <USBHS_Handler+0x11e>
			_usb_d_dev_handle_setup(ept);
  40108c:	4b08      	ldr	r3, [pc, #32]	; (4010b0 <USBHS_Handler+0x1e4>)
  40108e:	4798      	blx	r3
  401090:	e7ab      	b.n	400fea <USBHS_Handler+0x11e>
		_usb_d_dev_in_next(ept);
  401092:	4b0b      	ldr	r3, [pc, #44]	; (4010c0 <USBHS_Handler+0x1f4>)
  401094:	4798      	blx	r3
  401096:	e7a8      	b.n	400fea <USBHS_Handler+0x11e>
		_usb_d_dev_handle_overflow(ept);
  401098:	4b0a      	ldr	r3, [pc, #40]	; (4010c4 <USBHS_Handler+0x1f8>)
  40109a:	4798      	blx	r3
  40109c:	e7a5      	b.n	400fea <USBHS_Handler+0x11e>
		_usb_d_dev_out_next(ept);
  40109e:	4b0a      	ldr	r3, [pc, #40]	; (4010c8 <USBHS_Handler+0x1fc>)
  4010a0:	4798      	blx	r3
  4010a2:	e7a2      	b.n	400fea <USBHS_Handler+0x11e>
  4010a4:	40038000 	.word	0x40038000
  4010a8:	204000ac 	.word	0x204000ac
  4010ac:	00400b05 	.word	0x00400b05
  4010b0:	00400a61 	.word	0x00400a61
  4010b4:	00400b69 	.word	0x00400b69
  4010b8:	4003831c 	.word	0x4003831c
  4010bc:	00400b8d 	.word	0x00400b8d
  4010c0:	00400cdd 	.word	0x00400cdd
  4010c4:	00400cb5 	.word	0x00400cb5
  4010c8:	00400df1 	.word	0x00400df1

004010cc <_usb_d_dev_init>:
{
  4010cc:	b508      	push	{r3, lr}
	tmp = ((Usbhs *)hw)->USBHS_CTRL;
  4010ce:	4b0e      	ldr	r3, [pc, #56]	; (401108 <_usb_d_dev_init+0x3c>)
  4010d0:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
	if (hri_usbhs_get_CTRL_USBE_bit(hw)) {
  4010d4:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  4010d8:	d113      	bne.n	401102 <_usb_d_dev_init+0x36>
	dev_inst.callbacks.sof   = (_usb_d_dev_sof_cb_t)_dummy_func_no_return;
  4010da:	4b0c      	ldr	r3, [pc, #48]	; (40110c <_usb_d_dev_init+0x40>)
  4010dc:	4a0c      	ldr	r2, [pc, #48]	; (401110 <_usb_d_dev_init+0x44>)
  4010de:	601a      	str	r2, [r3, #0]
	dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)_dummy_func_no_return;
  4010e0:	605a      	str	r2, [r3, #4]
	dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)_dummy_func_no_return;
  4010e2:	609a      	str	r2, [r3, #8]
	dev_inst.ep_callbacks.more  = (_usb_d_dev_ep_cb_more_t)_dummy_func_return_false;
  4010e4:	490b      	ldr	r1, [pc, #44]	; (401114 <_usb_d_dev_init+0x48>)
  4010e6:	60d9      	str	r1, [r3, #12]
	dev_inst.ep_callbacks.done  = (_usb_d_dev_ep_cb_done_t)_dummy_func_no_return;
  4010e8:	611a      	str	r2, [r3, #16]
	_usb_d_dev_reset_epts();
  4010ea:	4b0b      	ldr	r3, [pc, #44]	; (401118 <_usb_d_dev_init+0x4c>)
  4010ec:	4798      	blx	r3
	((Usbhs *)hw)->USBHS_CTRL = data;
  4010ee:	4b06      	ldr	r3, [pc, #24]	; (401108 <_usb_d_dev_init+0x3c>)
  4010f0:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  4010f4:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
	((Usbhs *)hw)->USBHS_DEVCTRL = data;
  4010f8:	f44f 6250 	mov.w	r2, #3328	; 0xd00
  4010fc:	601a      	str	r2, [r3, #0]
	return ERR_NONE;
  4010fe:	2000      	movs	r0, #0
  401100:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
  401102:	f06f 0010 	mvn.w	r0, #16
}
  401106:	bd08      	pop	{r3, pc}
  401108:	40038000 	.word	0x40038000
  40110c:	204000ac 	.word	0x204000ac
  401110:	00400a59 	.word	0x00400a59
  401114:	00400a5b 	.word	0x00400a5b
  401118:	00400b05 	.word	0x00400b05

0040111c <_usb_d_dev_ep_stall>:
	uint8_t               epn = USB_EP_GET_N(ep);
  40111c:	f000 000f 	and.w	r0, r0, #15
	struct _usb_d_dev_ep *ept = &dev_inst.ep[epn];
  401120:	eb00 0280 	add.w	r2, r0, r0, lsl #2
  401124:	0093      	lsls	r3, r2, #2
  401126:	3310      	adds	r3, #16
  401128:	4a48      	ldr	r2, [pc, #288]	; (40124c <_usb_d_dev_ep_stall+0x130>)
  40112a:	4413      	add	r3, r2
	if (epn > CONF_USB_D_MAX_EP_N) {
  40112c:	2803      	cmp	r0, #3
  40112e:	f200 8083 	bhi.w	401238 <_usb_d_dev_ep_stall+0x11c>
  401132:	3304      	adds	r3, #4
	if (USB_EP_STALL_SET == ctrl) {
  401134:	2901      	cmp	r1, #1
  401136:	d00a      	beq.n	40114e <_usb_d_dev_ep_stall+0x32>
	} else if (USB_EP_STALL_CLR == ctrl) {
  401138:	b3b9      	cbz	r1, 4011aa <_usb_d_dev_ep_stall+0x8e>
	return ept->flags.bits.is_stalled;
  40113a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  40113e:	0082      	lsls	r2, r0, #2
  401140:	4b42      	ldr	r3, [pc, #264]	; (40124c <_usb_d_dev_ep_stall+0x130>)
  401142:	4413      	add	r3, r2
  401144:	f893 0027 	ldrb.w	r0, [r3, #39]	; 0x27
  401148:	f3c0 00c0 	ubfx	r0, r0, #3, #1
  40114c:	4770      	bx	lr
	uint8_t epn = USB_EP_GET_N(ept->ep);
  40114e:	eb00 0380 	add.w	r3, r0, r0, lsl #2
  401152:	009a      	lsls	r2, r3, #2
  401154:	4b3d      	ldr	r3, [pc, #244]	; (40124c <_usb_d_dev_ep_stall+0x130>)
  401156:	4413      	add	r3, r2
  401158:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
  40115c:	f003 030f 	and.w	r3, r3, #15
	if (epn > CONF_USB_D_MAX_EP_N) {
  401160:	2b03      	cmp	r3, #3
  401162:	d86c      	bhi.n	40123e <_usb_d_dev_ep_stall+0x122>
	if (!ept->flags.bits.is_stalled) {
  401164:	eb00 0280 	add.w	r2, r0, r0, lsl #2
  401168:	0091      	lsls	r1, r2, #2
  40116a:	4a38      	ldr	r2, [pc, #224]	; (40124c <_usb_d_dev_ep_stall+0x130>)
  40116c:	440a      	add	r2, r1
  40116e:	f892 2027 	ldrb.w	r2, [r2, #39]	; 0x27
  401172:	f012 0f08 	tst.w	r2, #8
  401176:	d165      	bne.n	401244 <_usb_d_dev_ep_stall+0x128>
		ept->flags.bits.is_stalled = 1;
  401178:	4a34      	ldr	r2, [pc, #208]	; (40124c <_usb_d_dev_ep_stall+0x130>)
  40117a:	440a      	add	r2, r1
  40117c:	f892 1027 	ldrb.w	r1, [r2, #39]	; 0x27
  401180:	f041 0108 	orr.w	r1, r1, #8
  401184:	f882 1027 	strb.w	r1, [r2, #39]	; 0x27
	((Usbhs *)hw)->USBHS_DEVEPTIER[index] = data;
  401188:	4a31      	ldr	r2, [pc, #196]	; (401250 <_usb_d_dev_ep_stall+0x134>)
  40118a:	f103 007c 	add.w	r0, r3, #124	; 0x7c
  40118e:	2140      	movs	r1, #64	; 0x40
  401190:	f842 1020 	str.w	r1, [r2, r0, lsl #2]
	hri_usbhs_set_DEVIMR_reg(USBHS, USBHS_DEVIMR_PEP_0 << epn);
  401194:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  401198:	fa01 f303 	lsl.w	r3, r1, r3
	((Usbhs *)hw)->USBHS_DEVIER = mask;
  40119c:	6193      	str	r3, [r2, #24]
	((Usbhs *)hw)->USBHS_DEVEPTIER[index] = data;
  40119e:	f44f 2300 	mov.w	r3, #524288	; 0x80000
  4011a2:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
	return ERR_NONE;
  4011a6:	2000      	movs	r0, #0
  4011a8:	4770      	bx	lr
	uint8_t epn = USB_EP_GET_N(ept->ep);
  4011aa:	7c9a      	ldrb	r2, [r3, #18]
  4011ac:	f002 020f 	and.w	r2, r2, #15
	if (!ept->flags.bits.is_stalled) {
  4011b0:	7cd9      	ldrb	r1, [r3, #19]
  4011b2:	f011 0f08 	tst.w	r1, #8
  4011b6:	d047      	beq.n	401248 <_usb_d_dev_ep_stall+0x12c>
{
  4011b8:	b410      	push	{r4}
	((Usbhs *)hw)->USBHS_DEVEPTIDR[index] = data;
  4011ba:	4825      	ldr	r0, [pc, #148]	; (401250 <_usb_d_dev_ep_stall+0x134>)
  4011bc:	f102 0188 	add.w	r1, r2, #136	; 0x88
  4011c0:	f44f 2400 	mov.w	r4, #524288	; 0x80000
  4011c4:	f840 4021 	str.w	r4, [r0, r1, lsl #2]
  4011c8:	2440      	movs	r4, #64	; 0x40
  4011ca:	f840 4021 	str.w	r4, [r0, r1, lsl #2]
	return (((Usbhs *)hw)->USBHS_DEVEPTISR[index] & USBHS_DEVEPTISR_CTRL_STALLEDI) >> USBHS_DEVEPTISR_CTRL_STALLEDI_Pos;
  4011ce:	f102 014c 	add.w	r1, r2, #76	; 0x4c
  4011d2:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
	if (_usbd_ep_is_stall_sent(epn)) {
  4011d6:	f011 0f40 	tst.w	r1, #64	; 0x40
  4011da:	d014      	beq.n	401206 <_usb_d_dev_ep_stall+0xea>
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  4011dc:	4601      	mov	r1, r0
  4011de:	f102 0058 	add.w	r0, r2, #88	; 0x58
  4011e2:	f841 4020 	str.w	r4, [r1, r0, lsl #2]
	hri_usbhs_set_DEVEPT_reg(hw, USBHS_DEVEPT_EPRST0 << epn);
  4011e6:	f44f 3080 	mov.w	r0, #65536	; 0x10000
  4011ea:	4090      	lsls	r0, r2
	((Usbhs *)hw)->USBHS_DEVEPT |= mask;
  4011ec:	69cc      	ldr	r4, [r1, #28]
  4011ee:	4304      	orrs	r4, r0
  4011f0:	61cc      	str	r4, [r1, #28]
	((Usbhs *)hw)->USBHS_DEVEPT &= ~mask;
  4011f2:	69cc      	ldr	r4, [r1, #28]
  4011f4:	ea24 0000 	bic.w	r0, r4, r0
  4011f8:	61c8      	str	r0, [r1, #28]
	((Usbhs *)hw)->USBHS_DEVEPTIER[index] = data;
  4011fa:	f102 007c 	add.w	r0, r2, #124	; 0x7c
  4011fe:	f44f 2480 	mov.w	r4, #262144	; 0x40000
  401202:	f841 4020 	str.w	r4, [r1, r0, lsl #2]
	if (_usb_d_dev_ep_is_ctrl(ept)) {
  401206:	7cd9      	ldrb	r1, [r3, #19]
  401208:	f001 0107 	and.w	r1, r1, #7
  40120c:	2901      	cmp	r1, #1
  40120e:	d007      	beq.n	401220 <_usb_d_dev_ep_stall+0x104>
		ept->flags.bits.is_stalled = 0;
  401210:	7cda      	ldrb	r2, [r3, #19]
  401212:	f36f 02c3 	bfc	r2, #3, #1
  401216:	74da      	strb	r2, [r3, #19]
		rc = _usb_d_dev_ep_stall_clr(ept);
  401218:	2000      	movs	r0, #0
}
  40121a:	f85d 4b04 	ldr.w	r4, [sp], #4
  40121e:	4770      	bx	lr
	return ((Usbhs *)hw)->USBHS_DEVEPTISR[index];
  401220:	324c      	adds	r2, #76	; 0x4c
  401222:	490b      	ldr	r1, [pc, #44]	; (401250 <_usb_d_dev_ep_stall+0x134>)
  401224:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
		if ((hri_usbhs_read_DEVEPTISR_reg(USBHS, epn) & USBHS_DEVEPTISR_STALLEDI) == 0) {
  401228:	f012 0f40 	tst.w	r2, #64	; 0x40
  40122c:	d1f4      	bne.n	401218 <_usb_d_dev_ep_stall+0xfc>
			ept->flags.bits.is_stalled = 0;
  40122e:	7cda      	ldrb	r2, [r3, #19]
  401230:	f36f 02c3 	bfc	r2, #3, #1
  401234:	74da      	strb	r2, [r3, #19]
  401236:	e7ef      	b.n	401218 <_usb_d_dev_ep_stall+0xfc>
		return -USB_ERR_PARAM;
  401238:	f06f 0011 	mvn.w	r0, #17
  40123c:	4770      	bx	lr
		return ERR_NOT_FOUND;
  40123e:	f06f 0009 	mvn.w	r0, #9
  401242:	4770      	bx	lr
	return ERR_NONE;
  401244:	2000      	movs	r0, #0
  401246:	4770      	bx	lr
		rc = _usb_d_dev_ep_stall_clr(ept);
  401248:	2000      	movs	r0, #0
}
  40124a:	4770      	bx	lr
  40124c:	204000ac 	.word	0x204000ac
  401250:	40038000 	.word	0x40038000

00401254 <_usb_d_dev_ep_read_req>:
}

int32_t _usb_d_dev_ep_read_req(const uint8_t ep, uint8_t *req_buf)
{
  401254:	b410      	push	{r4}
	uint8_t epn = USB_EP_GET_N(ep);
  401256:	f000 000f 	and.w	r0, r0, #15
	tmp = ((Usbhs *)hw)->USBHS_DEVEPTISR[index];
  40125a:	f100 024c 	add.w	r2, r0, #76	; 0x4c
  40125e:	4b1b      	ldr	r3, [pc, #108]	; (4012cc <_usb_d_dev_ep_read_req+0x78>)
  401260:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
	return (hri_usbhs_get_DEVEPTISR_reg(USBHS, epn, USBHS_DEVEPTISR_BYCT_Msk) >> USBHS_DEVEPTISR_BYCT_Pos);
  401264:	f3c2 520a 	ubfx	r2, r2, #20, #11

	uint16_t bytes = _usbd_ep_get_trans_count(epn);

	if (epn > CONF_USB_D_MAX_EP_N || !req_buf) {
  401268:	460c      	mov	r4, r1
  40126a:	fab1 f181 	clz	r1, r1
  40126e:	0949      	lsrs	r1, r1, #5
  401270:	2803      	cmp	r0, #3
  401272:	bf88      	it	hi
  401274:	f041 0101 	orrhi.w	r1, r1, #1
  401278:	bb09      	cbnz	r1, 4012be <_usb_d_dev_ep_read_req+0x6a>
	tmp = ((Usbhs *)hw)->USBHS_DEVEPTCFG[index];
  40127a:	f100 0340 	add.w	r3, r0, #64	; 0x40
  40127e:	4913      	ldr	r1, [pc, #76]	; (4012cc <_usb_d_dev_ep_read_req+0x78>)
  401280:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
		return -USB_ERR_PARAM;
	}

	if (!_usbd_ep_is_ctrl(epn)) {
  401284:	f413 5fc0 	tst.w	r3, #6144	; 0x1800
  401288:	d11c      	bne.n	4012c4 <_usb_d_dev_ep_read_req+0x70>
	return (((Usbhs *)hw)->USBHS_DEVEPTISR[index] & USBHS_DEVEPTISR_CTRL_RXSTPI) >> USBHS_DEVEPTISR_CTRL_RXSTPI_Pos;
  40128a:	f100 034c 	add.w	r3, r0, #76	; 0x4c
  40128e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
		return -USB_ERR_FUNC;
	}

	if (!_usbd_ep_is_setup(epn)) {
  401292:	f013 0f04 	tst.w	r3, #4
  401296:	d103      	bne.n	4012a0 <_usb_d_dev_ep_read_req+0x4c>
		return ERR_NONE;
  401298:	2000      	movs	r0, #0
	memcpy(req_buf, (void *)ptr, 8);

	_usbd_ep_ack_setup(epn);

	return bytes;
}
  40129a:	f85d 4b04 	ldr.w	r4, [sp], #4
  40129e:	4770      	bx	lr
	uint8_t *ptr = (uint8_t *)&_usbd_ep_get_fifo_access(epn, 8);
  4012a0:	4b0b      	ldr	r3, [pc, #44]	; (4012d0 <_usb_d_dev_ep_read_req+0x7c>)
  4012a2:	eb03 33c0 	add.w	r3, r3, r0, lsl #15
	memcpy(req_buf, (void *)ptr, 8);
  4012a6:	6819      	ldr	r1, [r3, #0]
  4012a8:	685b      	ldr	r3, [r3, #4]
  4012aa:	6021      	str	r1, [r4, #0]
  4012ac:	6063      	str	r3, [r4, #4]
	((Usbhs *)hw)->USBHS_DEVEPTICR[index] = data;
  4012ae:	f100 0358 	add.w	r3, r0, #88	; 0x58
  4012b2:	2004      	movs	r0, #4
  4012b4:	4905      	ldr	r1, [pc, #20]	; (4012cc <_usb_d_dev_ep_read_req+0x78>)
  4012b6:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
	return bytes;
  4012ba:	4610      	mov	r0, r2
  4012bc:	e7ed      	b.n	40129a <_usb_d_dev_ep_read_req+0x46>
		return -USB_ERR_PARAM;
  4012be:	f06f 0011 	mvn.w	r0, #17
  4012c2:	e7ea      	b.n	40129a <_usb_d_dev_ep_read_req+0x46>
		return -USB_ERR_FUNC;
  4012c4:	f06f 0012 	mvn.w	r0, #18
  4012c8:	e7e7      	b.n	40129a <_usb_d_dev_ep_read_req+0x46>
  4012ca:	bf00      	nop
  4012cc:	40038000 	.word	0x40038000
  4012d0:	a0100000 	.word	0xa0100000

004012d4 <_usb_d_dev_ep_trans>:

int32_t _usb_d_dev_ep_trans(const struct usb_d_transfer *trans)
{
  4012d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4012d8:	b085      	sub	sp, #20
	Usbhs *               hw  = USBHS;
	uint8_t               epn = USB_EP_GET_N(trans->ep);
  4012da:	7a07      	ldrb	r7, [r0, #8]
  4012dc:	f007 040f 	and.w	r4, r7, #15
  4012e0:	b27f      	sxtb	r7, r7
	bool                  dir = USB_EP_GET_DIR(trans->ep);
  4012e2:	ea4f 79d7 	mov.w	r9, r7, lsr #31
	struct _usb_d_dev_ep *ept = &dev_inst.ep[epn];
  4012e6:	4a52      	ldr	r2, [pc, #328]	; (401430 <_usb_d_dev_ep_trans+0x15c>)
  4012e8:	00a3      	lsls	r3, r4, #2
  4012ea:	1919      	adds	r1, r3, r4
  4012ec:	008d      	lsls	r5, r1, #2
  4012ee:	3510      	adds	r5, #16
  4012f0:	4415      	add	r5, r2
  4012f2:	3504      	adds	r5, #4

	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
  4012f4:	0089      	lsls	r1, r1, #2
  4012f6:	440a      	add	r2, r1
  4012f8:	8c96      	ldrh	r6, [r2, #36]	; 0x24
  4012fa:	f240 33ff 	movw	r3, #1023	; 0x3ff
  4012fe:	429e      	cmp	r6, r3
  401300:	d001      	beq.n	401306 <_usb_d_dev_ep_trans+0x32>
  401302:	3e01      	subs	r6, #1
  401304:	b2b6      	uxth	r6, r6
	bool     size_n_aligned = (trans->size & size_mask);
  401306:	6843      	ldr	r3, [r0, #4]
  401308:	401e      	ands	r6, r3
	bool     is_ctrl        = _usb_d_dev_ep_is_ctrl(ept);
  40130a:	eb04 0384 	add.w	r3, r4, r4, lsl #2
  40130e:	009a      	lsls	r2, r3, #2
  401310:	4b47      	ldr	r3, [pc, #284]	; (401430 <_usb_d_dev_ep_trans+0x15c>)
  401312:	4413      	add	r3, r2
  401314:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  401318:	f003 0a07 	and.w	sl, r3, #7

	volatile hal_atomic_t flags;

	if (epn > CONF_USB_D_MAX_EP_N) {
  40131c:	2c03      	cmp	r4, #3
  40131e:	f200 8083 	bhi.w	401428 <_usb_d_dev_ep_trans+0x154>
		return -USB_ERR_PARAM;
	}

	/* Check halt */
	if (ept->flags.bits.is_stalled) {
  401322:	f013 0f08 	tst.w	r3, #8
  401326:	d003      	beq.n	401330 <_usb_d_dev_ep_trans+0x5c>
		return USB_HALTED;
  401328:	2002      	movs	r0, #2
#if (CONF_USB_D_DMA_ENABLE == 1)
	}
#endif

	return ERR_NONE;
}
  40132a:	b005      	add	sp, #20
  40132c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  401330:	4680      	mov	r8, r0
	atomic_enter_critical(&flags);
  401332:	a803      	add	r0, sp, #12
  401334:	4b3f      	ldr	r3, [pc, #252]	; (401434 <_usb_d_dev_ep_trans+0x160>)
  401336:	4798      	blx	r3
	if (_usb_d_dev_ep_is_busy(ept)) {
  401338:	eb04 0384 	add.w	r3, r4, r4, lsl #2
  40133c:	009a      	lsls	r2, r3, #2
  40133e:	4b3c      	ldr	r3, [pc, #240]	; (401430 <_usb_d_dev_ep_trans+0x15c>)
  401340:	4413      	add	r3, r2
  401342:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  401346:	f013 0f40 	tst.w	r3, #64	; 0x40
  40134a:	d128      	bne.n	40139e <_usb_d_dev_ep_trans+0xca>
	ept->flags.bits.is_busy = 1;
  40134c:	00a3      	lsls	r3, r4, #2
  40134e:	4423      	add	r3, r4
  401350:	009a      	lsls	r2, r3, #2
  401352:	4b37      	ldr	r3, [pc, #220]	; (401430 <_usb_d_dev_ep_trans+0x15c>)
  401354:	eb03 0b02 	add.w	fp, r3, r2
  401358:	f10b 0320 	add.w	r3, fp, #32
  40135c:	4619      	mov	r1, r3
  40135e:	79db      	ldrb	r3, [r3, #7]
  401360:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  401364:	9101      	str	r1, [sp, #4]
  401366:	71cb      	strb	r3, [r1, #7]
	atomic_leave_critical(&flags);
  401368:	a803      	add	r0, sp, #12
  40136a:	4b33      	ldr	r3, [pc, #204]	; (401438 <_usb_d_dev_ep_trans+0x164>)
  40136c:	4798      	blx	r3
	ept->trans_buf   = trans->buf;
  40136e:	f8d8 3000 	ldr.w	r3, [r8]
  401372:	f8cb 3014 	str.w	r3, [fp, #20]
	ept->trans_size  = trans->size;
  401376:	f8d8 3004 	ldr.w	r3, [r8, #4]
  40137a:	f8cb 3018 	str.w	r3, [fp, #24]
	ept->trans_count = 0;
  40137e:	2300      	movs	r3, #0
  401380:	f8cb 301c 	str.w	r3, [fp, #28]
	ept->trans_load  = 0;
  401384:	f8cb 3020 	str.w	r3, [fp, #32]
	ept->flags.bits.dir      = dir;
  401388:	9901      	ldr	r1, [sp, #4]
  40138a:	79cb      	ldrb	r3, [r1, #7]
  40138c:	f369 13c7 	bfi	r3, r9, #7, #1
  401390:	71cb      	strb	r3, [r1, #7]
	ept->flags.bits.need_zlp = (trans->zlp && (!size_n_aligned));
  401392:	f898 3009 	ldrb.w	r3, [r8, #9]
  401396:	b13b      	cbz	r3, 4013a8 <_usb_d_dev_ep_trans+0xd4>
  401398:	b386      	cbz	r6, 4013fc <_usb_d_dev_ep_trans+0x128>
  40139a:	2100      	movs	r1, #0
  40139c:	e005      	b.n	4013aa <_usb_d_dev_ep_trans+0xd6>
		atomic_leave_critical(&flags);
  40139e:	a803      	add	r0, sp, #12
  4013a0:	4b25      	ldr	r3, [pc, #148]	; (401438 <_usb_d_dev_ep_trans+0x164>)
  4013a2:	4798      	blx	r3
		return USB_BUSY;
  4013a4:	2001      	movs	r0, #1
  4013a6:	e7c0      	b.n	40132a <_usb_d_dev_ep_trans+0x56>
	ept->flags.bits.need_zlp = (trans->zlp && (!size_n_aligned));
  4013a8:	2100      	movs	r1, #0
  4013aa:	eb04 0384 	add.w	r3, r4, r4, lsl #2
  4013ae:	009a      	lsls	r2, r3, #2
  4013b0:	4b1f      	ldr	r3, [pc, #124]	; (401430 <_usb_d_dev_ep_trans+0x15c>)
  4013b2:	4413      	add	r3, r2
  4013b4:	f893 2027 	ldrb.w	r2, [r3, #39]	; 0x27
  4013b8:	f361 1204 	bfi	r2, r1, #4, #1
  4013bc:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
	if (_usb_d_dev_ep_is_dma(epn)) {
  4013c0:	1e63      	subs	r3, r4, #1
  4013c2:	b2db      	uxtb	r3, r3
  4013c4:	2b05      	cmp	r3, #5
  4013c6:	d91b      	bls.n	401400 <_usb_d_dev_ep_trans+0x12c>
		if (!is_ctrl) {
  4013c8:	f1ba 0f01 	cmp.w	sl, #1
  4013cc:	d004      	beq.n	4013d8 <_usb_d_dev_ep_trans+0x104>
			hri_usbhs_set_DEVIMR_reg(hw, (USBHS_DEVIER_PEP_0 << epn));
  4013ce:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  4013d2:	40a3      	lsls	r3, r4
	((Usbhs *)hw)->USBHS_DEVIER = mask;
  4013d4:	4a19      	ldr	r2, [pc, #100]	; (40143c <_usb_d_dev_ep_trans+0x168>)
  4013d6:	6193      	str	r3, [r2, #24]
	((Usbhs *)hw)->USBHS_DEVEPTCFG[index] &= ~USBHS_DEVEPTCFG_AUTOSW;
  4013d8:	4a18      	ldr	r2, [pc, #96]	; (40143c <_usb_d_dev_ep_trans+0x168>)
  4013da:	f104 0140 	add.w	r1, r4, #64	; 0x40
  4013de:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
  4013e2:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  4013e6:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
		if (dir) {
  4013ea:	2f00      	cmp	r7, #0
  4013ec:	db15      	blt.n	40141a <_usb_d_dev_ep_trans+0x146>
	((Usbhs *)hw)->USBHS_DEVEPTIER[index] = data;
  4013ee:	347c      	adds	r4, #124	; 0x7c
  4013f0:	2202      	movs	r2, #2
  4013f2:	4b12      	ldr	r3, [pc, #72]	; (40143c <_usb_d_dev_ep_trans+0x168>)
  4013f4:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
	return ERR_NONE;
  4013f8:	2000      	movs	r0, #0
  4013fa:	e796      	b.n	40132a <_usb_d_dev_ep_trans+0x56>
	ept->flags.bits.need_zlp = (trans->zlp && (!size_n_aligned));
  4013fc:	2101      	movs	r1, #1
  4013fe:	e7d4      	b.n	4013aa <_usb_d_dev_ep_trans+0xd6>
	((Usbhs *)hw)->USBHS_DEVEPTCFG[index] |= USBHS_DEVEPTCFG_AUTOSW;
  401400:	4a0e      	ldr	r2, [pc, #56]	; (40143c <_usb_d_dev_ep_trans+0x168>)
  401402:	3440      	adds	r4, #64	; 0x40
  401404:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
  401408:	f443 7300 	orr.w	r3, r3, #512	; 0x200
  40140c:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
		_usb_d_dev_dma_next(ept);
  401410:	4628      	mov	r0, r5
  401412:	4b0b      	ldr	r3, [pc, #44]	; (401440 <_usb_d_dev_ep_trans+0x16c>)
  401414:	4798      	blx	r3
	return ERR_NONE;
  401416:	2000      	movs	r0, #0
  401418:	e787      	b.n	40132a <_usb_d_dev_ep_trans+0x56>
	((Usbhs *)hw)->USBHS_DEVEPTIER[index] = data;
  40141a:	347c      	adds	r4, #124	; 0x7c
  40141c:	2201      	movs	r2, #1
  40141e:	4b07      	ldr	r3, [pc, #28]	; (40143c <_usb_d_dev_ep_trans+0x168>)
  401420:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
  401424:	2000      	movs	r0, #0
  401426:	e780      	b.n	40132a <_usb_d_dev_ep_trans+0x56>
		return -USB_ERR_PARAM;
  401428:	f06f 0011 	mvn.w	r0, #17
  40142c:	e77d      	b.n	40132a <_usb_d_dev_ep_trans+0x56>
  40142e:	bf00      	nop
  401430:	204000ac 	.word	0x204000ac
  401434:	00400351 	.word	0x00400351
  401438:	0040035f 	.word	0x0040035f
  40143c:	40038000 	.word	0x40038000
  401440:	00400b8d 	.word	0x00400b8d

00401444 <_usb_d_dev_register_ep_callback>:
	}
}

void _usb_d_dev_register_ep_callback(const enum usb_d_dev_ep_cb_type type, const FUNC_PTR func)
{
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
  401444:	460b      	mov	r3, r1
  401446:	b129      	cbz	r1, 401454 <_usb_d_dev_register_ep_callback+0x10>

	if (type == USB_D_DEV_EP_CB_SETUP) {
  401448:	b130      	cbz	r0, 401458 <_usb_d_dev_register_ep_callback+0x14>
		dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)f;
	} else if (type == USB_D_DEV_EP_CB_MORE) {
  40144a:	2801      	cmp	r0, #1
  40144c:	d007      	beq.n	40145e <_usb_d_dev_register_ep_callback+0x1a>
		dev_inst.ep_callbacks.more = (_usb_d_dev_ep_cb_more_t)f;
	} else if (type == USB_D_DEV_EP_CB_DONE) {
  40144e:	2802      	cmp	r0, #2
  401450:	d008      	beq.n	401464 <_usb_d_dev_register_ep_callback+0x20>
  401452:	4770      	bx	lr
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
  401454:	4b05      	ldr	r3, [pc, #20]	; (40146c <_usb_d_dev_register_ep_callback+0x28>)
  401456:	e7f7      	b.n	401448 <_usb_d_dev_register_ep_callback+0x4>
		dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)f;
  401458:	4a05      	ldr	r2, [pc, #20]	; (401470 <_usb_d_dev_register_ep_callback+0x2c>)
  40145a:	6093      	str	r3, [r2, #8]
  40145c:	4770      	bx	lr
		dev_inst.ep_callbacks.more = (_usb_d_dev_ep_cb_more_t)f;
  40145e:	4a04      	ldr	r2, [pc, #16]	; (401470 <_usb_d_dev_register_ep_callback+0x2c>)
  401460:	60d3      	str	r3, [r2, #12]
  401462:	4770      	bx	lr
		dev_inst.ep_callbacks.done = (_usb_d_dev_ep_cb_done_t)f;
  401464:	4a02      	ldr	r2, [pc, #8]	; (401470 <_usb_d_dev_register_ep_callback+0x2c>)
  401466:	6113      	str	r3, [r2, #16]
	}
}
  401468:	e7f3      	b.n	401452 <_usb_d_dev_register_ep_callback+0xe>
  40146a:	bf00      	nop
  40146c:	00400a59 	.word	0x00400a59
  401470:	204000ac 	.word	0x204000ac

00401474 <read_trig_channel>:
 *
 * \param[in] pin       The pin number for device
 */
static inline bool gpio_get_pin_level(const uint8_t pin)
{
	return (bool)(_gpio_get_level((enum gpio_port)GPIO_PORT(pin)) & (0x01U << GPIO_PIN(pin)));
  401474:	0942      	lsrs	r2, r0, #5
 * \brief Transfer gpio_port to hardware address
 */
static inline void *port_to_reg(const enum gpio_port port)
{
	/* PIO instance offset is 0x200 */
	return (void *)((uint32_t)PIOA + port * 0x200);
  401476:	4b07      	ldr	r3, [pc, #28]	; (401494 <read_trig_channel+0x20>)
  401478:	eb03 2342 	add.w	r3, r3, r2, lsl #9
	return ((Pio *)hw)->PIO_PDSR;
  40147c:	6bda      	ldr	r2, [r3, #60]	; 0x3c
  40147e:	f000 001f 	and.w	r0, r0, #31
  401482:	2301      	movs	r3, #1
  401484:	fa03 f000 	lsl.w	r0, r3, r0
  401488:	4202      	tst	r2, r0
bool read_trig_channel(const uint8_t ch)
{
	bool status = gpio_get_pin_level(ch);
	// printf("trigger status: %s", status ? "true" : "false"); // need to set up serial for this to work
	return status;
}
  40148a:	bf14      	ite	ne
  40148c:	4618      	movne	r0, r3
  40148e:	2000      	moveq	r0, #0
  401490:	4770      	bx	lr
  401492:	bf00      	nop
  401494:	400e0e00 	.word	0x400e0e00

00401498 <main>:

int main(void)
{
  401498:	b508      	push	{r3, lr}
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
  40149a:	4b0a      	ldr	r3, [pc, #40]	; (4014c4 <main+0x2c>)
  40149c:	4798      	blx	r3
	delay_init(TC2);
  40149e:	480a      	ldr	r0, [pc, #40]	; (4014c8 <main+0x30>)
  4014a0:	4b0a      	ldr	r3, [pc, #40]	; (4014cc <main+0x34>)
  4014a2:	4798      	blx	r3
  4014a4:	e003      	b.n	4014ae <main+0x16>
		if (ch_status) 
		{
			start_timer(TC2, 2);
		}
		else {
			stop_timer(TC2, 2);
  4014a6:	2102      	movs	r1, #2
  4014a8:	4807      	ldr	r0, [pc, #28]	; (4014c8 <main+0x30>)
  4014aa:	4b09      	ldr	r3, [pc, #36]	; (4014d0 <main+0x38>)
  4014ac:	4798      	blx	r3
		bool ch_status = read_trig_channel(PB3_TRIG);
  4014ae:	2023      	movs	r0, #35	; 0x23
  4014b0:	4b08      	ldr	r3, [pc, #32]	; (4014d4 <main+0x3c>)
  4014b2:	4798      	blx	r3
		if (ch_status) 
  4014b4:	2800      	cmp	r0, #0
  4014b6:	d0f6      	beq.n	4014a6 <main+0xe>
			start_timer(TC2, 2);
  4014b8:	2102      	movs	r1, #2
  4014ba:	4803      	ldr	r0, [pc, #12]	; (4014c8 <main+0x30>)
  4014bc:	4b06      	ldr	r3, [pc, #24]	; (4014d8 <main+0x40>)
  4014be:	4798      	blx	r3
  4014c0:	e7f5      	b.n	4014ae <main+0x16>
  4014c2:	bf00      	nop
  4014c4:	004001d5 	.word	0x004001d5
  4014c8:	40014000 	.word	0x40014000
  4014cc:	0040036d 	.word	0x0040036d
  4014d0:	00400a4d 	.word	0x00400a4d
  4014d4:	00401475 	.word	0x00401475
  4014d8:	00400a41 	.word	0x00400a41

004014dc <__libc_init_array>:
  4014dc:	b570      	push	{r4, r5, r6, lr}
  4014de:	4e0d      	ldr	r6, [pc, #52]	; (401514 <__libc_init_array+0x38>)
  4014e0:	4c0d      	ldr	r4, [pc, #52]	; (401518 <__libc_init_array+0x3c>)
  4014e2:	1ba4      	subs	r4, r4, r6
  4014e4:	10a4      	asrs	r4, r4, #2
  4014e6:	2500      	movs	r5, #0
  4014e8:	42a5      	cmp	r5, r4
  4014ea:	d109      	bne.n	401500 <__libc_init_array+0x24>
  4014ec:	4e0b      	ldr	r6, [pc, #44]	; (40151c <__libc_init_array+0x40>)
  4014ee:	4c0c      	ldr	r4, [pc, #48]	; (401520 <__libc_init_array+0x44>)
  4014f0:	f000 f84c 	bl	40158c <_init>
  4014f4:	1ba4      	subs	r4, r4, r6
  4014f6:	10a4      	asrs	r4, r4, #2
  4014f8:	2500      	movs	r5, #0
  4014fa:	42a5      	cmp	r5, r4
  4014fc:	d105      	bne.n	40150a <__libc_init_array+0x2e>
  4014fe:	bd70      	pop	{r4, r5, r6, pc}
  401500:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  401504:	4798      	blx	r3
  401506:	3501      	adds	r5, #1
  401508:	e7ee      	b.n	4014e8 <__libc_init_array+0xc>
  40150a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  40150e:	4798      	blx	r3
  401510:	3501      	adds	r5, #1
  401512:	e7f2      	b.n	4014fa <__libc_init_array+0x1e>
  401514:	00401598 	.word	0x00401598
  401518:	00401598 	.word	0x00401598
  40151c:	00401598 	.word	0x00401598
  401520:	0040159c 	.word	0x0040159c

00401524 <memcpy>:
  401524:	b510      	push	{r4, lr}
  401526:	1e43      	subs	r3, r0, #1
  401528:	440a      	add	r2, r1
  40152a:	4291      	cmp	r1, r2
  40152c:	d100      	bne.n	401530 <memcpy+0xc>
  40152e:	bd10      	pop	{r4, pc}
  401530:	f811 4b01 	ldrb.w	r4, [r1], #1
  401534:	f803 4f01 	strb.w	r4, [r3, #1]!
  401538:	e7f7      	b.n	40152a <memcpy+0x6>

0040153a <memset>:
  40153a:	4402      	add	r2, r0
  40153c:	4603      	mov	r3, r0
  40153e:	4293      	cmp	r3, r2
  401540:	d100      	bne.n	401544 <memset+0xa>
  401542:	4770      	bx	lr
  401544:	f803 1b01 	strb.w	r1, [r3], #1
  401548:	e7f9      	b.n	40153e <memset+0x4>
	...

0040154c <_ext_irq>:
	...

00401568 <_pio_irq_n>:
  401568:	0b0a 100c 0011 0000 2e2e 682f 6c70 702f     ........../hpl/p
  401578:	6f69 682f 6c70 705f 6f69 655f 7478 632e     io/hpl_pio_ext.c
  401588:	0000 0000                                   ....

0040158c <_init>:
  40158c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40158e:	bf00      	nop
  401590:	bcf8      	pop	{r3, r4, r5, r6, r7}
  401592:	bc08      	pop	{r3}
  401594:	469e      	mov	lr, r3
  401596:	4770      	bx	lr

00401598 <__init_array_start>:
  401598:	0040018d 	.word	0x0040018d

0040159c <_fini>:
  40159c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40159e:	bf00      	nop
  4015a0:	bcf8      	pop	{r3, r4, r5, r6, r7}
  4015a2:	bc08      	pop	{r3}
  4015a4:	469e      	mov	lr, r3
  4015a6:	4770      	bx	lr

004015a8 <__fini_array_start>:
  4015a8:	00400169 	.word	0x00400169
